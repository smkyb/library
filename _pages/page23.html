<pre>template<typename T, typename S, auto op, auto e>
struct meldable_binary_trie{
    static_assert(is_unsigned_v<T>);
    
    static constexpr T one = 1;
    static constexpr int bit_width = sizeof(T) * 8;
    
    struct node_t{
        T value;
        S sum;
        int width;
        int count;
        array<node_t*, 4> child;
        node_t() = default;
        node_t(T v, S s, int w, int c) : value(v), sum(s), width(w), count(c), child{&nil, &nil, &nil, &nil} {}
        node_t(T v, S s, int w, int c, node_t* c0, node_t* c1, node_t* c2, node_t* c3) : value(v), sum(s), width(w), count(c), child{c0, c1, c2, c3} {}
        static node_t nil;
    };
    
    struct ref_node_t{
        T val;
        bool exist;
        ref_node_t(T x, bool _e) : val{x}, exist{_e} {}
    };
    
    struct Pool {
        int cnt = 0;
        constexpr static int SIZ = 1<<17;
        node_t *ptr = nullptr, *en = nullptr;
        vector<node_t*> reuse;
        Pool() {
            ptr = new node_t[SIZ];
            en = ptr + SIZ;
        }
        node_t *get() {
            if(ptr == en) {
                if(!reuse.empty()) {
                    auto ptr = reuse.back();
                    reuse.pop_back();
                    return ptr;
                }
                ptr = new node_t[SIZ];
                en = ptr + SIZ;
            }
            return ptr++;
        }
        void push(node_t *p) {reuse.push_back(p);}
    };
    
    static Pool pool;
    node_t* root;
    bool rev = false;
    
    template<typename _Tp>
    inline static int clz(_Tp x) {
        if constexpr(sizeof(_Tp) == 8ull) return __builtin_clzll(x);
        else return __builtin_clz(x);
    }
    
    inline static T mask(int l, int r) {
        if(r >= bit_width) return -(one<<l);
        return (one<<r) - (one<<l);
    }
    
    inline static T masked(T v, int l, int r) {
        return mask(l, r) & v;
    }
    
    inline static int diff_bit(T x, T y) {
        return ((bit_width-1 - clz(x^y))|1) + 1;
    }
    
    //value, sum, width, count, child
    template<typename... Args>
    static inline node_t* make_node(Args ...args) {
        return &((*pool.get()) = node_t(forward<Args>(args)...));
    }
    
    public:
    
    meldable_binary_trie(){
        root = make_node(0, e(), bit_width, 0);
    }
    meldable_binary_trie(T p, const S &x){
        root = make_node(p, x, bit_width, 1);
    }
    meldable_binary_trie(node_t *x){
        root = x;
    }
    
    meldable_binary_trie& operator=(meldable_binary_trie&& o) noexcept = default;
    
    meldable_binary_trie(meldable_binary_trie&& o) noexcept = default;
    
    void insert(T v, const S &x) {
        node_t* pos = root;
        int bit = bit_width;
        node_t *route[65]; int route_cnt = 0;
        while(true){
            T mv = masked(v, bit-pos->width, bit);
            T mnv = masked(pos->value, bit-pos->width, bit);
            if(mv != mnv){
                route[route_cnt++] = pos;
                int diff = diff_bit(mv, mnv);
                int b = (mv>>(diff-2))&3;
                int nb = (mnv>>(diff-2))&3;
                node_t* inter = make_node(pos->value, pos->sum, pos->width-bit+diff, pos->count, pos->child[0], pos->child[1], pos->child[2], pos->child[3]);
                node_t* leaf = make_node(v, x, diff, 1);
                pos->width = bit-diff;
                pos->count++;
                pos->child = {&node_t::nil, &node_t::nil, &node_t::nil, &node_t::nil};
                pos->child[b] = leaf;
                pos->child[nb] = inter;
                break;
            } else {
                pos->count++;
                bit -= pos->width;
                if(bit == 0) {
                    pos->sum = x;
                    break;
                }
                route[route_cnt++] = pos;
                int b = (v>>(bit-2))&3;
                if(pos->child[b] == &node_t::nil){
                    pos->child[b] = make_node(v, x, bit, 1);
                    break;
                }
                pos = pos->child[b];
            }
        }
        for(int i = route_cnt-1; i >= 0; i--){
            node_t *ptr = route[i];
            ptr->sum = op(op(op(ptr->child[0]->sum, ptr->child[1]->sum), ptr->child[2]->sum), ptr->child[3]->sum);
        }
    }
    
    int count(T v) const {
        node_t* pos = root;
        int bit = bit_width;
        while(pos != &node_t::nil){
            T mv = masked(v, bit-pos->width, bit);
            T mnv = masked(pos->value, bit-pos->width, bit);
            if(mv != mnv) return 0;
            bit -= pos->width;
            if(bit == 0) return pos->count;
            pos = pos->child[(v>>(bit-2))&3];
        }
        return 0;
    }
    
    int size() const {
        return root->count;
    }
    
    static node_t *meld(meldable_binary_trie &l, meldable_binary_trie &r){
        return meld(l.root, r.root);
    }
    static node_t *meld(node_t *l, node_t *r){
        node_t *res = meld(l, r, bit_width);
        return res;
    }
    static node_t *meld(node_t *l, node_t *r, int bit){
        if(l->count == 0){
            return r;
        }
        if(r->count == 0){
            return l;
        }
        T mlv = masked(l->value, min(bit-l->width, bit-r->width), bit);
        T mrv = masked(r->value, min(bit-l->width, bit-r->width), bit);
        if(mlv == mrv){
            if(l->width == r->width){
                l->count += r->count;
                if(bit == l->width){
                    l->sum = op(l->sum, r->sum);
                    return l;
                } else {
                    for(int i = 0; i < 4; i++) l->child[i] = meld(l->child[i], r->child[i], bit - l->width);
                    pool.push(r);
                }
            } else {
                if(l->width > r->width) swap(l, r);
                l->count += r->count;
                bit -= l->width;
                r->width -= l->width;
                int b = (r->value>>(bit-2))&3;
                l->child[b] = meld(l->child[b], r, bit);
            }
        } else {
            if(l->width > r->width) swap(l, r);
            int diff = diff_bit(mlv, mrv);
            if(l->width <= bit - diff){
                l->count += r->count;
                r->width -= l->width;
                bit -= l->width;
                int b = (r->value>>(bit-2))&3;
                l->child[b] = meld(l->child[b], r, bit);
            } else {
                node_t *ptr = make_node(l->value, l->sum, l->width-bit+diff, l->count, l->child[0], l->child[1], l->child[2], l->child[3]);
                memcpy(l->child.data(), node_t::nil.child.data(), sizeof(node_t*) * 4);
                r->width -= bit - diff;
                l->width = bit - diff;
                l->count += r->count;
                l->child[l->value>>(diff-2)&3] = ptr;
                l->child[r->value>>(diff-2)&3] = r;
            }
        }
        l->sum = op(op(op(l->child[0]->sum, l->child[1]->sum), l->child[2]->sum), l->child[3]->sum);
        return l;
    }
    
    pair<meldable_binary_trie, meldable_binary_trie> split(int p){
        if(rev) p = root->count-p;
        auto res = split(root, p);
        if(rev){
            meldable_binary_trie f(res.second), s(res.first);
            f.rev = true; s.rev = true;
            return make_pair(move(f), move(s));
        } else return {meldable_binary_trie(res.first), meldable_binary_trie(res.second)};
    }
    
    static pair<node_t*, node_t*> split(node_t *l, int p){
        if(p == 0) return {&node_t::nil, l};
        if(p == l->count) return {l, &node_t::nil};
        int acc = 0;
        
        for (int i = 0; i < 4; i++) {
            int c = l->child[i]->count;
            if (p < acc + c) {
                auto sub = split(l->child[i], p - acc);
                
                node_t *ptr = make_node(l->value, e(), l->width, 0);
                
                l->child[i] = sub.first;
                ptr->child[i] = sub.second;
                for(int j = i+1; j < 4; j++) ptr->child[j] = l->child[j];
                for(int j = i+1; j < 4; j++) l->child[j] = &node_t::nil;
                
                l->count = 0;
                for(int j = 0; j <= i; j++) l->count += l->child[j]->count;
                for(int j = i; j < 4; j++) ptr->count += ptr->child[j]->count;
                
                l->sum = e();
                for(int j = 0; j <= i; j++) l->sum = op(l->sum, l->child[j]->sum);
                for(int j = i; j < 4; j++) ptr->sum = op(ptr->sum, ptr->child[j]->sum);
                
                return {l, ptr};
            }
            acc += c;
        }
        assert(false);
    }
    
    meldable_binary_trie split_one(){
        if(rev){
            meldable_binary_trie res(split_one_rev(root));
            res.rev = true;
            return move(res);
        } else {
            return meldable_binary_trie(split_one(root));
        }
    }
    node_t *split_one(node_t *l){
        if(l->count == 1) return &node_t::nil;
        
        l->count--;
        for(int i = 0; i < 4; i++){
            int c = l->child[i]->count;
            if(c == 0) continue;
            l->child[i] = split_one(l->child[i]);
            l->sum = e();
            for(int j = i; j < 4; j++) l->sum = op(l->sum, l->child[j]->sum);
            return l;
        }
        assert(false);
    }
    node_t *split_one_rev(node_t *l){
        if(l->count == 1) return &node_t::nil;
        
        l->count--;
        for(int i = 3; i >= 0; i--){
            int c = l->child[i]->count;
            if(c == 0) continue;
            l->child[i] = split_one_rev(l->child[i]);
            l->sum = e();
            for(int j = 0; j <= i; j++) l->sum = op(l->sum, l->child[j]->sum);
            return l;
        }
        assert(false);
    }
    
    S all_prod() const {return root->sum;}
    
    void init(T p, const S &x){
        root = make_node(p, x, bit_width, 1);
    }
    
    static int get_size(node_t *ptr){
        if(ptr == &node_t::nil) return 0;
        int res = 1;
        for(int i = 0; i < 4; i++) res += get_size(ptr->child[i]);
        return res;
    }
};
template<typename T, typename S, auto op, auto e> typename meldable_binary_trie<T, S, op, e>::node_t meldable_binary_trie<T, S, op, e>::node_t::nil = meldable_binary_trie<T, S, op, e>::node_t(0, e(), bit_width, 0);
template<typename T, typename S, auto op, auto e> typename meldable_binary_trie<T, S, op, e>::Pool meldable_binary_trie<T, S, op, e>::pool = meldable_binary_trie<T, S, op, e>::Pool();</pre>