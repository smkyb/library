{
	"0_cpptosnippet": {
		"prefix": "0_cpptosnippet",
		"body": [
			"#undef _GLIBCXX_DEBUG",
			"#include <iostream>",
			"#include <filesystem>",
			"#include <fstream>",
			"#include <vector>",
			"#include <string>",
			"",
			"namespace fs = std::filesystem;",
			"",
			"std::string escapeJsonString(const std::string& input) {",
			"    std::string output;",
			"    for (char c : input) {",
			"        switch(c) {",
			"            case '\\\"': output += \"\\\\\\\"\"; break;",
			"            case '\\\\': output += \"\\\\\\\\\"; break;",
			"            default: output += c; break;",
			"        }",
			"    }",
			"    return output;",
			"}",
			"",
			"void generateSnippetJson(const std::string& directory, const std::string& outputFile) {",
			"    std::ofstream outFile(outputFile);",
			"    if (!outFile) {",
			"        std::cerr << \"Failed to open output file: \" << outputFile << std::endl;",
			"        return;",
			"    }",
			"    ",
			"    outFile << \"{\\n\";",
			"    ",
			"    bool firstEntry = true;",
			"    for (const auto& entry : fs::recursive_directory_iterator(directory)) {",
			"        if (entry.path().extension() == \".cpp\" || entry.path().extension() == \".hpp\") {",
			"            if (!firstEntry) {",
			"                outFile << \",\\n\\t\\n\";",
			"            }",
			"            firstEntry = false;",
			"            ",
			"            std::ifstream inFile(entry.path());",
			"            if (!inFile) continue;",
			"            ",
			"            std::cout << entry << std::endl;",
			"            ",
			"            std::vector<std::string> lines;",
			"            std::string line;",
			"            while (std::getline(inFile, line)) {",
			"                std::string escapedLine = escapeJsonString(line);",
			"                lines.push_back(\"\\\"\" + escapedLine + \"\\\"\");",
			"            }",
			"            ",
			"            std::string key = entry.path().stem().string();",
			"            outFile << \"\\t\\\"\" << escapeJsonString(key) << \"\\\": {\\n\";",
			"            outFile << \"\\t\\t\\\"prefix\\\": \\\"\" << escapeJsonString(key) << \"\\\",\\n\";",
			"            outFile << \"\\t\\t\\\"body\\\": [\\n\";",
			"            for (size_t i = 0; i < lines.size(); ++i) {",
			"                outFile << \"\\t\\t\\t\" << lines[i];",
			"                if (i != lines.size() - 1) {",
			"                    outFile << \",\";",
			"                }",
			"                outFile << \"\\n\";",
			"            }",
			"            outFile << \"\\t\\t]\\n\";",
			"            outFile << \"\\t}\";",
			"        }",
			"    }",
			"    ",
			"    outFile << \"\\n}\";",
			"    outFile.close();",
			"    std::cout << std::endl;",
			"    std::cout << \"cpp.json has been generated successfully.\" << std::endl;",
			"}",
			"",
			"int main(){",
			"    //.cppや.hppが入っているフォルダを指定する",
			"    std::string directory = \"C:\\\\vscode programs\\\\Libraries\";",
			"    //出力に使用するファイルを指定する（無い場合は新たに作られる？）",
			"    std::string outputfile = \"0_output.txt\";",
			"    ",
			"    generateSnippetJson(directory, outputfile);",
			"}"
		]
	},
	
	"4dydx": {
		"prefix": "4dydx",
		"body": [
			"for(int dk = 0; dk < 4; dk++){",
			"    int ny = y+dy[dk], nx = x+dx[dk];",
			"    $1",
			"}"
		]
	},
	
	"binary_trie": {
		"prefix": "binary_trie",
		"body": [
			"template <typename T>",
			"struct binary_trie{",
			"    static_assert(is_unsigned_v<T>);",
			"    ",
			"    private:",
			"    ",
			"    struct node_t{",
			"        T value;",
			"        int count = 0;",
			"        array<int, 4> child = {};",
			"        int width = 0;",
			"    };",
			"    ",
			"    struct ref_node_t{",
			"        T val;",
			"        bool exist;",
			"        ref_node_t(T x, bool e) : val{x}, exist{e} {}",
			"    };",
			"    ",
			"    static constexpr T one = 1;",
			"    static constexpr int bit_width = sizeof(T) * 8;",
			"    vector<node_t> node;",
			"    T xor_val = 0;",
			"    int root = -1;",
			"    int siz = 0;",
			"    ",
			"    //__builtin_clz",
			"    template<typename _Tp>",
			"    inline int clz(_Tp x) const {",
			"        if constexpr(sizeof(_Tp) == 8ull) return __builtin_clzll(x);",
			"        else return __builtin_clz(x);",
			"    }",
			"    ",
			"    inline T mask(int l, int r) const {",
			"        if(r >= bit_width) return -(one<<l);",
			"        return (one<<r) - (one<<l);",
			"    }",
			"    ",
			"    inline T masked(T v, int l, int r) const {",
			"        return mask(l, r) & v;",
			"    }",
			"    ",
			"    inline int diff_bit(T x, T y) const {",
			"        return ((bit_width-1 - clz(x^y))|1) + 1;",
			"    }",
			"    ",
			"    inline int make_node(T v){",
			"        node.emplace_back();",
			"        node.back().value = v;",
			"        return ssize(node)-1;",
			"    }",
			"    ",
			"    public:",
			"    ",
			"    binary_trie(){",
			"        make_node(0);",
			"        root = make_node(0);",
			"        node[root].width = bit_width;",
			"    }",
			"    ",
			"    binary_trie<T>& operator=(binary_trie<T>&& o) noexcept = default;",
			"    ",
			"    binary_trie(binary_trie&& o) noexcept = default;",
			"    ",
			"    void insert(T v) {",
			"        int pos = root;",
			"        int bit = bit_width;",
			"        siz++;",
			"        v ^= xor_val;",
			"        while(pos != 0){",
			"            T mv = masked(v, bit-node[pos].width, bit);",
			"            T mnv = masked(node[pos].value, bit-node[pos].width, bit);",
			"            if(mv != mnv){",
			"                int diff = diff_bit(mv, mnv);",
			"                int b = (mv>>(diff-2))&3;",
			"                int nb = (mnv>>(diff-2))&3;",
			"                int inter = make_node(node[pos].value);",
			"                int leaf = make_node(v);",
			"                node[inter] = node[pos];",
			"                node[inter].width -= bit - diff;",
			"                memset(node[pos].child.data(), 0, sizeof(int)*4);",
			"                node[pos].child[b] = leaf;",
			"                node[pos].child[nb] = inter;",
			"                node[pos].count++;",
			"                node[pos].width = bit - diff;",
			"                bit = diff;",
			"                node[leaf].width = bit;",
			"                node[leaf].count = 1;",
			"                pos = leaf;",
			"                return;",
			"            } else {",
			"                node[pos].count++;",
			"                bit -= node[pos].width;",
			"                if(bit == 0) return;",
			"                int nex = node[pos].child[(v>>(bit-2))&3];",
			"                if(nex == 0){",
			"                    nex = node[pos].child[(v>>(bit-2))&3] = make_node(v);",
			"                    node[nex].count = 1;",
			"                    node[nex].width = bit;",
			"                    return;",
			"                }",
			"                pos = nex;",
			"            }",
			"        }",
			"    }",
			"    ",
			"    int count(T v) const {",
			"        int pos = root;",
			"        int bit = bit_width;",
			"        v ^= xor_val;",
			"        while(pos != 0){",
			"            T mv = masked(v, bit-node[pos].width, bit);",
			"            T mnv = masked(node[pos].value, bit-node[pos].width, bit);",
			"            if(mv != mnv) return 0;",
			"            bit -= node[pos].width;",
			"            if(bit == 0) return node[pos].count;",
			"            pos = node[pos].child[(v>>(bit-2))&3];",
			"        }",
			"        return 0;",
			"    }",
			"    ",
			"    void erase(T v, int n = -1) {",
			"        if(n == -1) n = count(v);",
			"        if(n == 0) return;",
			"        int pos = root;",
			"        int bit = bit_width;",
			"        siz -= n;",
			"        v ^= xor_val;",
			"        while(true){",
			"            node[pos].count -= n;",
			"            bit -= node[pos].width;",
			"            if(bit == 0) return;",
			"            pos = node[pos].child[(v>>(bit-2))&3];",
			"        }",
			"    }",
			"    ",
			"    const ref_node_t operator[](int k) const {",
			"        if(k < 0) k += siz;",
			"        if(k < 0 || siz <= k) return ref_node_t{0, false};",
			"        ",
			"        k++;",
			"        int pos = root;",
			"        int bit = bit_width;",
			"        while(true){",
			"            bit -= node[pos].width;",
			"            if(bit == 0) return ref_node_t{node[pos].value^xor_val, true};",
			"            int b = (xor_val>>(bit-2))&3;",
			"            auto &child = node[pos].child;",
			"            if(k <= node[child[b]].count){",
			"                pos = child[b];",
			"            } else {",
			"                k -= node[child[b]].count;",
			"                if(k <= node[child[b^1]].count){",
			"                    pos = child[b^1];",
			"                } else {",
			"                    k -= node[child[b^1]].count;",
			"                    if(k <= node[child[b^2]].count){",
			"                        pos = child[b^2];",
			"                    } else {",
			"                        k -= node[child[b^2]].count;",
			"                        pos = child[b^3];",
			"                    }",
			"                }",
			"            }",
			"        }",
			"    }",
			"    ",
			"    int order(T v) const {",
			"        if(v == 0) return 0;",
			"        v--;",
			"        int res = 0;",
			"        int pos = root;",
			"        int bit = bit_width;",
			"        while(pos != 0){",
			"            T mv = masked(v, bit-node[pos].width, bit);",
			"            T mnv = masked(node[pos].value^xor_val, bit-node[pos].width, bit);",
			"            if(mv < mnv){",
			"                return res;",
			"            } else {",
			"                if(mv > mnv){",
			"                    res += node[pos].count;",
			"                    return res;",
			"                } else {",
			"                    bit -= node[pos].width;",
			"                    if(bit == 0) return res + node[pos].count;",
			"                    int b = (v>>(bit-2))&3;",
			"                    auto &child = node[pos].child;",
			"                    T mxv = (xor_val>>(bit-2))&3;",
			"                    ",
			"                    if(b >= 1){",
			"                        res += node[child[mxv]].count;",
			"                        if(b >= 2){",
			"                            res += node[child[mxv^1]].count;",
			"                            if(b >= 3){",
			"                                res += node[child[mxv^2]].count;",
			"                            }",
			"                        }",
			"                    }",
			"                    pos = node[pos].child[b^((xor_val>>(bit-2))&3)];",
			"                }",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"    ",
			"    const ref_node_t lower_bound(T v) const {",
			"        int ord = order(v);",
			"        if(siz == ord) return ref_node_t{0, false};",
			"        else return ref_node_t{(*this)[ord].val, true};",
			"    }",
			"    ",
			"    const ref_node_t less_bound(T v) const {",
			"        int ord = v!=numeric_limits<T>::max() ? order(v+1) : siz;",
			"        if(ord == 0) return ref_node_t{0, false};",
			"        else return ref_node_t{(*this)[ord-1].val, true};",
			"    }",
			"    ",
			"    void reserve(int n) {",
			"        node.reserve(2*n+2);",
			"    }",
			"    ",
			"    int size() const {",
			"        return siz;",
			"    }",
			"    ",
			"    void apply_xor(T x) {",
			"        xor_val ^= x;",
			"    }",
			"    ",
			"    const ref_node_t xor_min(T v) {",
			"        if(siz == 0) return ref_node_t{0, false};",
			"        apply_xor(v);",
			"        ref_node_t res{(*this)[0].val^v, true};",
			"        apply_xor(v);",
			"        return res;",
			"    }",
			"    ",
			"    const ref_node_t xor_max(T v) {",
			"        if(siz == 0) return ref_node_t{0, false};",
			"        apply_xor(v);",
			"        ref_node_t res{(*this)[-1].val^v, true};",
			"        apply_xor(v);",
			"        return res;",
			"    }",
			"};"
		]
	},
	
	"calc_area": {
		"prefix": "calc_area",
		"body": [
			"using _CA_T = long long;",
			"auto calc_area = [](_CA_T a1, _CA_T a2, _CA_T b1, _CA_T b2, _CA_T c1, _CA_T c2, bool sign = 0){",
			"    a1 -= b1; a2 -= b2;",
			"    c1 -= b1; c2 -= b2;",
			"    _CA_T res = (a1*c2 - a2*c1);",
			"    if(!sign) res = abs(res);",
			"    return res;",
			"};"
		]
	},
	
	"calc_pl_dist": {
		"prefix": "calc_pl_dist",
		"body": [
			"using _CPLD_T = long double;",
			"auto calc_pl_dist = [](_CPLD_T p1, _CPLD_T p2, _CPLD_T e1, _CPLD_T e2, _CPLD_T e3, _CPLD_T e4){",
			"    p1 -= e1; p2 -= e2;",
			"    e3 -= e1; e4 -= e2;",
			"    _CPLD_T len = e3*e3 + e4*e4;",
			"    _CPLD_T t = (p1*e3 + p2*e4) / len;",
			"    t = max(0.0L, min(1.0L, t));",
			"    return hypot(e3*t-p1, e4*t-p2);",
			"};"
		]
	},
	
	"combination": {
		"prefix": "combination",
		"body": [
			"auto comb = [](long long N, long long K, int mod = 0)->long long {",
			"    constexpr int COMBSIZ = 200000;",
			"    assert(mod >= 0);",
			"    if(N < K || K < 0) return 0;",
			"    if(mod != 0){",
			"        assert(N <= COMBSIZ);",
			"        static vector<long long> combf(COMBSIZ+9, -1);",
			"        if(combf[0] == -1){",
			"            combf[0] = 1;",
			"            for(long long i = 1; i <= COMBSIZ; i++) combf[i] = (combf[i-1]*i)%mod;",
			"        }",
			"        return (combf[N]*power((combf[N-K]*combf[K])%mod, mod-2, mod))%mod;",
			"    } else {",
			"        long long a=1, b=1;",
			"        K = min(K, N-K);",
			"        for(long long i = N; i > N-K; i--) a *= i;",
			"        for(long long i = 2; i <= K; i++) b *= i;",
			"        return a/b;",
			"    }",
			"};"
		]
	},
	
	"compression": {
		"prefix": "compression",
		"body": [
			"void _compression_merge(...){}",
			"template<typename T, typename... Args>",
			"void _compression_merge(vector<T>& C, vector<T>& v, Args&... args){",
			"    for(auto& i : v) C.push_back(i);",
			"    _compression_merge(C, args...);",
			"}",
			"void _compression_apply(...){}",
			"template<typename T, typename... Args>",
			"void _compression_apply(vector<T>& C, vector<T>& v, Args&... args){",
			"    for(auto& i : v) i = lower_bound(C.begin(), C.end(), i) - C.begin();",
			"    _compression_apply(C, args...);",
			"}",
			"template<typename T, typename... Args>",
			"vector<T> compression(vector<T>& v, Args&... args){",
			"    vector<T> C;",
			"    _compression_merge(C, v, args...);",
			"    sort(C.begin(), C.end());",
			"    C.erase(unique(C.begin(), C.end()), C.end());",
			"    _compression_apply(C, v, args...);",
			"    return C;",
			"}"
		]
	},
	
	"convert": {
		"prefix": "convert",
		"body": [
			"auto convert = [](long long x, int n, int len = 1){",
			"    string res = \"\";",
			"    while(x){",
			"        int num = x%n;",
			"        if(num >= 10) res += 'A'+(num-10);",
			"        else res += '0'+(num);",
			"        x /= n;",
			"    }",
			"    while((int)res.size() < len) res += '0';",
			"    reverse(res.begin(), res.end());",
			"    return res;",
			"};"
		]
	},
	
	"cycle_detection": {
		"prefix": "cycle_detection",
		"body": [
			"auto cycle_detection = [](int n, const auto &e)->vector<int> {",
			"    int m = e.size();",
			"    vector<pair<int, array<int, 2>>> E;",
			"    E.reserve(m);",
			"    for(auto &[u, v] : e){",
			"        const int siz = E.size();",
			"        E.push_back({u, {v, siz}});",
			"    }",
			"    graph<array<int, 2>> G;",
			"    G.build(n, E);",
			"    ",
			"    vector<array<int, 2>> st; st.reserve(n);",
			"    vector<int> ans; ans.reserve(n);",
			"    vector<int> state(n), idx(n), par(n, -1), done(n);",
			"    int pos, ret = -1;",
			"    for(int start = 0; start < n; start++){",
			"        if(state[start] != 0) continue;",
			"        pos = start;",
			"        while(pos != -1){",
			"            auto g = G[pos];",
			"            if(done[pos]){",
			"                done[pos] = false;",
			"                if(ret >= 0){",
			"                    ans.push_back(st.back()[1]);",
			"                    st.pop_back();",
			"                    if(ret == pos) ret = -2;",
			"                    pos = par[pos];",
			"                    continue;",
			"                } else if(ret == -2){",
			"                    st.pop_back();",
			"                    pos = par[pos];",
			"                    continue;",
			"                } else st.pop_back();",
			"            }",
			"            if(idx[pos] == (int)g.size()){",
			"                state[pos] = 2;",
			"                pos = par[pos];",
			"                ret = -1;",
			"            } else {",
			"                state[pos] = 1;",
			"                auto [nex, i] = g[idx[pos]];",
			"                idx[pos]++;",
			"                if(state[nex] == 2) continue;",
			"                if(state[nex] == 1) {",
			"                    ans.push_back(i);",
			"                    ret = nex;",
			"                    pos = par[pos];",
			"                    continue;",
			"                }",
			"                done[pos] = true;",
			"                st.push_back({nex, i});",
			"                par[nex] = pos;",
			"                pos = nex;",
			"            }",
			"        }",
			"        ",
			"        if(ret == -2){",
			"            reverse(all(ans));",
			"            return ans;",
			"        }",
			"    }",
			"    ",
			"    return {-1};",
			"};"
		]
	},
	
	"dfs2d": {
		"prefix": "dfs2d",
		"body": [
			"auto bfs2d = [](const auto& v, const vector<pair<int, int>>& spos, char wall){",
			"    int h = v.size(), w = v[0].size();",
			"    vector<int> dy = {0, 1, 0, -1}, dx = {1, 0, -1, 0};",
			"    vector<vector<int>> dist(h, vector<int>(w, INF));",
			"    queue<pair<int, int>> Q;",
			"    for(auto [sy, sx] : spos){",
			"        Q.emplace(sy, sx);",
			"        dist[sy][sx] = 0;",
			"    }",
			"    while(!Q.empty()){",
			"        int y = Q.front().first, x = Q.front().second;",
			"        Q.pop();",
			"        for(int dk = 0; dk < (int)dy.size(); dk++){",
			"            int ny = y+dy[dk], nx = x+dx[dk];",
			"            if(ny < 0 || ny >= h || nx < 0 || nx >= w || dist[ny][nx] != INF || v[ny][nx] == wall) continue;",
			"            dist[ny][nx] = dist[y][x]+1;",
			"            Q.emplace(ny, nx);",
			"        }",
			"    }",
			"    return dist;",
			"};"
		]
	},
	
	"dijkstra": {
		"prefix": "dijkstra",
		"body": [
			"auto dijkstra = [](const vector<vector<pair<long long, int>>>& v, const vector<int>& s){",
			"    int siz = v.size();",
			"    vector<long long> dist(siz, LLINF);",
			"    vector<int> path(siz, -1);",
			"    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;",
			"    for(int i : s){",
			"        dist[i] = 0;",
			"        pq.emplace(0, i);",
			"    }",
			"    while(!pq.empty()){",
			"        auto [d, pos] = pq.top();",
			"        pq.pop();",
			"        if(d > dist[pos]) continue;",
			"        for(auto [cost, nex] : v[pos]){",
			"            long long nex_cost = dist[pos] + cost;",
			"            if(dist[nex] > nex_cost){",
			"                dist[nex] = nex_cost;",
			"                pq.emplace(dist[nex], nex);",
			"                path[nex] = pos;",
			"            }",
			"        }",
			"    }",
			"    return make_pair(dist, path);",
			"}"
		]
	},
	
	"durtime": {
		"prefix": "durtime",
		"body": [
			"chrono::duration_cast<chrono::milliseconds>($1)"
		]
	},
	
	"dydx": {
		"prefix": "dydx",
		"body": [
			"dy[] = {0, 1, 0, -1}, dx[] = {1, 0, -1, 0}"
		]
	},
	
	"dynamic_segtree": {
		"prefix": "dynamic_segtree",
		"body": [
			"template <typename T, typename S, auto op, auto e>",
			"struct dynamic_segtree{",
			"    private:",
			"    ",
			"    struct node_t{",
			"        S sum;",
			"        T value;",
			"        array<int, 4> child = {};",
			"        int width = 0;",
			"        node_t() : sum{e()} {}",
			"        node_t(const node_t &o) noexcept = default;",
			"        node_t(node_t &&o) noexcept = default;",
			"        node_t &operator=(const node_t &o) noexcept = default;",
			"        node_t &operator=(node_t &&o) noexcept = default;",
			"    };",
			"    ",
			"    static constexpr T one = 1;",
			"    static constexpr int bit_width = sizeof(T) * 8;",
			"    vector<node_t> node;",
			"    int root = -1;",
			"    ",
			"    //__builtin_clz",
			"    template<typename _Tp>",
			"    inline int clz(_Tp x) const {",
			"        if constexpr(sizeof(_Tp) == 8ull) return __builtin_clzll(x);",
			"        else return __builtin_clz(x);",
			"    }",
			"    ",
			"    inline T mask(int l, int r) const {",
			"        if(r >= bit_width) return -(one<<l);",
			"        return (one<<r) - (one<<l);",
			"    }",
			"    ",
			"    inline T masked(T v, int l, int r) const {",
			"        return mask(l, r) & v;",
			"    }",
			"    ",
			"    inline int diff_bit(T x, T y) const {",
			"        return ((bit_width-1 - clz(x^y))|1) + 1;",
			"    }",
			"    ",
			"    inline int make_node(T v, S x){",
			"        node.emplace_back();",
			"        node.back().value = v;",
			"        node.back().sum = move(x);",
			"        return ssize(node)-1;",
			"    }",
			"    ",
			"    public:",
			"    ",
			"    dynamic_segtree(){",
			"        make_node(0, e());",
			"        root = make_node(0, e());",
			"        node[root].width = bit_width;",
			"    }",
			"    ",
			"    dynamic_segtree<T, S, op, e>& operator=(dynamic_segtree<T, S, op, e>&& o) noexcept = default;",
			"    ",
			"    dynamic_segtree(dynamic_segtree&& o) noexcept = default;",
			"    ",
			"    void set(T v, const S &x) {",
			"        int pos = root;",
			"        int bit = bit_width;",
			"        int route[65], route_cnt = 0;",
			"        while(true){",
			"            T mv = masked(v, bit-node[pos].width, bit);",
			"            T mnv = masked(node[pos].value, bit-node[pos].width, bit);",
			"            if(mv != mnv){",
			"                route[route_cnt++] = pos;",
			"                int diff = diff_bit(mv, mnv);",
			"                int b = (mv>>(diff-2))&3;",
			"                int nb = (mnv>>(diff-2))&3;",
			"                int inter = make_node(node[pos].value, node[pos].sum);",
			"                int leaf = make_node(v, x);",
			"                node[inter] = node[pos];",
			"                node[inter].width -= bit - diff;",
			"                memset(node[pos].child.data(), 0, sizeof(int)*4);",
			"                node[pos].child[b] = leaf;",
			"                node[pos].child[nb] = inter;",
			"                node[pos].width = bit - diff;",
			"                bit = diff;",
			"                node[leaf].width = bit;",
			"                pos = leaf;",
			"                break;",
			"            } else {",
			"                ",
			"                bit -= node[pos].width;",
			"                if(bit == 0){",
			"                    node[pos].sum = x;",
			"                    break;",
			"                }",
			"                route[route_cnt++] = pos;",
			"                int nex = node[pos].child[(v>>(bit-2))&3];",
			"                if(nex == 0){",
			"                    nex = node[pos].child[(v>>(bit-2))&3] = make_node(v, x);",
			"                    node[nex].width = bit;",
			"                    break;",
			"                }",
			"                pos = nex;",
			"            }",
			"        }",
			"        for(int i = route_cnt-1; i >= 0; i--){",
			"            int idx = route[i];",
			"            auto &child = node[idx].child;",
			"            node[idx].sum = op(op(op(node[child[0]].sum, node[child[1]].sum), node[child[2]].sum), node[child[3]].sum);",
			"        }",
			"    }",
			"    ",
			"    S get(T p) const {",
			"        int pos = root;",
			"        int bit = bit_width;",
			"        while(pos != 0){",
			"            bit -= node[pos].width;",
			"            if(bit == 0) return node[pos].value==p ? node[pos].sum : e();",
			"            pos = node[pos].child[(p>>(bit-2))&3];",
			"        }",
			"        return e();",
			"    }",
			"    ",
			"    S prod(T l, T r) const {",
			"        return _prod(l, r, root, bit_width);",
			"    }",
			"    S _prod(T l, T r, int pos, int bit) const {",
			"        if(pos == 0) return e();",
			"        bit -= node[pos].width;",
			"        T mv = masked(node[pos].value, bit, bit_width);",
			"        if(r <= mv) return e();",
			"        if(l != numeric_limits<T>::min() && mv-1+(one<<bit) < l) return e();",
			"        if(l <= mv && mv-1+(one<<bit) < r){",
			"            return node[pos].sum;",
			"        }",
			"        auto &child = node[pos].child;",
			"        return op(op(op(_prod(l, r, child[0], bit), _prod(l, r, child[1], bit)), _prod(l, r, child[2], bit)), _prod(l, r, child[3], bit));",
			"    }",
			"    ",
			"    S all_prod() const {",
			"        return node[root].sum;",
			"    }",
			"    ",
			"    void reserve(int n) {",
			"        node.reserve(2*n+2);",
			"    }",
			"};"
		]
	},
	
	"enum_comb": {
		"prefix": "enum_comb",
		"body": [
			"auto enum_comb = [](int n, int k) {",
			"    vector<vector<int>> res;",
			"    vector<int> now(k);",
			"    iota(now.begin(), now.end(), 0);",
			"    while(true){",
			"        {",
			"            res.emplace_back(now);",
			"        }",
			"        int ind = k-1;",
			"        while(ind >= 0 && now[ind] == ind+n-k) --ind;",
			"        if(ind == -1) break;",
			"        ++now[ind];",
			"        for(int i = ind+1; i < k; ++i) now[i] = now[i-1] + 1;",
			"    }",
			"    return res;",
			"};"
		]
	},
	
	"enum_prime": {
		"prefix": "enum_prime",
		"body": [
			"auto enum_prime = [](int n){",
			"    if(n < 2) return vector<int>(0);",
			"    vector<int> prime = {2};",
			"    vector<bool> check((n+1)/2, 1);",
			"    if(n > 1000) prime.reserve((int)(n/(log(n)-1)));",
			"    int lim = sqrt(n);",
			"    if(lim%2 == 0) lim--;",
			"    for(long long i = 3; i <= lim; i+=2){",
			"        if(check[i/2] == 1){",
			"            prime.emplace_back(i);",
			"            for(long long j = i*i; j <= n; j+=2*i) check[j/2] = 0;",
			"        }",
			"    }",
			"    for(int i = lim+2; i <= n; i+=2){",
			"        if(check[i/2] == 1) prime.emplace_back(i);",
			"    }",
			"    return prime;",
			"};"
		]
	},
	
	"eular_tour": {
		"prefix": "eular_tour",
		"body": [
			"struct euler_tour{",
			"    int n, root;",
			"    vector<vector<int>> graph;",
			"    vector<int> val, in, out, par;",
			"    //↓1-index",
			"    vector<int> route;",
			"    ",
			"    //segtree<pair<int, int>, [](const auto& a, const auto& b){return a.first < b.first ? a : b;}, [](){return make_pair(INF, -1);}> tree;",
			"    ",
			"    euler_tour() = default;",
			"    euler_tour(const vector<vector<int>>& v, int r = 0):",
			"        n(v.size()), root(r), graph(v), in(n), out(n), par(n){",
			"            auto dfs = [&](auto self, int pos, int pre, int d)->void {",
			"                in[pos] = route.size();",
			"                par[pos] = pre;",
			"                route.push_back(pos+1);",
			"                val.push_back(d);",
			"                for(int nex : graph[pos]){",
			"                    if(nex == pre) continue;",
			"                    self(self, nex, pos, d+1);",
			"                }",
			"                out[pos] = route.size();",
			"                route.push_back(-(pos+1));",
			"                val.push_back(d-1);",
			"            };",
			"            route.reserve(n*2);",
			"            val.reserve(n*2);",
			"            dfs(dfs, r, -1, 0);",
			"            ",
			"            //vec<pair<int, int>> V(n*2);",
			"            //for(int i = 0; i < n*2; i++) V[i] = {val[i], route[i] >= 0 ? route[i]-1 : par[-route[i]-1]};",
			"            //tree.init(V);",
			"        }",
			"    ",
			"    ",
			"    //int lca(int a, int b){",
			"    //    return tree.prod(min(in[a], in[b]), max(in[a], in[b])).second;",
			"    //}",
			"};"
		]
	},
	
	"extgcd": {
		"prefix": "extgcd",
		"body": [
			"pair<long long, long long> extgcd(long long a, long long b) {",
			"    if (b == 0){",
			"        return {1, 0};",
			"    }",
			"    auto [y, x] = extgcd(b, a%b);",
			"    y -= a/b * x;",
			"    return {x, y};",
			"}"
		]
	},
	
	"factorize": {
		"prefix": "factorize",
		"body": [
			"auto factorize = [](auto n){",
			"    vector<pair<decltype(n), int>> res;",
			"    for(unsigned long long i = 2; i*i <= static_cast<unsigned long long>(n) || i == static_cast<unsigned long long>(n);){",
			"        if(n%i != 0) ++i;",
			"        else if(res.empty() || res.back().first != static_cast<decltype(n)>(i)) res.emplace_back(static_cast<decltype(n)>(i), 1), n/=i;",
			"        else ++res.back().second, n/=i;",
			"    }",
			"    if(n >= 2) res.emplace_back(n, 1);",
			"    return res;",
			"};"
		]
	},
	
	"fastset": {
		"prefix": "fastset",
		"body": [
			"struct fastset{",
			"    int siz;",
			"    vector<ull> node;",
			"    ",
			"    fastset(int _n){",
			"        int n = 1;",
			"        while((n<<6) < _n) n <<= 6;",
			"        siz = (n+1)/63;",
			"        node.resize((n+1)/63 + (_n+63)/64);",
			"    }",
			"    ",
			"    void insert(int x){",
			"        uint idx = siz + (x/64);",
			"        x &= 63;",
			"        while(true){",
			"            if((node[idx]>>x) & 1ull) return;",
			"            node[idx] |= (1ull<<x);",
			"            if(idx == 0) return;",
			"            idx--;",
			"            x = idx & 63;",
			"            idx /= 64;",
			"        }",
			"    }",
			"    ",
			"    void erase(int x){",
			"        int idx = siz + (x/64);",
			"        x &= 63;",
			"        while(true){",
			"            node[idx] &= ~(1ull<<x);",
			"            if(idx == 0 || node[idx]) return;",
			"            idx--;",
			"            x = idx & 63;",
			"            idx /= 64;",
			"        }",
			"    }",
			"    ",
			"    bool count(int x) const {",
			"        return (node[siz+x/64]>>(x&63u))&1;",
			"    }",
			"    ",
			"    int lower_bound(int x){",
			"        if(count(x)) return x;",
			"        int idx = siz + (x/64);",
			"        x &= 63;",
			"        while(true){",
			"            if(node[idx] & ~(((1ull<<x)<<1) - 1ull)){",
			"                x = __builtin_ctzll(node[idx] & ~(((1ull<<x)<<1) - 1ull));",
			"                if(idx >= siz) return (idx-siz)*64+x;",
			"                break;",
			"            }",
			"            if(idx == 0) return -1;",
			"            idx--;",
			"            x = idx & 63;",
			"            idx /= 64;",
			"        }",
			"        ",
			"        idx = idx*64 + x+1;",
			"        while(idx < siz) idx = idx*64 + __builtin_ctzll(node[idx])+1;",
			"        return (idx-siz)*64 + __builtin_ctzll(node[idx]);",
			"    }",
			"    ",
			"    int less_bound(int x){",
			"        if(count(x)) return x;",
			"        int idx = siz + (x/64);",
			"        x &= 63;",
			"        while(true){",
			"            if(node[idx] & ((1ull<<x) - 1ull)){",
			"                x = 63 - __builtin_clzll(node[idx] & ((1ull<<x) - 1ull));",
			"                if(idx >= siz) return (idx-siz)*64+x;",
			"                break;",
			"            }",
			"            if(idx == 0) return -1;",
			"            idx--;",
			"            x = idx & 63;",
			"            idx /= 64;",
			"        }",
			"        ",
			"        idx = idx*64 + x+1;",
			"        while(idx < siz) idx = idx*64 + 64 - __builtin_clzll(node[idx]);",
			"        return (idx-siz)*64 + 63 - __builtin_clzll(node[idx]);",
			"    }",
			"};"
		]
	},
	
	"fastvector": {
		"prefix": "fastvector",
		"body": [
			"template<size_t n, typename T>",
			"struct fast_vector{",
			"    using value_type = T;",
			"    using size_type = size_t;",
			"    using reference = T&;",
			"    using const_reference = const T&;",
			"    using iterator = T*;",
			"    using const_iterator = const T*;",
			"    ",
			"    T arr[n];",
			"    int en;",
			"    ",
			"    fast_vector():",
			"        en{0} {}",
			"    ",
			"    void open() {en = n;}",
			"    ",
			"    void assign(int siz, const T& x){",
			"        fill(arr, arr+siz, x);",
			"        en = siz;",
			"    }",
			"    ",
			"    void push_back(const T& x){",
			"        arr[en++] = x;",
			"    }",
			"    ",
			"    void push_back(T&& x){",
			"        arr[en++] = move(x);",
			"    }",
			"    ",
			"    void pop_back(){",
			"        en--;",
			"    }",
			"    ",
			"    iterator insert(iterator it, const T& x){",
			"        for(auto i = arr+en; i > it; i--){",
			"            *i = move(*prev(i));",
			"        }",
			"        *it = x;",
			"        en++;",
			"        return it;",
			"    }",
			"    ",
			"    iterator erase(iterator it){",
			"        en--;",
			"        for(auto i = it; i < arr+en; i++){",
			"            *i = move(*next(i));",
			"        }",
			"        return it;",
			"    }",
			"    ",
			"    void swap(fast_vector& x){",
			"        std::swap(en, x.en);",
			"        std::swap(arr, x.arr);",
			"    }",
			"    ",
			"    void clear(){",
			"        en = 0;",
			"    }",
			"    ",
			"    T& operator[](int p) {return arr[p];}",
			"    ",
			"    const T& operator[](int p) const {return arr[p];}",
			"    ",
			"    T& at(int p) {return arr[p];}",
			"    ",
			"    const T& at(int p) const {return arr[p];}",
			"    ",
			"    T* data() {return arr;}",
			"    ",
			"    T& front() {return arr[0];}",
			"    ",
			"    const T& front() const {return arr[0];}",
			"    ",
			"    T& back() {return arr[en-1];}",
			"    ",
			"    const T& back() const {return arr[en-1];}",
			"    ",
			"    size_type size() const {return en;}",
			"    ",
			"    bool empty() const {return en == 0;}",
			"    ",
			"    void reserve() {}",
			"    ",
			"    void resize(int siz) {",
			"        if(en > siz){",
			"            fill(arr+en, arr+siz, T());",
			"        }",
			"        en = siz;",
			"    }",
			"    ",
			"    void resize(int siz, const T& x) {",
			"        if(en > siz){",
			"            fill(arr+en, arr+siz, x);",
			"        }",
			"        en = siz;",
			"    }",
			"    ",
			"    iterator begin() {return arr;}",
			"    ",
			"    iterator end() {return arr+en;}",
			"};",
			"#define fvec fast_vector"
		]
	},
	
	"fenwick_tree": {
		"prefix": "fenwick_tree",
		"body": [
			"template<typename T>",
			"struct fenwick_tree{",
			"    int n;",
			"    vector<T> node, val;",
			"    ",
			"    fenwick_tree() = default;",
			"    fenwick_tree(unsigned siz):",
			"        n(siz), node(n+1), val(n){}",
			"    fenwick_tree(const vector<T>& v):",
			"        n(v.size()), node(n+1), val(v){",
			"            for(int i = 0; i < n; i++) node[i+1] = v[i];",
			"            for(int i = 1; i < n; i++) if(i+(i&-i) <= n) node[i+(i&-i)] += node[i];",
			"        }",
			"    ",
			"    void add(int p, const T x){",
			"        assert(0 <= p && p < n);",
			"        val[p] += x;",
			"        p++;",
			"        for(; p <= n; p += p&(-p)){",
			"            node[p] += x;",
			"        }",
			"    }",
			"    ",
			"    T sum(int l, int r){",
			"        assert(0 <= l && l <= r && r <= n);",
			"        if(__builtin_popcount(l) + __builtin_popcount(r) > r-l){",
			"            T res = 0;",
			"            for(int i = l; i < r; i++) res += val[i];",
			"            return res;",
			"        } else return sum(r) - sum(l);",
			"    }",
			"    ",
			"    T sum(int r){",
			"        T res = 0;",
			"        for(; r > 0; r -= r&(-r)){",
			"            res += node[r];",
			"        }",
			"        return res;",
			"    }",
			"    ",
			"    T prod(int l, int r){",
			"        return sum(l, r);",
			"    }",
			"    ",
			"    T get(int p){",
			"        return val[p];",
			"    }",
			"    ",
			"    void set(int p, const T x){",
			"        add(p, x - sum(p, p+1));",
			"    }",
			"    ",
			"    int max_right(T x){",
			"        if(x < 0) return 0;",
			"        int res = 0, w = bit_floor((unsigned)n);",
			"        for(int len = w; len > 0; len>>=1){",
			"            if(len+res<= n && node[len+res] <= x){",
			"                x -= node[len+res];",
			"                res += len;",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"};"
		]
	},
	
	"fiostream": {
		"prefix": "fiostream",
		"body": [
			"struct FIstream{",
			"    #ifndef LOCAL",
			"    #define fread fread_unlocked",
			"    #endif",
			"    ",
			"    static constexpr unsigned SIZ = 1 << 17;",
			"    char buf[SIZ], *p1 = buf, *p2 = buf;",
			"    ",
			"    inline char _getchar(){",
			"        if(p1 == p2){",
			"            p2 = (p1 = buf) + fread(buf, 1, SIZ, stdin);",
			"            if(p1 == p2) [[unlikely]] assert(0&&\"EOF\");",
			"        }",
			"        return *p1++;",
			"    }",
			"    ",
			"    inline char ignore_space(){",
			"        char c;",
			"        while((c = _getchar()) <= 0x20);",
			"        return c;",
			"    }",
			"    ",
			"    template<typename T>",
			"    inline void _read(T& res){",
			"        T x = 0, f = 1;",
			"        char c = ignore_space();",
			"        if(c == '-'){",
			"            f = -1;",
			"            c = _getchar();",
			"        }",
			"        while('0' <= c && c <= '9'){",
			"            x = x*10 + (c-'0');",
			"            c = _getchar();",
			"        }",
			"        res = x*f;",
			"    }",
			"    ",
			"    template<typename T>",
			"    inline FIstream& operator>>(T& x){_read(x); return *this;}",
			"    inline FIstream& operator>>(char& x){x = ignore_space(); return *this;}",
			"    #ifdef _GLIBCXX_STRING",
			"    inline FIstream& operator>>(string& x){",
			"        string().swap(x);",
			"        char c = ignore_space();",
			"        while(c > 0x20){",
			"            x.push_back(c);",
			"            c = _getchar();",
			"        }",
			"        return *this;",
			"    }",
			"    #endif",
			"    #ifndef LOCAL",
			"    #undef fread",
			"    #endif",
			"} _cin;",
			"#define cin _cin",
			"#define istream FIstream",
			"",
			"struct FOstream_Pre{",
			"    char num[10000][4];",
			"    constexpr FOstream_Pre():num(){",
			"        for(int i = 0; i < 10000; i++){",
			"            int x = i;",
			"            for(int j = 3; j >= 0; j--){",
			"                num[i][j] = x%10 + '0';",
			"                x /= 10;",
			"            }",
			"        }",
			"    }",
			"} constexpr _FOstream_pre;",
			"",
			"struct FOstream{",
			"    #ifndef LOCAL",
			"    #define fwrite fwrite_unlocked",
			"    #endif",
			"    ",
			"    static constexpr unsigned SIZ = 1 << 17;",
			"    char buf[SIZ], *p1 = buf, *p2 = buf+SIZ;",
			"    ",
			"    inline void _write(){",
			"        fwrite(buf, 1, p1-buf, stdout);",
			"        p1 = buf;",
			"    }",
			"    ",
			"    inline void _putchar(char c){",
			"        if(p1 == p2) [[unlikely]] {",
			"            _write();",
			"        }",
			"        *p1++ = c;",
			"    }",
			"    ",
			"    template<typename T>",
			"    void _write_i(T x){",
			"        constexpr int DIGIT_SIZ = 40;",
			"        static_assert(DIGIT_SIZ <= SIZ);",
			"        char num[DIGIT_SIZ], *idxp = num+DIGIT_SIZ;",
			"        if(x < 0){",
			"            _putchar('-');",
			"            x = -x;",
			"        }",
			"        if(p2 - p1 < DIGIT_SIZ) _write();",
			"        while(x >= 10000){",
			"            idxp -= 4;",
			"            memcpy(idxp, _FOstream_pre.num[size_t(x%10000)], 4);",
			"            x /= 10000;",
			"        }",
			"        if(x >= 1000){",
			"            memcpy(p1, _FOstream_pre.num[size_t(x)], 4);",
			"            p1 += 4;",
			"        } else if(x >= 100){",
			"            memcpy(p1, _FOstream_pre.num[size_t(x)]+1, 3);",
			"            p1 += 3;",
			"        } else if(x >= 10){",
			"            memcpy(p1, _FOstream_pre.num[size_t(x)]+2, 2);",
			"            p1 += 2;",
			"        } else *p1++ = char(x)+'0';",
			"        memcpy(p1, idxp, num+DIGIT_SIZ - idxp);",
			"        p1 += num+DIGIT_SIZ - idxp;",
			"    }",
			"    ",
			"    template<typename T>",
			"    FOstream &operator<<(const T &x) {_write_i(x); return *this;}",
			"    FOstream &operator<<(char x) {_putchar(x); return *this;}",
			"    FOstream &operator<<(const char *x) {",
			"        while(*x) _putchar(*x++);",
			"        return *this;",
			"    }",
			"    FOstream &operator<<(char *x) {return *this << const_cast<const char*>(x);}",
			"    FOstream &operator<<(double x) {",
			"        if(isnan(x)) [[unlikely]] return *this << \"nan\";",
			"        char _b[70];",
			"        snprintf(_b, sizeof(_b), \"%.*f\", 15, x);",
			"        return *this << const_cast<const char*>(_b);",
			"    }",
			"    FOstream &operator<<(long double x) {",
			"        if(isnan(x)) [[unlikely]] return *this << \"nan\";",
			"        char _b[330];",
			"        snprintf(_b, sizeof(_b), \"%.*Lf\", 15, x);",
			"        return *this << const_cast<const char*>(_b);",
			"    }",
			"    #ifdef _GLIBCXX_STRING",
			"    FOstream& operator<<(const string& x){",
			"        for(char i : x) _putchar(i);",
			"        return *this;",
			"    }",
			"    #endif",
			"    ",
			"    ~FOstream(){",
			"        if(p1 != buf){",
			"            fwrite(buf, 1, p1 - buf, stdout);",
			"        }",
			"    }",
			"    ",
			"    #ifndef LOCAL",
			"    #undef fwrite",
			"    #endif",
			"} _cout;",
			"#define cout _cout",
			"#define ostream FOstream"
		]
	},
	
	"gettime": {
		"prefix": "gettime",
		"body": [
			"chrono::steady_clock::now()"
		]
	},
	
	"graph": {
		"prefix": "graph",
		"body": [
			"template<typename T>",
			"struct graph {",
			"    vector<T> G;",
			"    vector<int> idx;",
			"    struct ref_t {",
			"        vector<T>::iterator begin_, end_;",
			"        auto begin() const noexcept {return begin_;}",
			"        auto end() const noexcept {return end_;}",
			"        auto size() const noexcept {return end_ - begin_;}",
			"        T operator[](int p) const {return begin_[p];}",
			"    };",
			"    ",
			"    void build(int n, const auto &E){",
			"        G.resize(E.size());",
			"        idx.resize(n+1);",
			"        for(auto &[u, v] : E){",
			"            idx[u+1]++;",
			"        }",
			"        for(int i = 1; i <= n; i++) idx[i] += idx[i-1];",
			"        auto C = idx;",
			"        for(auto &[u, v] : E){",
			"            G[C[u]++] = v;",
			"        }",
			"    }",
			"    ",
			"    ref_t operator[](int p) {return {G.begin()+idx[p], G.begin()+idx[p+1]};}",
			"};"
		]
	},
	
	"hashmap": {
		"prefix": "hashmap",
		"body": [
			"template<int siz>",
			"struct hashmap{",
			"    static_assert(__builtin_popcount(siz) == 1);",
			"    using ull = long long unsigned;",
			"    using ll = long long;",
			"    ",
			"    constexpr static int mask = siz-1;",
			"    ull key[siz];",
			"    ll val[siz];",
			"    bitset<siz> exist{};",
			"    ",
			"    hashmap(){}",
			"    ",
			"    static inline ull hash(ull x) {",
			"        x ^= x >> 33;",
			"        x *= 0xff51afd7ed558ccdULL;",
			"        x ^= x >> 33;",
			"        x *= 0xc4ceb9fe1a85ec53ULL;",
			"        return x ^ (x >> 33);",
			"    }",
			"    ",
			"    ll &operator[](ull k){",
			"        int h = hash(k)&mask;",
			"        while(exist[h]){",
			"            if(key[h] == k) return val[h];",
			"            h = (h+1)&mask;",
			"        }",
			"        key[h] = k;",
			"        exist.set(h);",
			"        return val[h];",
			"    }",
			"};"
		]
	},
	
	"hinit": {
		"prefix": "hinit",
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"#ifdef LOCAL",
			"ofstream outputfile(\"output.txt\");",
			"#define cout outputfile",
			"#else",
			"struct fast_io{fast_io(){std::ios::sync_with_stdio(0); std::cin.tie(0);}} _fast_io_ins;",
			"#endif",
			"",
			"using uint = unsigned;",
			"using ull = unsigned long long;",
			"using ll = long long;",
			"using ld = long double;",
			"#define el '\\n'",
			"#define all(x) begin(x), end(x)",
			"#define initv2(t,a,...) (a), vector<t>(__VA_ARGS__)",
			"#define initv3(t,a,b,...) (a), vector<vector<t>>((b), vector<t>(__VA_ARGS__))",
			"#define vec vector",
			"#define elif else if",
			"",
			"constexpr long long LLINF = (1ll<<62)-1; constexpr int INF = (1<<30)-1;",
			"template<typename T, typename U> ostream& operator<<(ostream& ost, const pair<T, U> p) {ost << '{' << p.first << ' ' << p.second << '}'; return ost;} template<typename T> ostream& operator<<(ostream& ost, const vector<T>& v) {for(int i = 0; i < ssize(v); i++) {ost << (i ? \" \" : \"\") << v[i];} return ost;} template<typename T> ostream& operator<<(ostream& ost, const vector<vector<T>>& v) {for(int i = 0; i < ssize(v); i++) {ost << (i ? \"\\n\" : \"\") << v[i];} return ost;}",
			"template<typename T, typename U> inline bool chmin(T& a, U b) {if(a > b){a = b; return true;} return false;} template<typename T, typename U> inline bool chmax(T& a, U b) {if(a < b){a = b; return true;} return false;} template<typename T> inline T minv(const vector<T>& v) {return *min_element(v.begin(), v.end());} template<typename T> inline T maxv(const vector<T>& v) {return *max_element(v.begin(), v.end());} long long power(long long val, long long num, long long mod = LLONG_MAX);",
			"",
			"",
			"//*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*/",
			"//*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*/",
			"",
			"",
			"",
			"signed main(){",
			"    $1",
			"    ",
			"}",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"long long power(long long val, long long num, long long mod){",
			"    assert(mod >= 0); assert(num >= 0);",
			"    long long res = 1;",
			"    val %= mod;",
			"    while(num){",
			"        if(num&1) res = (res*val)%mod;",
			"        val = (val*val)%mod;",
			"        num >>= 1;",
			"    }",
			"    return res;",
			"}"
		]
	},
	
	"hld_e": {
		"prefix": "hld_e",
		"body": [
			"//addが使えるなら",
			"#define HLD_HAS_OPERATION_ADD true",
			"//区間作用があるなら",
			"#define HLD_HAS_LAZY_APPLY false",
			"",
			"template<int MAXN, typename S, auto op, auto e>",
			"//template<int MAXN, typename S, auto op, auto e, typename F, auto mapping, auto composition, auto id>",
			"",
			"struct hld{",
			"    using node_type = segtree<S, op, e>;",
			"    //using node_type = segtree<S, op, e, F, mapping, composition, id>",
			"    ",
			"    int n, r, edge_idx;",
			"    int dep[MAXN], in[MAXN], out[MAXN], head[MAXN], par[MAXN];",
			"    array<int, 2> E[MAXN-1];",
			"    S V[MAXN-1];",
			"    ",
			"    node_type node[2];",
			"    ",
			"    hld(int _n, int _r = -1):",
			"        n(_n), r(_r), edge_idx(0){",
			"            if(r == -1) r = random_device()()%n;",
			"        }",
			"    ",
			"    void add_edge(int u, int v, const S &x){",
			"        E[edge_idx][0] = u;",
			"        E[edge_idx][1] = v;",
			"        V[edge_idx] = x;",
			"        edge_idx++;",
			"    }",
			"    ",
			"    void build(){",
			"        int g[(MAXN-1)*2], start[MAXN+1], C[MAXN+1];",
			"        S val[(MAXN-1)*2];",
			"        for(int i = 0; i < n-1; i++){",
			"            auto [u, v] = E[i];",
			"            start[u+1]++;",
			"            start[v+1]++;",
			"        }",
			"        for(int i = 1; i <= n; i++) start[i] += start[i-1];",
			"        memcpy(C, start, sizeof(int)*(n+1));",
			"        for(int i = 0; i < n-1; i++){",
			"            auto [u, v] = E[i];",
			"            val[C[u]] = V[i];",
			"            g[C[u]++] = v;",
			"            val[C[v]] = V[i];",
			"            g[C[v]++] = u;",
			"        }",
			"        ",
			"        int sub_siz[MAXN], idx[MAXN+1];",
			"        fill(sub_siz, sub_siz+n, 1);",
			"        memcpy(idx, start, sizeof(int)*(n+1));",
			"        ",
			"        int cur = r;",
			"        par[r] = -1;",
			"        while(true){",
			"            if(idx[cur] < start[cur+1]-(cur!=r)){",
			"                int nex = g[idx[cur]++];",
			"                if(nex == par[cur]){",
			"                    --idx[cur];",
			"                    val[idx[cur]] = val[start[cur+1]-1];",
			"                    g[idx[cur]] = g[start[cur+1]-1];",
			"                    continue;",
			"                }",
			"                par[nex] = cur;",
			"                cur = nex;",
			"            } else {",
			"                if(cur == r) break;",
			"                sub_siz[par[cur]] += sub_siz[cur];",
			"                cur = par[cur];",
			"            }",
			"        }",
			"        ",
			"        memcpy(idx, start, sizeof(int)*(n+1));",
			"        int state[MAXN]{}, heavy[MAXN];",
			"        ",
			"        int node_siz = 0;",
			"        cur = r;",
			"        head[cur] = r;",
			"        dep[cur] = 0;",
			"        while(1){",
			"            if(state[cur] == 0){",
			"                in[cur] = node_siz++;",
			"                heavy[cur] = -1;",
			"                for(int i = start[cur]; i < start[cur+1]-(cur!=r); i++){",
			"                    int nex = g[i];",
			"                    if(heavy[cur] == -1 || sub_siz[heavy[cur]] < sub_siz[nex]){",
			"                        heavy[cur] = nex;",
			"                    }",
			"                }",
			"                if(heavy[cur] != -1){",
			"                    int nex = heavy[cur];",
			"                    dep[nex] = dep[cur];",
			"                    head[nex] = head[cur];",
			"                    state[cur] = 2;",
			"                    cur = nex;",
			"                } else state[cur] = 2;",
			"            } else if(state[cur] == 2){",
			"                if(idx[cur] < start[cur+1]-(cur!=r)){",
			"                    int nex = g[idx[cur]++];",
			"                    if(nex == heavy[cur]) continue;",
			"                    dep[nex] = dep[cur]+1;",
			"                    head[nex] = nex;",
			"                    cur = nex;",
			"                } else state[cur] = 3;",
			"            } else {",
			"                out[cur] = node_siz;",
			"                if(cur == r) break;",
			"                cur = par[cur];",
			"            }",
			"        }",
			"        ",
			"        vector<S> node_v(n);",
			"        for(int i = 0; i < n; i++){",
			"            for(int j = start[i]; j < start[i+1]-(i!=r); j++){",
			"                node_v[in[g[j]]] = val[j];",
			"            }",
			"        }",
			"        ",
			"        node[0] = node_type(node_v);",
			"        reverse(node_v.begin(), node_v.end());",
			"        node[1] = node_type(node_v);",
			"    }",
			"    ",
			"    #if HLD_HAS_OPERATION_ADD",
			"    ",
			"    void add(int u, int v, const S& x){",
			"        if(dep[u] != dep[v]){",
			"            if(dep[u] < dep[v]) u = v;",
			"            node[0].add(in[u], x);",
			"            node[1].add(in[u], x);",
			"        } else {",
			"            if(head[u] < head[v]) u = v;",
			"            node[0].add(in[u], x);",
			"            node[1].add(in[u], x);",
			"        }",
			"    }",
			"    ",
			"    #endif",
			"    ",
			"    S prod(int l, int r){",
			"        assert(0 <= l && 0 <= r && l < n && r < n);",
			"        S l_ans = e();",
			"        S r_ans = e();",
			"        bool rev = false;",
			"        while(true){",
			"            if(dep[l] < dep[r]) swap(l, r), rev ^= 1;",
			"            if(dep[l] != dep[r] || head[l] != head[r]){",
			"                if(!rev) l_ans = op(l_ans, node[1].prod(n-in[l]-1, n-in[head[l]]));",
			"                else r_ans = op(node[0].prod(in[head[l]], in[l]+1), r_ans);",
			"                l = par[head[l]];",
			"            } else {",
			"                if(in[l] > in[r]) swap(l, r), rev ^= 1;",
			"                if(!rev) l_ans = op(l_ans, node[0].prod(in[l]+1, in[r]+1));",
			"                else r_ans = op(node[1].prod(n-in[r]-1, n-in[l]-1), r_ans);",
			"                return op(l_ans, r_ans);",
			"            }",
			"        }",
			"    }",
			"    ",
			"    S prod(int r){",
			"        assert(0 <= r && r < n);",
			"        return node[0].prod(in[r]+1, out[r]);",
			"    }",
			"    ",
			"    void set(int u, int v, const S& x){",
			"        if(dep[u] != dep[v]){",
			"            if(dep[u] < dep[v]) u = v;",
			"            node[0].set(in[u], x);",
			"            node[1].set(n-in[u]-1, x);",
			"        } else {",
			"            if(in[u] < in[v]) u = v;",
			"            node[0].set(in[u], x);",
			"            node[1].set(n-in[u]-1, x);",
			"        }",
			"    }",
			"    ",
			"    S get(int u, int v){",
			"        if(dep[u] != dep[v]){",
			"            if(dep[u] < dep[v]) u = v;",
			"            return node[0].get(in[u]);",
			"        } else {",
			"            if(in[u] < in[v]) u = v;",
			"            return node[0].get(in[u]);",
			"        }",
			"    }",
			"    ",
			"    int lca(int l, int r){",
			"        assert(0 <= l && 0 <= r && l < n && r < n);",
			"        while(true){",
			"            if(dep[l] < dep[r]) swap(l, r);",
			"            if(dep[l] != dep[r] || head[l] != head[r]){",
			"                l = par[head[l]];",
			"            } else {",
			"                if(in[l] > in[r]) swap(l, r);",
			"                return l;",
			"            }",
			"        }",
			"    }",
			"    ",
			"    int dist(int l, int r){",
			"        assert(0 <= l && 0 <= r && l < n && r < n);",
			"        int d = 0;",
			"        while(true){",
			"            if(dep[l] < dep[r]) swap(l, r);",
			"            if(dep[l] != dep[r] || head[l] != head[r]){",
			"                d += in[l] - in[head[l]] + 1;",
			"                l = par[head[l]];",
			"            } else {",
			"                if(in[l] > in[r]) swap(l, r);",
			"                d += in[r] - in[l];",
			"                return d;",
			"            }",
			"        }",
			"    }",
			"    ",
			"    #if HLD_HAS_LAZY_APPLY",
			"    ",
			"    void apply(int l, int r, const F& x){",
			"        while(true){",
			"            if(dep[l] < dep[r]) swap(l, r);",
			"            if(dep[l] != dep[r] || head[l] != head[r]){",
			"                node[0].apply(in[head[l]], in[l]+1, x);",
			"                node[1].apply(n-in[l]-1, n-in[head[l]], x);",
			"                l = par[head[l]];",
			"            } else {",
			"                if(in[l] > in[r]) swap(l, r);",
			"                node[0].apply(in[l]+1, in[r]+1, x);",
			"                node[1].apply(n-in[r]-1, n-in[l]-1, x);",
			"                break;",
			"            }",
			"        }",
			"    }",
			"    ",
			"    void apply(int r, const F& x){",
			"        node[0].apply(in[r]+1, out[r], x);",
			"        node[1].apply(n-out[r], n-in[r]-1, x);",
			"    }",
			"    ",
			"    #endif",
			"};"
		]
	},
	
	"hld_n": {
		"prefix": "hld_n",
		"body": [
			"template<int MAXN>",
			"",
			"struct hld{",
			"    int n;",
			"    int dep[MAXN], in[MAXN], head[MAXN], par[MAXN];",
			"    int node[MAXN];",
			"    ",
			"    hld(int _n, vector<int>& g, const vector<int>& start, int r = 0):",
			"        n(_n){",
			"            assert(0 <= r && r < n);",
			"            ",
			"            if(ssize(g) == (n-1)*2){",
			"                int sub_siz[MAXN], idx[MAXN+1];",
			"                fill(sub_siz, sub_siz+n, 1);",
			"                memcpy(idx, start.data(), sizeof(int)*start.size());",
			"                ",
			"                int cur = r;",
			"                par[r] = -1;",
			"                while(true){",
			"                    if(idx[cur] < start[cur+1]-(cur!=r)){",
			"                        int nex = g[idx[cur]++];",
			"                        if(nex == par[cur]){",
			"                            g[--idx[cur]] = g[start[cur+1]-1];",
			"                            continue;",
			"                        }",
			"                        par[nex] = cur;",
			"                        cur = nex;",
			"                    } else {",
			"                        if(cur == r) break;",
			"                        sub_siz[par[cur]] += sub_siz[cur];",
			"                        cur = par[cur];",
			"                    }",
			"                }",
			"                ",
			"                memcpy(idx, start.data(), sizeof(int)*start.size());",
			"                int state[MAXN]{}, heavy[MAXN];",
			"                ",
			"                int node_siz = 0;",
			"                cur = r;",
			"                head[cur] = r;",
			"                dep[cur] = 0;",
			"                while(1){",
			"                    if(state[cur] == 0){",
			"                        in[cur] = node_siz++;",
			"                        heavy[cur] = -1;",
			"                        for(int i = start[cur]; i < start[cur+1]-(cur!=r); i++){",
			"                            int nex = g[i];",
			"                            if(heavy[cur] == -1 || sub_siz[heavy[cur]] < sub_siz[nex]){",
			"                                heavy[cur] = nex;",
			"                            }",
			"                        }",
			"                        if(heavy[cur] != -1){",
			"                            int nex = heavy[cur];",
			"                            dep[nex] = dep[cur];",
			"                            head[nex] = head[cur];",
			"                            state[cur] = 2;",
			"                            cur = nex;",
			"                        } else state[cur] = 2;",
			"                    } else if(state[cur] == 2){",
			"                        if(idx[cur] < start[cur+1]-(cur!=r)){",
			"                            int nex = g[idx[cur]++];",
			"                            if(nex == heavy[cur]) continue;",
			"                            dep[nex] = dep[cur]+1;",
			"                            head[nex] = nex;",
			"                            cur = nex;",
			"                        } else state[cur] = 3;",
			"                    } else {",
			"                        if(cur == r) break;",
			"                        cur = par[cur];",
			"                    }",
			"                }",
			"            } else if(ssize(g) == (n-1)){",
			"                int sub_siz[MAXN], idx[MAXN];",
			"                fill(sub_siz, sub_siz+n, 1);",
			"                memcpy(idx, start.data(), sizeof(int)*start.size());",
			"                ",
			"                int cur = r;",
			"                par[r] = -1;",
			"                while(true){",
			"                    if(idx[cur] < start[cur+1]){",
			"                        int nex = g[idx[cur]++];",
			"                        par[nex] = cur;",
			"                        cur = nex;",
			"                    } else {",
			"                        if(cur == r) break;",
			"                        sub_siz[par[cur]] += sub_siz[cur];",
			"                        cur = par[cur];",
			"                    }",
			"                }",
			"                ",
			"                memcpy(idx, start.data(), sizeof(int)*start.size());",
			"                int state[MAXN]{}, heavy[MAXN];",
			"                ",
			"                int node_siz = 0;",
			"                cur = r;",
			"                head[cur] = r;",
			"                dep[cur] = 0;",
			"                while(1){",
			"                    if(state[cur] == 0){",
			"                        in[cur] = node_siz++;",
			"                        heavy[cur] = -1;",
			"                        for(int i = start[cur]; i < start[cur+1]; i++){",
			"                            int nex = g[i];",
			"                            if(heavy[cur] == -1 || sub_siz[heavy[cur]] < sub_siz[nex]){",
			"                                heavy[cur] = nex;",
			"                            }",
			"                        }",
			"                        if(heavy[cur] != -1){",
			"                            int nex = heavy[cur];",
			"                            dep[nex] = dep[cur];",
			"                            head[nex] = head[cur];",
			"                            state[cur] = 2;",
			"                            cur = nex;",
			"                        } else state[cur] = 2;",
			"                    } else if(state[cur] == 2){",
			"                        if(idx[cur] < start[cur+1]){",
			"                            int nex = g[idx[cur]++];",
			"                            if(nex == heavy[cur]) continue;",
			"                            dep[nex] = dep[cur]+1;",
			"                            head[nex] = nex;",
			"                            cur = nex;",
			"                        } else state[cur] = 3;",
			"                    } else {",
			"                        if(cur == r) break;",
			"                        cur = par[cur];",
			"                    }",
			"                }",
			"            } else assert(0);",
			"            for(int i = 0; i < n; i++) node[in[i]] = i;",
			"        }",
			"    ",
			"        int prod(int l, int r, int k){",
			"            int lc = lca(l, r);",
			"            int dl = dist(l, lc), dr = dist(lc, r);",
			"            if(dl+dr < k) return -1;",
			"            if(dl >= k){",
			"                while(true){",
			"                    k -= in[l] - in[head[l]];",
			"                    if(k <= 0) return node[in[head[l]]-k];",
			"                    k--; l = par[head[l]];",
			"                }",
			"            } else {",
			"                k -= dl;",
			"                k = dr - k;",
			"                while(true){",
			"                    k -= in[r] - in[head[r]];",
			"                    if(k <= 0) return node[in[head[r]]-k];",
			"                    k--; r = par[head[r]];",
			"                }",
			"            }",
			"        }",
			"    ",
			"    int lca(int l, int r){",
			"        assert(0 <= l && 0 <= r && l < n && r < n);",
			"        while(true){",
			"            if(dep[l] < dep[r]) swap(l, r);",
			"            if(dep[l] != dep[r] || head[l] != head[r]){",
			"                l = par[head[l]];",
			"            } else {",
			"                if(in[l] > in[r]) swap(l, r);",
			"                return l;",
			"            }",
			"        }",
			"    }",
			"    ",
			"    int dist(int l, int r){",
			"        assert(0 <= l && 0 <= r && l < n && r < n);",
			"        int d = 0;",
			"        while(true){",
			"            if(dep[l] < dep[r]) swap(l, r);",
			"            if(dep[l] != dep[r] || head[l] != head[r]){",
			"                d += in[l] - in[head[l]] + 1;",
			"                l = par[head[l]];",
			"            } else {",
			"                if(in[l] > in[r]) swap(l, r);",
			"                d += in[r] - in[l];",
			"                return d;",
			"            }",
			"        }",
			"    }",
			"};"
		]
	},
	
	"hld_v": {
		"prefix": "hld_v",
		"body": [
			"template<typename S, auto op, auto e = []{return S();}, typename F = int, auto mapping = []{}, auto composition = []{}, auto id = []{}>",
			"struct hld{",
			"    using node_type = segtree<S, op, e>;",
			"    //using node_type = lazy_segtree<S, op, e, F, mapping, composition, id>",
			"    ",
			"    int *dum0, *dum1;",
			"    int n, r, edge_idx;",
			"    int *dep, *in, *out, *head, *par;",
			"    int *E;",
			"    ",
			"    node_type node[2];",
			"    ",
			"    hld(int _n, int _r = -1):",
			"        n(_n), r(_r), edge_idx(0){",
			"            if(r == -1) r = random_device()()%n;",
			"            dum0 = new int[n*7-2];",
			"            dep = dum0;",
			"            in = dum0+n;",
			"            out = dum0+n*2;",
			"            head = dum0+n*3;",
			"            par = dum0+n*4;",
			"            E = dum0+n*5;",
			"        }",
			"    ",
			"    void add_edge(int u, int v){",
			"        E[edge_idx++] = u;",
			"        E[edge_idx++] = v;",
			"    }",
			"    ",
			"    void build(const vector<S>& v){",
			"        dum1 = new int[n*8+1];",
			"        int *g = dum1;",
			"        int *start = dum1+n*2-2;",
			"        int *C = dum1+n*3-1;",
			"        memset(start, 0, sizeof(int)*(n+1));",
			"        ",
			"        for(int i = 0; i < 2*n-2; i+=2){",
			"            start[E[i]+1]++;",
			"            start[E[i+1]+1]++;",
			"        }",
			"        for(int i = 1; i <= n; i++) start[i] += start[i-1];",
			"        memcpy(C, start, sizeof(int)*(n+1));",
			"        ",
			"        for(int i = 0; i < 2*n-2; i+=2){",
			"            g[C[E[i]]++] = E[i+1];",
			"            g[C[E[i+1]]++] = E[i];",
			"        }",
			"        ",
			"        int *sub_siz = dum1+n*4;",
			"        int *idx = dum1+n*5;",
			"        fill(sub_siz, sub_siz+n, 1);",
			"        memcpy(idx, start, sizeof(int)*(n+1));",
			"        ",
			"        int cur = r;",
			"        par[r] = -1;",
			"        while(true){",
			"            if(idx[cur] < start[cur+1]-(cur!=r)){",
			"                int nex = g[idx[cur]++];",
			"                if(nex == par[cur]){",
			"                    g[--idx[cur]] = g[start[cur+1]-1];",
			"                    continue;",
			"                }",
			"                par[nex] = cur;",
			"                cur = nex;",
			"            } else {",
			"                if(cur == r) break;",
			"                sub_siz[par[cur]] += sub_siz[cur];",
			"                cur = par[cur];",
			"            }",
			"        }",
			"        ",
			"        memcpy(idx, start, sizeof(int)*(n+1));",
			"        int *state = dum1+n*6+1;",
			"        int *heavy = dum1+n*7+1;",
			"        memset(state, 0, sizeof(int)*n);",
			"        ",
			"        int node_siz = 0;",
			"        cur = r;",
			"        head[cur] = r;",
			"        dep[cur] = 0;",
			"        while(1){",
			"            if(state[cur] == 0){",
			"                in[cur] = node_siz++;",
			"                heavy[cur] = -1;",
			"                for(int i = start[cur]; i < start[cur+1]-(cur!=r); i++){",
			"                    int nex = g[i];",
			"                    if(heavy[cur] == -1 || sub_siz[heavy[cur]] < sub_siz[nex]){",
			"                        heavy[cur] = nex;",
			"                    }",
			"                }",
			"                if(heavy[cur] != -1){",
			"                    int nex = heavy[cur];",
			"                    dep[nex] = dep[cur];",
			"                    head[nex] = head[cur];",
			"                    state[cur] = 2;",
			"                    cur = nex;",
			"                } else state[cur] = 2;",
			"            } else if(state[cur] == 2){",
			"                if(idx[cur] < start[cur+1]-(cur!=r)){",
			"                    int nex = g[idx[cur]++];",
			"                    if(nex == heavy[cur]) continue;",
			"                    dep[nex] = dep[cur]+1;",
			"                    head[nex] = nex;",
			"                    cur = nex;",
			"                } else state[cur] = 3;",
			"            } else {",
			"                out[cur] = node_siz;",
			"                if(cur == r) break;",
			"                cur = par[cur];",
			"            }",
			"        }",
			"        ",
			"        vector<S> node_v(n);",
			"        for(int i = 0; i < n; i++) node_v[in[i]] = v[i];",
			"        ",
			"        node[0] = node_type(node_v);",
			"        reverse(node_v.begin(), node_v.end());",
			"        node[1] = node_type(node_v);",
			"        ",
			"        delete[] dum1;",
			"    }",
			"    ",
			"    S prod(int l, int r){",
			"        assert(0 <= l && 0 <= r && l < n && r < n);",
			"        S l_ans = e();",
			"        S r_ans = e();",
			"        bool rev = false;",
			"        while(true){",
			"            if(dep[l] < dep[r]) swap(l, r), rev ^= 1;",
			"            if(dep[l] != dep[r] || head[l] != head[r]){",
			"                if(!rev) l_ans = op(l_ans, node[1].prod(n-in[l]-1, n-in[head[l]]));",
			"                else r_ans = op(node[0].prod(in[head[l]], in[l]+1), r_ans);",
			"                l = par[head[l]];",
			"            } else {",
			"                if(in[l] > in[r]) swap(l, r), rev ^= 1;",
			"                if(!rev) l_ans = op(l_ans, node[0].prod(in[l], in[r]+1));",
			"                else r_ans = op(node[1].prod(n-in[r]-1, n-in[l]), r_ans);",
			"                return op(l_ans, r_ans);",
			"            }",
			"        }",
			"    }",
			"    ",
			"    S prod(int r){",
			"        assert(0 <= r && r < n);",
			"        return node[0].prod(in[r], out[r]);",
			"    }",
			"    ",
			"    S get(int p){",
			"        assert(0 <= p && p < n);",
			"        return node[0].get(in[p]);",
			"    }",
			"    ",
			"    void set(int p, const S& x){",
			"        assert(0 <= p && p < n);",
			"        node[0].set(in[p], x);",
			"        node[1].set(n-in[p]-1, x);",
			"    }",
			"    ",
			"    void add(int p, const S& x){",
			"        assert(0 <= p && p < n);",
			"        node[0].add(in[p], x);",
			"        node[1].add(n-in[p]-1, x);",
			"    }",
			"    ",
			"    int lca(int l, int r){",
			"        assert(0 <= l && 0 <= r && l < n && r < n);",
			"        while(true){",
			"            if(dep[l] < dep[r]) swap(l, r);",
			"            if(dep[l] != dep[r] || head[l] != head[r]){",
			"                l = par[head[l]];",
			"            } else {",
			"                if(in[l] > in[r]) swap(l, r);",
			"                return l;",
			"            }",
			"        }",
			"    }",
			"    ",
			"    int dist(int l, int r){",
			"        assert(0 <= l && 0 <= r && l < n && r < n);",
			"        int d = 0;",
			"        while(true){",
			"            if(dep[l] < dep[r]) swap(l, r);",
			"            if(dep[l] != dep[r] || head[l] != head[r]){",
			"                d += in[l] - in[head[l]] + 1;",
			"                l = par[head[l]];",
			"            } else {",
			"                if(in[l] > in[r]) swap(l, r);",
			"                d += in[r] - in[l];",
			"                return d;",
			"            }",
			"        }",
			"    }",
			"    ",
			"    ",
			"    void apply(int l, int r, const F& x){",
			"        while(true){",
			"            if(dep[l] < dep[r]) swap(l, r);",
			"            if(dep[l] != dep[r] || head[l] != head[r]){",
			"                node[0].apply(in[head[l]], in[l]+1, x);",
			"                node[1].apply(n-in[l]-1, n-in[head[l]], x);",
			"                l = par[head[l]];",
			"            } else {",
			"                if(in[l] > in[r]) swap(l, r);",
			"                node[0].apply(in[l], in[r]+1, x);",
			"                node[1].apply(n-in[r]-1, n-in[l], x);",
			"                break;",
			"            }",
			"        }",
			"    }",
			"    ",
			"    void apply(int r, const F& x){",
			"        node[0].apply(in[r], out[r], x);",
			"        node[1].apply(n-out[r], n-in[r], x);",
			"    }",
			"};"
		]
	},
	
	"inversion": {
		"prefix": "inversion",
		"body": [
			"auto inversion = [](const vector<int>& v){",
			"    fenwick_tree<int> tree(v.size());",
			"    long long res = 0;",
			"    for(int i = 0; i < ssize(v); i++){",
			"        res += tree.sum(v[i]+1, ssize(v));",
			"        tree.add(v[i], 1);",
			"    }",
			"    return res;",
			"};"
		]
	},
	
	"iossync": {
		"prefix": "iossync",
		"body": [
			"ios::sync_with_stdio(0); cin.tie(0);"
		]
	},
	
	"janken": {
		"prefix": "janken",
		"body": [
			"auto janken = [](char R, char C, char P, char a, char b){",
			"    if(a == b) return 0;",
			"    if(a == R && b == C) return 1;",
			"    if(a == C && b == P) return 1;",
			"    if(a == P && b == R) return 1;",
			"    else return -1;",
			"};"
		]
	},
	
	"large_lcm": {
		"prefix": "large_lcm",
		"body": [
			"auto large_lcm = [](const vector<int>& v){",
			"    unordered_map<int, int> lc;",
			"    for(int i : v){",
			"        vector<pair<int, int>> f = factorize(i);",
			"        for(auto [e, n] : f){",
			"            lc[e] = max(lc[e], n);",
			"        }",
			"    }",
			"    vector<pair<int, int>> res;",
			"    for(auto [e, n] : lc){",
			"        res.emplace_back(e, n);",
			"    }",
			"    return res;",
			"};"
		]
	},
	
	"lazy_cheat": {
		"prefix": "lazy_cheat",
		"body": [
			"struct S{",
			"    long long value;",
			"    int size;",
			"};",
			"using F = long long;",
			"",
			"S op(S a, S b){ return {a.value+b.value, a.size+b.size}; }",
			"S e(){ return {0, 0}; }",
			"S mapping(F f, S x){ return {x.value + f*x.size, x.size}; }",
			"F composition(F f, F g){ return f+g; }",
			"F id(){ return 0; }"
		]
	},
	
	"lis": {
		"prefix": "lis",
		"body": [
			"template<typename T>",
			"auto lis = [](const vector<T>& v){",
			"    //デフォルトで狭義単調増加",
			"    constexpr auto T_bound = lower_bound<typename vector<T>::iterator, T>;",
			"    vector<T> cur;",
			"    vector<vector<int>> ind;",
			"    for(int i = 0; i < (int)v.size(); i++){",
			"        auto itr = T_bound(cur.begin(), cur.end(), v[i]);",
			"        if(itr == cur.end()){",
			"            ind.push_back({i});",
			"            cur.push_back(v[i]);",
			"        } else {",
			"            ind[itr - cur.begin()].push_back(i);",
			"            *itr = v[i];",
			"        }",
			"    }",
			"    vector<int> res(ind.size()+1, INF);",
			"    for(int i = (int)ind.size()-1; i >= 0; i--){",
			"        res[i] = *prev(upper_bound(ind[i].begin(), ind[i].end(), res[i+1]));",
			"    } res.pop_back();",
			"    return res;",
			"};"
		]
	},
	
	"mergesort_tree": {
		"prefix": "mergesort_tree",
		"body": [
			"template<typename T, auto comp = less<T>()>",
			"struct mergesort_tree{",
			"    int siz;",
			"    vector<vector<T>> node;",
			"    vector<vector<T>> prefix;",
			"    ",
			"    mergesort_tree(const vector<T>& v):",
			"        siz(v.size()), node(siz*2), prefix(siz*2, {0}){",
			"            for(int i = 0; i < siz; i++) node[i+siz] = {v[i]};",
			"            for(int i = siz-1; i > 0; i--){",
			"                node[i].reserve(node[i*2].size() + node[i*2+1].size());",
			"                merge(node[i*2].begin(), node[i*2].end(), node[i*2+1].begin(), node[i*2+1].end(), back_inserter(node[i]), comp);",
			"            }",
			"            for(int i = 1; i < 2*siz; i++){",
			"                prefix[i].reserve(node[i].size()+1);",
			"                for(int j = 0; j < node[i].size(); j++){",
			"                    prefix[i].emplace_back(prefix[i].back() + node[i][j]);",
			"                }",
			"            }",
			"        }",
			"    ",
			"    T prod(int left, int right, T val){",
			"        T ans = 0;",
			"        assert(0 <= left && right <= siz);",
			"        for(left+=siz, right+=siz; left < right; left>>=1, right>>=1){",
			"            if(left&1){",
			"                ans = ans + prefix[left][upper_bound(node[left].begin(), node[left].end(), val, comp)-node[left].begin()];",
			"                left++;",
			"            }",
			"            if(right&1){",
			"                right--;",
			"                ans = ans + prefix[right][upper_bound(node[right].begin(), node[right].end(), val, comp)-node[right].begin()];",
			"            }",
			"        }",
			"        return ans;",
			"    }",
			"};"
		]
	},
	
	"modoid": {
		"prefix": "modoid",
		"body": [
			"struct S{",
			"    mint9 first, second;",
			"    S() : first(mint9::raw(1)), second(mint9::raw(0)) {}",
			"    S(const mint9 &l, const mint9 &r) : first(l), second(r) {}",
			"};",
			"inline S op(const S& l, const S& r){",
			"    return {r.first*l.first, r.first*l.second + r.second};",
			"}",
			"inline S e(){",
			"    return {1, 0};",
			"}"
		]
	},
	
	"ordered_set": {
		"prefix": "ordered_set",
		"body": [
			"struct ordered_set{",
			"    using ll = unsigned long long;",
			"    ",
			"    private:",
			"    ",
			"    struct node_t{",
			"        ll sum = 0;",
			"        ll value;",
			"        int count = 0;",
			"        array<int, 4> child = {};",
			"        int width = 0;",
			"        node_t() noexcept = default;",
			"        node_t(const node_t &o) noexcept = default;",
			"        node_t(node_t &&o) noexcept = default;",
			"        node_t &operator=(const node_t &o) noexcept = default;",
			"        node_t &operator=(node_t &&o) noexcept = default;",
			"    };",
			"    ",
			"    struct ref_node_t{",
			"        ll val;",
			"        bool exist;",
			"        ref_node_t(ll x, bool e) : val{x}, exist{e} {}",
			"    };",
			"    ",
			"    static constexpr ll one = 1;",
			"    static constexpr int bit_width = sizeof(ll) * 8;",
			"    vector<node_t> node;",
			"    int root = -1;",
			"    int siz = 0;",
			"    ",
			"    //__builtin_clz",
			"    template<typename _Tp>",
			"    inline int clz(_Tp x) const {",
			"        if constexpr(sizeof(_Tp) == 8ull) return __builtin_clzll(x);",
			"        else return __builtin_clz(x);",
			"    }",
			"    ",
			"    inline ll mask(int l, int r) const {",
			"        if(r >= bit_width) return -(one<<l);",
			"        return (one<<r) - (one<<l);",
			"    }",
			"    ",
			"    inline ll masked(ll v, int l, int r) const {",
			"        return mask(l, r) & v;",
			"    }",
			"    ",
			"    inline int diff_bit(ll x, ll y) const {",
			"        return ((bit_width-1 - clz(x^y))|1) + 1;",
			"    }",
			"    ",
			"    inline int make_node(ll v, ll x){",
			"        node.emplace_back();",
			"        node.back().value = v;",
			"        node.back().sum = move(x);",
			"        return ssize(node)-1;",
			"    }",
			"    ",
			"    public:",
			"    ",
			"    ordered_set(){",
			"        make_node(0, 0);",
			"        root = make_node(0, 0);",
			"        node[root].width = bit_width;",
			"    }",
			"    ",
			"    ordered_set& operator=(ordered_set&& o) noexcept = default;",
			"    ",
			"    ordered_set(ordered_set&& o) noexcept = default;",
			"    ",
			"    void insert(ll v) {",
			"        int pos = root;",
			"        int bit = bit_width;",
			"        siz++;",
			"        while(true){",
			"            ll mv = masked(v, bit-node[pos].width, bit);",
			"            ll mnv = masked(node[pos].value, bit-node[pos].width, bit);",
			"            if(mv != mnv){",
			"                int diff = diff_bit(mv, mnv);",
			"                int b = (mv>>(diff-2))&3;",
			"                int nb = (mnv>>(diff-2))&3;",
			"                int inter = make_node(node[pos].value, node[pos].sum);",
			"                int leaf = make_node(v, v);",
			"                node[inter] = node[pos];",
			"                node[inter].width -= bit - diff;",
			"                memset(node[pos].child.data(), 0, sizeof(int)*4);",
			"                node[pos].child[b] = leaf;",
			"                node[pos].child[nb] = inter;",
			"                node[pos].count++;",
			"                node[pos].width = bit - diff;",
			"                node[pos].sum += v;",
			"                bit = diff;",
			"                node[leaf].width = bit;",
			"                node[leaf].count = 1;",
			"                pos = leaf;",
			"                return;",
			"            } else {",
			"                node[pos].count++;",
			"                bit -= node[pos].width;",
			"                node[pos].sum += v;",
			"                if(bit == 0) return;",
			"                int nex = node[pos].child[(v>>(bit-2))&3];",
			"                if(nex == 0){",
			"                    nex = node[pos].child[(v>>(bit-2))&3] = make_node(v, v);",
			"                    node[nex].count = 1;",
			"                    node[nex].width = bit;",
			"                    node[nex].sum = v;",
			"                    return;",
			"                }",
			"                pos = nex;",
			"            }",
			"        }",
			"    }",
			"    ",
			"    int count(ll v) const {",
			"        int pos = root;",
			"        int bit = bit_width;",
			"        while(pos != 0){",
			"            ll mv = masked(v, bit-node[pos].width, bit);",
			"            ll mnv = masked(node[pos].value, bit-node[pos].width, bit);",
			"            if(mv != mnv) return 0;",
			"            bit -= node[pos].width;",
			"            if(bit == 0) return node[pos].count;",
			"            pos = node[pos].child[(v>>(bit-2))&3];",
			"        }",
			"        return 0;",
			"    }",
			"    ",
			"    void erase(ll v, int n = -1) {",
			"        if(n == -1) n = count(v);",
			"        if(n == 0) return;",
			"        int pos = root;",
			"        int bit = bit_width;",
			"        siz -= n;",
			"        while(true){",
			"            node[pos].count -= n;",
			"            node[pos].sum -= v*n;",
			"            bit -= node[pos].width;",
			"            if(bit == 0) return;",
			"            pos = node[pos].child[(v>>(bit-2))&3];",
			"        }",
			"    }",
			"    ",
			"    const ref_node_t operator[](int k) const {",
			"        if(k >= 0) k = siz-k-1;",
			"        else k += siz;",
			"        if(k < 0 || siz <= k) return ref_node_t{0, false};",
			"        ",
			"        k++;",
			"        int pos = root;",
			"        int bit = bit_width;",
			"        while(true){",
			"            bit -= node[pos].width;",
			"            if(bit == 0) return ref_node_t{node[pos].value, true};",
			"            constexpr static int b = 0;",
			"            auto &child = node[pos].child;",
			"            if(k <= node[child[b^3]].count){",
			"                pos = child[b^3];",
			"            } else {",
			"                k -= node[child[b^3]].count;",
			"                if(k <= node[child[b^2]].count){",
			"                    pos = child[b^2];",
			"                } else {",
			"                    k -= node[child[b^2]].count;",
			"                    if(k <= node[child[b^1]].count){",
			"                        pos = child[b^1];",
			"                    } else {",
			"                        k -= node[child[b^1]].count;",
			"                        pos = child[b];",
			"                    }",
			"                }",
			"            }",
			"        }",
			"    }",
			"    ",
			"    int order(ll v) const {",
			"        if(v == 0) return 0;",
			"        v--;",
			"        int res = 0;",
			"        int pos = root;",
			"        int bit = bit_width;",
			"        while(pos != 0){",
			"            ll mv = masked(v, bit-node[pos].width, bit);",
			"            ll mnv = masked(node[pos].value, bit-node[pos].width, bit);",
			"            if(mv < mnv){",
			"                return res;",
			"            } else {",
			"                if(mv > mnv){",
			"                    res += node[pos].count;",
			"                    return res;",
			"                } else {",
			"                    bit -= node[pos].width;",
			"                    if(bit == 0) return res + node[pos].count;",
			"                    int b = (v>>(bit-2))&3;",
			"                    auto &child = node[pos].child;",
			"                    constexpr static ll mxv = 0;",
			"                    ",
			"                    if(b >= 1){",
			"                        res += node[child[mxv]].count;",
			"                        if(b >= 2){",
			"                            res += node[child[mxv^1]].count;",
			"                            if(b >= 3){",
			"                                res += node[child[mxv^2]].count;",
			"                            }",
			"                        }",
			"                    }",
			"                    pos = node[pos].child[b];",
			"                }",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"    ",
			"    const ref_node_t lower_bound(ll v) const {",
			"        int ord = order(v);",
			"        if(siz == ord) return ref_node_t{0, false};",
			"        else return ref_node_t{(*this)[ord].val, true};",
			"    }",
			"    ",
			"    const ref_node_t less_bound(ll v) const {",
			"        int ord = v!=numeric_limits<ll>::max() ? order(v+1) : siz;",
			"        if(ord == 0) return ref_node_t{0, false};",
			"        else return ref_node_t{(*this)[ord-1].val, true};",
			"    }",
			"    ",
			"    ll prod(ll k) const {",
			"        assert(k <= (unsigned)siz);",
			"        int pos = root;",
			"        int bit = bit_width;",
			"        ll res = 0;",
			"        while(true){",
			"            bit -= node[pos].width;",
			"            if(bit == 0) return res + k*node[pos].value;",
			"            constexpr static int b = 0;",
			"            auto &child = node[pos].child;",
			"            if(k <= (unsigned)node[child[b]].count){",
			"                pos = child[b];",
			"            } else {",
			"                k -= node[child[b]].count;",
			"                res += node[child[b]].sum;",
			"                if(k <= (unsigned)node[child[b^1]].count){",
			"                    pos = child[b^1];",
			"                } else {",
			"                    k -= node[child[b^1]].count;",
			"                    res += node[child[b^1]].sum;",
			"                    if(k <= (unsigned)node[child[b^2]].count){",
			"                        pos = child[b^2];",
			"                    } else {",
			"                        k -= node[child[b^2]].count;",
			"                        res += node[child[b^2]].sum;",
			"                        pos = child[b^3];",
			"                    }",
			"                }",
			"            }",
			"        }",
			"    }",
			"    ",
			"    ll sum(ll k) const {",
			"        return prod(k);",
			"    }",
			"    ",
			"    ll all_prod() const {",
			"        return node[root].sum;",
			"    }",
			"    ",
			"    int size() const {",
			"        return siz;",
			"    }",
			"    ",
			"    void reserve(int n) {",
			"        node.reserve(2*n+2);",
			"    }",
			"};"
		]
	},
	
	"out": {
		"prefix": "out",
		"body": [
			"auto out = [&](int y, int x){return (y < 0 || x < 0 || y >= h || x >= w);};"
		]
	},
	
	"poly": {
		"prefix": "poly",
		"body": [
			"template<typename T>",
			"struct poly : vector<T> {",
			"    using vector<T>::vector;",
			"    ",
			"    poly(const vector<T> &x) {",
			"        this->resize(x.size());",
			"        for(int i = 0; i < (int)x.size(); i++) (*this)[i] = x[i];",
			"    }",
			"    ",
			"    poly &operator+=(const T &x) {for(auto &i : *this) i += x; return *this;}",
			"    poly &operator-=(const T &x) {for(auto &i : *this) i -= x; return *this;}",
			"    poly &operator*=(const T &x) {for(auto &i : *this) i *= x; return *this;}",
			"    poly &operator/=(const T &x) {for(auto &i : *this) i /= x; return *this;}",
			"    poly &operator%=(const T &x) {for(auto &i : *this) i %= x; return *this;}",
			"    poly operator+(const T &x) {poly res(*this); res += x; return res;}",
			"    poly operator-(const T &x) {poly res(*this); res -= x; return res;}",
			"    poly operator*(const T &x) {poly res(*this); res *= x; return res;}",
			"    poly operator/(const T &x) {poly res(*this); res /= x; return res;}",
			"    poly operator%(const T &x) {poly res(*this); res %= x; return res;}",
			"    ",
			"    poly &operator+=(const poly &x) {extend(x.size()); for(int i = 0; i < (int)x.size(); i++) (*this)[i] += x[i]; return *this;}",
			"    poly &operator-=(const poly &x) {extend(x.size()); for(int i = 0; i < (int)x.size(); i++) (*this)[i] -= x[i]; return *this;}",
			"    poly &operator*=(const poly &x) {fft(x); return *this;}",
			"    ",
			"    __attribute__((optimize(\"O3\")))",
			"    __attribute__((target(\"avx2\")))",
			"    __attribute__((optimize(\"unroll-loops\")))",
			"    void fft(poly x) {",
			"        int siz = bit_ceil(this->size() + x.size());",
			"        vector<T> vl(siz), vr(siz);",
			"        for(int i = 0; i < (int)this->size(); i++) vl[i] = (*this)[i];",
			"        for(int i = 0; i < (int)x.size(); i++) vr[i] = x[i];",
			"        ",
			"        vector<int> rev = calc_rev(siz);",
			"        ",
			"        {",
			"            for(int i = 1; i < siz; i++) if(i < rev[i]) swap(vl[i], vl[rev[i]]);",
			"            for(int i = 1; i < siz; i++) if(i < rev[i]) swap(vr[i], vr[rev[i]]);",
			"            ",
			"            for(int w = 2; w <= siz; w*=2){",
			"                T z = T(3).pow(998244352 / w);",
			"                for(int l = 0; l < siz; l+=w){",
			"                    T pos = 1;",
			"                    for(int i = 0; i < w/2; i++){",
			"                        T u = vl[l+i];",
			"                        T v = vl[l+i+w/2]; v *= pos;",
			"                        vl[l+i] += v;",
			"                        vl[l+i+w/2] = u-v;",
			"                        ",
			"                        u = vr[l+i];",
			"                        v = vr[l+i+w/2]; v *= pos;",
			"                        vr[l+i] += v;",
			"                        vr[l+i+w/2] = u-v;",
			"                        pos *= z;",
			"                    }",
			"                }",
			"            }",
			"        }",
			"        ",
			"        for(int i = 0; i < siz; i++) vl[i] *= vr[i];",
			"        ",
			"        {",
			"            for(int i = 1; i < siz; i++) if(i < rev[i]) swap(vl[i], vl[rev[i]]);",
			"            ",
			"            for(int w = 2; w <= siz; w*=2){",
			"                T z = T(3).pow(998244352 - 998244352/ w);",
			"                for(int l = 0; l < siz; l+=w){",
			"                    T pos = 1;",
			"                    for(int i = 0; i < w/2; i++){",
			"                        T u = vl[l+i];",
			"                        T v = vl[l+i+w/2]; v *= pos;",
			"                        vl[l+i] += v;",
			"                        vl[l+i+w/2] = u-v;",
			"                        pos *= z;",
			"                    }",
			"                }",
			"            }",
			"        }",
			"        ",
			"        extend(this->size() + x.size() - 1ull);",
			"        T inv_n = T(siz).pow(998244351);",
			"        for(int i = 0; i < (int)this->size(); i++) (*this)[i] = vl[i] * inv_n;",
			"    }",
			"    ",
			"    vector<int> calc_rev(int siz) const {",
			"        int log = countr_zero((unsigned)siz);",
			"        vector<int> res(siz);",
			"        for(int i = 1; i < siz; i++){",
			"            res[i] = (res[i>>1]>>1) | ((i&1)<<(log-1));",
			"        }",
			"        return res;",
			"    }",
			"    void extend(unsigned siz) {if(this->size() < siz) this->resize(siz, 0);}",
			"};"
		]
	},
	
	"qcfium": {
		"prefix": "qcfium",
		"body": [
			"#pragma GCC target(\"avx2\")",
			"#pragma GCC optimize(\"O3\")",
			"#pragma GCC optimize(\"unroll-loops\")"
		]
	},
	
	"random32": {
		"prefix": "random32",
		"body": [
			"random_device seed_gen;",
			"mt19937 engine(seed_gen());"
		]
	},
	
	"random64": {
		"prefix": "random64",
		"body": [
			"random_device seed_gen;",
			"mt19937_64 engine(seed_gen());"
		]
	},
	
	"rangeset": {
		"prefix": "rangeset",
		"body": [
			"template<typename T = long long>",
			"struct rangeset{",
			"    set<pair<T, T>> S;",
			"    static constexpr T T_MAX = numeric_limits<T>::max();",
			"    static constexpr T T_MIN = numeric_limits<T>::min();",
			"    ",
			"    void insert(T x){",
			"        insert(x, x+1);",
			"    }",
			"    ",
			"    auto S_lower_bound(T x){",
			"        return S.lower_bound({x, T_MIN});",
			"    }",
			"    ",
			"    auto S_upper_bound(T x){",
			"        return S.upper_bound({x, T_MAX});",
			"    }",
			"    ",
			"    void insert(T xl, T xr){",
			"        T l = xl, r = xr;",
			"        auto litr = S_lower_bound(xl);",
			"        auto ritr = S_upper_bound(xr);",
			"        ",
			"        if(litr != S.begin()){",
			"            auto plitr = prev(litr);",
			"            if(plitr->second >= xl){",
			"                l = plitr->first;",
			"                litr = plitr;",
			"            }",
			"        }",
			"        if(ritr != S.begin()){",
			"            auto pritr = prev(ritr);",
			"            if(pritr->second > xr){",
			"                r = pritr->second;",
			"            }",
			"        }",
			"        ",
			"        S.erase(litr, ritr);",
			"        S.insert({l, r});",
			"    }",
			"    ",
			"    void erase(T x){",
			"        erase(x, x+1);",
			"    }",
			"    ",
			"    void erase(T xl, T xr){",
			"        auto litr = S_lower_bound(xl);",
			"        auto ritr = S_lower_bound(xr);",
			"        ",
			"        if(ritr == S.begin()) return;",
			"        ",
			"        vector<pair<T, T>> insert_list;",
			"        ",
			"        if(litr != S.begin()){",
			"            auto plitr = prev(litr);",
			"            if(plitr->second > xl){",
			"                insert_list.emplace_back(plitr->first, xl);",
			"                litr = plitr;",
			"            }",
			"        }",
			"        if(ritr != S.begin()){",
			"            auto pritr = prev(ritr);",
			"            if(pritr->second > xr){",
			"                insert_list.emplace_back(xr, pritr->second);",
			"            }",
			"        }",
			"        ",
			"        S.erase(litr, ritr);",
			"        for(auto& i : insert_list) S.insert(i);",
			"    }",
			"    ",
			"    T lower_bound(T x){",
			"        auto itr = S_lower_bound(x);",
			"        if(itr != S.begin()){",
			"            auto pitr = prev(itr);",
			"            if(pitr->second > x) return x;",
			"        }",
			"        if(itr != S.end()) return itr->first;",
			"        return -1;",
			"    }",
			"    ",
			"    T mex(T x){",
			"        auto itr = S_upper_bound(x);",
			"        if(itr != S.begin()){",
			"            auto pitr = prev(itr);",
			"            if(pitr->second <= x) return x;",
			"            else return pitr->second;",
			"        }",
			"        return x;",
			"    }",
			"    ",
			"    bool covered(T x){",
			"        return covered(x, x+1);",
			"    }",
			"    ",
			"    bool covered(T xl, T xr){",
			"        auto itr = S_upper_bound(xl);",
			"        if(itr != S.begin() && prev(itr)->second > xr) return true;",
			"        return false;",
			"    }",
			"    ",
			"    pair<T, T> get_range(T x){",
			"        return *prev(S_upper_bound(x));",
			"    }",
			"};"
		]
	},
	
	"ran_length": {
		"prefix": "ran_length",
		"body": [
			"auto ran_length = [](const string& s){",
			"    vector<pair<char, int>> res;",
			"    int from = 0;",
			"    for(int i = 1; i < (int)s.size(); i++){",
			"        if(s[from] != s[i]){",
			"            res.emplace_back(s[from], i-from);",
			"            from = i;",
			"        }",
			"    }",
			"    res.emplace_back(s[from], ssize(s)-from);",
			"    return res;",
			"};"
		]
	},
	
	"rolling_hash": {
		"prefix": "rolling_hash",
		"body": [
			"struct rolling_hash{",
			"    constexpr static long long mod = 1000000009;",
			"    constexpr static long long base0 = 716951, base1 = 716953;",
			"    ",
			"    int n;",
			"    vector<long long> hashed0, hashed1;",
			"    vector<long long> pow0, pow1;",
			"    ",
			"    rolling_hash(const string &s) : n(s.size()){",
			"        hashed0.resize(n+1);",
			"        pow0.resize(n+1);",
			"        pow0[0] = 1;",
			"        for(int i = 0; i < n; i++){",
			"            hashed0[i+1] = (hashed0[i] * base0 + s[i]) % mod;",
			"            pow0[i+1] = pow0[i] * base0 % mod;",
			"        }",
			"        ",
			"        hashed1.resize(n+1);",
			"        pow1.resize(n+1);",
			"        pow1[0] = 1;",
			"        for(int i = 0; i < n; i++){",
			"            hashed1[i+1] = (hashed1[i] * base1 + s[i]) % mod;",
			"            pow1[i+1] = pow1[i] * base1 % mod;",
			"        }",
			"    }",
			"    ",
			"    unsigned long long get(int l, int r){",
			"        unsigned long long h0 = (hashed0[r] - hashed0[l] * pow0[r-l]) % mod;",
			"        unsigned long long h1 = (hashed1[r] - hashed1[l] * pow1[r-l]) % mod;",
			"        if(h0>>63) h0 += mod;",
			"        if(h1>>63) h1 += mod;",
			"        return (h0<<32) + h1;",
			"    }",
			"};"
		]
	},
	
	"rotate": {
		"prefix": "rotate",
		"body": [
			"template<typaname T>",
			"auto rotate = [](vector<T>& defa){",
			"    int siz = defa.size();",
			"    vector<T> res(siz, T(siz, ' '));",
			"    for(int i = 0; i < siz; i++) for(int j = 0; j < siz; j++) res[j][siz-1-i] = defa[i][j];",
			"    defa = res;",
			"};"
		]
	},
	
	"sat": {
		"prefix": "sat",
		"body": [
			"template<typename T>",
			"T add_sat(T a, T b){",
			"    T MAX = numeric_limits<T>::max(), MIN = numeric_limits<T>::min();",
			"    if(a > 0 && b > MAX - a) return MAX;",
			"    if(a < 0 && b < MIN - a) return MIN;",
			"    return a+b;",
			"}",
			"template<typename T>",
			"T mul_sat(T a, T b){",
			"    T MAX = numeric_limits<T>::max(), MIN = numeric_limits<T>::min();",
			"    T res;",
			"    if(__builtin_mul_overflow(a, b, &res)){",
			"        if((a>0)^(b>0)) return MIN;",
			"        else return MAX;",
			"    }",
			"    return a*b;",
			"}"
		]
	},
	
	"segtree": {
		"prefix": "segtree",
		"body": [
			"template<typename S, auto op, auto e>",
			"struct segtree{",
			"    int siz;",
			"    vector<S> node;",
			"    ",
			"    segtree() = default;",
			"    segtree(unsigned n):",
			"        siz(bit_ceil(n)), node(siz*2, e()){}",
			"    segtree(const vector<S>& v){init(v);}",
			"    void init(const vector<S>& v){",
			"        siz = bit_ceil(v.size()); node.resize(siz*2, e());",
			"        for(int i = 0; i < (int)v.size(); i++) node[i+siz] = v[i];",
			"        for(int i = siz-1; i >= 1; i--) node[i] = op(node[i*2], node[i*2+1]);",
			"    }",
			"    ",
			"    const S &operator[](int pos) const {return node[pos+siz];}",
			"    ",
			"    const S &get(int pos) const {return node[pos+siz];}",
			"    ",
			"    void set(int pos, const S &x){",
			"        assert(0 <= pos && pos < siz);",
			"        pos += siz;",
			"        node[pos] = x;",
			"        while(pos>>=1) node[pos] = op(node[pos<<1], node[(pos<<1)+1]);",
			"    }",
			"    ",
			"    void add(int pos, const S &x){",
			"        assert(0 <= pos && pos < siz);",
			"        pos += siz;",
			"        node[pos] = op(node[pos], x);",
			"        while(pos>>=1) node[pos] = op(node[pos], x);",
			"    }",
			"    ",
			"    S prod(int left, int right){",
			"        left = max(0, left); right = min(right, siz);",
			"        S l_ans = e(), r_ans = e();",
			"        for(left+=siz, right+=siz; left < right; left>>=1, right>>=1){",
			"            if(left&1) l_ans = op(l_ans, node[left++]);",
			"            if(right&1) r_ans = op(node[--right], r_ans);",
			"        }",
			"        return op(l_ans, r_ans);",
			"    }",
			"    ",
			"    S all_prod(){",
			"        return node[1];",
			"    }",
			"};"
		]
	},
	
	"segtree_2d": {
		"prefix": "segtree_2d",
		"body": [
			"template <typename T, typename S, auto op, auto e>",
			"struct dynamic_segtree{",
			"    private:",
			"    ",
			"    struct node_t{",
			"        S sum;",
			"        T value;",
			"        array<int, 4> child = {};",
			"        int width = 0;",
			"        node_t() : sum{e()} {}",
			"        node_t(const node_t &o) noexcept = default;",
			"        node_t(node_t &&o) noexcept = default;",
			"        node_t &operator=(const node_t &o) noexcept = default;",
			"        node_t &operator=(node_t &&o) noexcept = default;",
			"    };",
			"    ",
			"    static constexpr T one = 1;",
			"    static constexpr int bit_width = sizeof(T) * 8;",
			"    vector<node_t> node;",
			"    int root = -1;",
			"    ",
			"    //__builtin_clz",
			"    template<typename _Tp>",
			"    inline int clz(_Tp x) const {",
			"        if constexpr(sizeof(_Tp) == 8ull) return __builtin_clzll(x);",
			"        else return __builtin_clz(x);",
			"    }",
			"    ",
			"    inline T mask(int l, int r) const {",
			"        if(r >= bit_width) return -(one<<l);",
			"        return (one<<r) - (one<<l);",
			"    }",
			"    ",
			"    inline T masked(T v, int l, int r) const {",
			"        return mask(l, r) & v;",
			"    }",
			"    ",
			"    inline int diff_bit(T x, T y) const {",
			"        return ((bit_width-1 - clz(x^y))|1) + 1;",
			"    }",
			"    ",
			"    inline int make_node(T v, S x){",
			"        node.emplace_back();",
			"        node.back().value = v;",
			"        node.back().sum = move(x);",
			"        return ssize(node)-1;",
			"    }",
			"    ",
			"    public:",
			"    ",
			"    dynamic_segtree(){",
			"        make_node(0, e());",
			"        root = make_node(0, e());",
			"        node[root].width = bit_width;",
			"    }",
			"    ",
			"    dynamic_segtree<T, S, op, e>& operator=(dynamic_segtree<T, S, op, e>&& o) noexcept = default;",
			"    ",
			"    dynamic_segtree(dynamic_segtree&& o) noexcept = default;",
			"    ",
			"    void set(T v, const S &x) {",
			"        int pos = root;",
			"        int bit = bit_width;",
			"        int route[65], route_cnt = 0;",
			"        while(true){",
			"            T mv = masked(v, bit-node[pos].width, bit);",
			"            T mnv = masked(node[pos].value, bit-node[pos].width, bit);",
			"            if(mv != mnv){",
			"                route[route_cnt++] = pos;",
			"                int diff = diff_bit(mv, mnv);",
			"                int b = (mv>>(diff-2))&3;",
			"                int nb = (mnv>>(diff-2))&3;",
			"                int inter = make_node(node[pos].value, node[pos].sum);",
			"                int leaf = make_node(v, x);",
			"                node[inter] = node[pos];",
			"                node[inter].width -= bit - diff;",
			"                memset(node[pos].child.data(), 0, sizeof(int)*4);",
			"                node[pos].child[b] = leaf;",
			"                node[pos].child[nb] = inter;",
			"                node[pos].width = bit - diff;",
			"                bit = diff;",
			"                node[leaf].width = bit;",
			"                pos = leaf;",
			"                break;",
			"            } else {",
			"                ",
			"                bit -= node[pos].width;",
			"                if(bit == 0){",
			"                    node[pos].sum = x;",
			"                    break;",
			"                }",
			"                route[route_cnt++] = pos;",
			"                int nex = node[pos].child[(v>>(bit-2))&3];",
			"                if(nex == 0){",
			"                    nex = node[pos].child[(v>>(bit-2))&3] = make_node(v, x);",
			"                    node[nex].width = bit;",
			"                    break;",
			"                }",
			"                pos = nex;",
			"            }",
			"        }",
			"        for(int i = route_cnt-1; i >= 0; i--){",
			"            int idx = route[i];",
			"            auto &child = node[idx].child;",
			"            node[idx].sum = op(op(op(node[child[0]].sum, node[child[1]].sum), node[child[2]].sum), node[child[3]].sum);",
			"        }",
			"    }",
			"    ",
			"    S get(T p) const {",
			"        int pos = root;",
			"        int bit = bit_width;",
			"        while(pos != 0){",
			"            bit -= node[pos].width;",
			"            if(bit == 0) return node[pos].value==p ? node[pos].sum : e();",
			"            ",
			"            pos = node[pos].child[(p>>(bit-2))&3];",
			"        }",
			"        return e();",
			"    }",
			"    ",
			"    S prod(T l, T r) const {",
			"        return _prod(l, r, root, bit_width);",
			"    }",
			"    S _prod(T l, T r, int pos, int bit) const {",
			"        if(pos == 0) return e();",
			"        bit -= node[pos].width;",
			"        T mv = masked(node[pos].value, bit, bit_width);",
			"        if(r <= mv) return e();",
			"        if(l != numeric_limits<T>::min() && mv-1+(one<<bit) < l) return e();",
			"        if(l <= mv && mv-1+(one<<bit) < r){",
			"            return node[pos].sum;",
			"        }",
			"        auto &child = node[pos].child;",
			"        return op(op(op(_prod(l, r, child[0], bit), _prod(l, r, child[1], bit)), _prod(l, r, child[2], bit)), _prod(l, r, child[3], bit));",
			"    }",
			"    ",
			"    S all_prod() const {",
			"        return node[root].sum;",
			"    }",
			"    ",
			"    void reserve(int n) {",
			"        node.reserve(2*n+2);",
			"    }",
			"};",
			"template<typename S, auto op, auto e>",
			"struct segtree_2d{",
			"    int siz;",
			"    vector<dynamic_segtree<int, S, op, e>> seg;",
			"    ",
			"    segtree_2d(int _n) : siz(bit_ceil(unsigned(_n))), seg(siz*2) {}",
			"    ",
			"    void set(int x, int y, const S &val){",
			"        assert(0 <= x && x < siz);",
			"        x += siz;",
			"        seg[x].set(y, val);",
			"        while(x>>=1){",
			"            seg[x].set(y, op(seg[x*2].get(y), seg[x*2+1].get(y)));",
			"        }",
			"    }",
			"    ",
			"    void add(int x, int y, const S &val){",
			"        assert(0 <= x && x < siz);",
			"        x += siz;",
			"        seg[x].set(y, op(seg[x].get(y), val));",
			"        while(x>>=1){",
			"            seg[x].set(y, op(seg[x].get(y), val));",
			"        }",
			"    }",
			"    ",
			"    S get(int x, int y){",
			"        return prod(x, y, x+1, y+1);",
			"    }",
			"    ",
			"    S prod(int l, int d, int r, int u){",
			"        S ans = e();",
			"        for(l+=siz,r+=siz; l < r; l>>=1,r>>=1){",
			"            if(l&1) ans = op(ans, seg[l++].prod(d, u));",
			"            if(r&1) ans = op(ans, seg[--r].prod(d, u));",
			"        }",
			"        return ans;",
			"    }",
			"};"
		]
	},
	
	"sinit": {
		"prefix": "sinit",
		"body": [
			"#ifdef LOCAL",
			"#include <bits/Lstdc++.h>",
			"#else",
			"#include <bits/stdc++.h>",
			"struct fast_io{fast_io(){std::ios::sync_with_stdio(0); std::cin.tie(0);}} _fast_io_ins;",
			"#endif",
			"using namespace std;",
			"",
			"using uint = unsigned;",
			"using ull = unsigned long long;",
			"using ll = long long;",
			"using ld = long double;",
			"#define el '\\n'",
			"#define all(x) begin(x), end(x)",
			"#define elif else if",
			"",
			"constexpr long long LLINF = (1ll<<62)-1; constexpr int INF = (1<<30)-1;",
			"template<typename T, typename U> istream& operator>>(istream& ist, pair<T, U>& p) {ist >> p.first >> p.second; return ist;} template<typename T> istream& operator>>(istream& ist, vector<T>& v) {for(T& i : v) ist >> i; return ist;} void read_d_graph(vector<vector<pair<long long, int>>>& v, int m, int num = -1); void read_d_graph(vector<vector<int>>& v, int m, int num = -1); void read_ud_graph(vector<vector<pair<long long, int>>>& v, int m, int num = -1); void read_ud_graph(vector<vector<int>>& v, int m, int num = -1); template<typename T> void read_multi() {} template<typename T, typename... U> void read_multi(int n, vector<T>& v, U&&... args) {if(n < ssize(v)) {cin >> v[n]; read_multi(args..., n+1, v);}} template<typename T, typename... U> void read_multi(vector<T>& v, U&&... args) {read_multi(args..., 0, v);} template<typename T = string> T input() {T res; cin >> res; return res;} template<typename T, typename U> ostream& operator<<(ostream& ost, const pair<T, U> p) {ost << '{' << p.first << ' ' << p.second << '}'; return ost;} template<typename T> ostream& operator<<(ostream& ost, const vector<T>& v) {for(int i = 0; i < ssize(v); i++) {ost << (i ? \" \" : \"\") << v[i];} return ost;} template<typename T> ostream& operator<<(ostream& ost, const vector<vector<T>>& v) {for(int i = 0; i < ssize(v); i++) {ost << (i ? \"\\n\" : \"\") << v[i];} return ost;}",
			"void add_each(...) {} template<typename T, typename... U> void add_each(long long n, vector<T>& v, U&... args); template<typename T, typename U> inline bool chmin(T& a, U b) {if(a > b){a = b; return true;} return false;} template<typename T, typename U> inline bool chmax(T& a, U b) {if(a < b){a = b; return true;} return false;} template<typename T> inline T minv(const vector<T>& v) {return *min_element(v.begin(), v.end());} template<typename T> inline T maxv(const vector<T>& v) {return *max_element(v.begin(), v.end());} long long power(long long val, long long num, long long mod = LLONG_MAX);",
			"",
			"#if __has_include(<atcoder/modint>)",
			"#include <atcoder/modint>",
			"using namespace atcoder;",
			"using mint9 = modint998244353;",
			"using mint1 = modint1000000007;",
			"ostream& operator<<(ostream& ost, const mint1& x) {ost << x.val(); return ost;} ostream& operator<<(ostream& ost, const mint9& x) {ost << x.val(); return ost;}",
			"#endif",
			"",
			"//*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*/",
			"//*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*/",
			"",
			"",
			"",
			"signed main(){",
			"    $1",
			"    ",
			"}",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"//*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*/",
			"//*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*/",
			"",
			"void read_d_graph(vector<vector<pair<long long, int>>>& v, int m, int num){",
			"    int a, b; long long c;",
			"    for(int _ = 0; _ < m; _++){",
			"        cin >> a >> b >> c;",
			"        a += num; b += num;",
			"        v[a].emplace_back(c, b);",
			"    }",
			"}",
			"void read_d_graph(vector<vector<int>>& v, int m, int num){",
			"    int a, b;",
			"    for(int _ = 0; _ < m; _++){",
			"        cin >> a >> b;",
			"        a += num; b += num;",
			"        v[a].emplace_back(b);",
			"    }",
			"}",
			"void read_ud_graph(vector<vector<pair<long long, int>>>& v, int m, int num){",
			"    int a, b; long long c;",
			"    for(int _ = 0; _ < m; _++){",
			"        cin >> a >> b >> c;",
			"        a += num; b += num;",
			"        v[a].emplace_back(c, b);",
			"        v[b].emplace_back(c, a);",
			"    }",
			"}",
			"void read_ud_graph(vector<vector<int>>& v, int m, int num){",
			"    int a, b;",
			"    for(int _ = 0; _ < m; _++){",
			"        cin >> a >> b;",
			"        a += num; b += num;",
			"        v[a].emplace_back(b);",
			"        v[b].emplace_back(a);",
			"    }",
			"}",
			"template<typename T, typename... U> void add_each(long long n, vector<T>& v, U&... args){",
			"    for(auto& i : v) i += n;",
			"    add_each(n, args...);",
			"}",
			"long long power(long long val, long long num, long long mod){",
			"    assert(mod >= 0); assert(num >= 0);",
			"    long long res = 1;",
			"    val %= mod;",
			"    while(num){",
			"        if(num&1) res = (res*val)%mod;",
			"        val = (val*val)%mod;",
			"        num >>= 1;",
			"    }",
			"    return res;",
			"}",
			"//PgUp5回"
		]
	},
	
	"sparse_table": {
		"prefix": "sparse_table",
		"body": [
			"template<typename T, auto op, auto e>",
			"struct sparse_table{",
			"    int n;",
			"    vector<T> table;",
			"    vector<T> start;",
			"    ",
			"    sparse_table() = default;",
			"    sparse_table(const vector<T>& v):",
			"        n(v.size()), table(v), start(1){",
			"            if(v.empty()) return;",
			"            int l2n = 31 - __builtin_clz((unsigned)n);",
			"            table.reserve(n*(1+l2n) - (1<<(l2n+1)) + 2 + l2n);",
			"            for(int bi = 1; (1<<bi) <= n; bi++){",
			"                start.push_back(table.size());",
			"                for(int i = 0; i+(1<<bi) <= n; i++){",
			"                    table.push_back(op(table[start[bi-1]+i], table[start[bi-1]+i+(1<<(bi-1))]));",
			"                }",
			"            }",
			"        }",
			"    ",
			"    T prod(int l, int r){",
			"        assert(0 <= l && l <= r && r <= n);",
			"        if(l == r) return e();",
			"        int bi = 31 - __builtin_clz(r-l);",
			"        return op(table[start[bi]+l], table[start[bi]+r-(1<<bi)]);",
			"    }",
			"};"
		]
	},
	
	"suugaku": {
		"prefix": "suugaku",
		"body": [
			"auto _suugaku = [](auto self, const string& s)->long long {",
			"    long long num = 0;",
			"    for(int i = 0; i < s.size(); i++){",
			"        if(s[i] == ' '){",
			"            continue;",
			"        } else if('0' <= s[i] && s[i] <= '9'){",
			"            num *= 10;",
			"            num += s[i]-'0';",
			"        } else if(s[i] == '('){",
			"            int nex = i+1, cnt = 1;",
			"            while(cnt && ++nex < s.size()){",
			"                if(s[nex] == ')') cnt--;",
			"                if(s[nex] == '(') cnt++;",
			"            }",
			"            num *= self(self, s.substr(i+1, nex-i-1));",
			"            i = nex-1;",
			"        } else{",
			"            if(s[i] == '*' || s[i] == 'x'){",
			"                int nex = i+1;",
			"                while(nex < s.size() && (s[nex] == ' ' || ('0' <= s[nex] && s[nex] <= '9'))) nex++;",
			"                num *= self(self, s.substr(i+1, nex-i-1));",
			"                i = nex-1;",
			"            } else if(s[i] == '/'){",
			"                int nex = i+1;",
			"                while(nex < s.size() && (s[nex] == ' ' || ('0' <= s[nex] && s[nex] <= '9'))) nex++;",
			"                num /= self(self, s.substr(i+1, nex-i-1));",
			"                i = nex-1;",
			"            } else if(s[i] == '+'){",
			"                num += self(self, s.substr(i+1));",
			"                break;",
			"            } else if(s[i] == '-'){",
			"                num -= self(self, s.substr(i+1));",
			"                break;",
			"            } else assert(false);",
			"        }",
			"    }",
			"    return num;",
			"};",
			"auto suugaku = [](const string& s) {return _suugaku(_suugaku, s);};"
		]
	},
	
	"topological_sort": {
		"prefix": "topological_sort",
		"body": [
			"auto topological_sort = [](const vector<vector<int>>& g){",
			"    int n = g.size();",
			"    vector<int> cnt(n);",
			"    vector<int> res; res.reserve(n);",
			"    queue<int> Q;",
			"    for(const auto& v : g) for(auto i : v) cnt[i]++;",
			"    for(int i = 0; i < n; i++) if(cnt[i] == 0) Q.push(i);",
			"    while(!Q.empty()){",
			"        int pos = Q.front();",
			"        Q.pop();",
			"        res.push_back(pos);",
			"        for(int i : g[pos]) if(--cnt[i] == 0) Q.push(i);",
			"    }",
			"    assert(res.size() == g.size());",
			"    return res;",
			"};"
		]
	},
	
	"trie": {
		"prefix": "trie",
		"body": [
			"struct trie{",
			"    using ar = array<pair<int, int>, 27>;",
			"    vector<ar> node;",
			"    deque<int> reuse;",
			"    ar def;",
			"    char ex;",
			"    trie(int n, char s = '_'){",
			"        node.reserve(n);",
			"        def.fill({-1, 0});",
			"        ex = s;",
			"        make_node();",
			"    }",
			"    ",
			"    int make_node(){",
			"        if(reuse.empty()){",
			"            node.push_back(def);",
			"            return node.size()-1;",
			"        } else {",
			"            int res = reuse.back();",
			"            reuse.pop_back();",
			"            return res;",
			"        }",
			"    }",
			"    ",
			"    void add(const string& s){",
			"        int now = 0, str;",
			"        for(int i = 0; i < (int)s.size(); i++){",
			"            if(s[i] == ex) str = 26;",
			"            else str = s[i]-'a';",
			"            if(node[now][str].first == -1){",
			"                node[now][str].first = make_node();",
			"            }",
			"            node[now][str].second++;",
			"            now = node[now][str].first;",
			"        }",
			"    }",
			"    ",
			"    int count(const string& s){",
			"        if(s.size() == 0) return 0;",
			"        int now = 0, str;",
			"        for(int i = 0; i < (int)s.size(); i++){",
			"            str = s[i]-'a';",
			"            if(s[i] == ex) str = 26;",
			"            if(node[now][str].first == -1){",
			"                return 0;",
			"            }",
			"            if(i != (int)s.size()-1) now = node[now][str].first;",
			"        }",
			"        int cnt = 0;",
			"        for(int i = 0; i < 27; i++) cnt += node[node[now][str].first][i].second;",
			"        return node[now][str].second - cnt;",
			"    }",
			"    ",
			"    int erase(const string& s, int num = INF){",
			"        num = min(num, count(s));",
			"        if(num == 0) return 0;",
			"        int now = 0, str;",
			"        vector<pair<int, int>> del_node;",
			"        for(int i = 0; i < (int)s.size(); i++){",
			"            str = s[i]-'a';",
			"            if(s[i] == ex) str = 26;",
			"            node[now][str].second -= num;",
			"            if(node[now][str].second == 0) del_node.emplace_back(now, str);",
			"            now = node[now][str].first;",
			"        }",
			"        for(auto [pos, str] : del_node){",
			"            reuse.emplace_back(node[pos][str].first);",
			"            node[pos][str].first = -1;",
			"        }",
			"        return num;",
			"    }",
			"};"
		]
	},
	
	"unionfind": {
		"prefix": "unionfind",
		"body": [
			"struct unionfind{",
			"    vector<int> par, rank;",
			"    int siz;",
			"    ",
			"    unionfind(int n):",
			"        par(n), rank(n, 1), siz(n){",
			"            iota(par.begin(), par.end(), 0);",
			"        }",
			"    unionfind(const vector<vector<int>>& v):",
			"    unionfind(v.size()){",
			"        for(int i = 0; i < siz; i++){",
			"            for(int j : v[i]) merge(i, j);",
			"        }",
			"    }",
			"    ",
			"    int root(int x){",
			"        if(par[x] == x) return x;",
			"        return par[x] = root(par[x]);",
			"    }",
			"    ",
			"    bool merge(int x, int y){",
			"        x = root(x);",
			"        y = root(y);",
			"        if(x == y) return false;",
			"        if(rank[x] < rank[y]) swap(x, y);",
			"        par[y] = x;",
			"        rank[x] += rank[y];",
			"        return true;",
			"    }",
			"    ",
			"    bool same(int x, int y){",
			"        return root(x) == root(y);",
			"    }",
			"    ",
			"    vector<vector<int>> groups(){",
			"        vector<vector<int>> res_memo(siz);",
			"        for(int i = 0; i < siz; i++){",
			"            res_memo[root(i)].emplace_back(i);",
			"        }",
			"        vector<vector<int>> res;",
			"        for(int i = 0; i < siz; i++){",
			"            if(!res_memo[i].empty()) res.emplace_back(res_memo[i]);",
			"        }",
			"        return res;",
			"    }",
			"};"
		]
	},
	
	"weighted_unionfind": {
		"prefix": "weighted_unionfind",
		"body": [
			"template<class S> struct weighted_unionfind {",
			"    vector<int> par, rank;",
			"    vector<S> weight;",
			"    ",
			"    weighted_unionfind(int n):",
			"        par(n), rank(n), weight(n) {",
			"            iota(par.begin(), par.end(), 0);",
			"        }",
			"    ",
			"    int root(int x){",
			"        if(par[x] == x) return x;",
			"        else {",
			"            int r = root(par[x]);",
			"            weight[x] += weight[par[x]];",
			"            return par[x] = r;",
			"        }",
			"    }",
			"    ",
			"    S get_weight(int x){",
			"        root(x);",
			"        return weight[x];",
			"    }",
			"    ",
			"    bool same(int x, int y){",
			"        return root(x) == root(y);",
			"    }",
			"    ",
			"    //x - y == w",
			"    bool merge(int x, int y, S w){",
			"        w += get_weight(y) - get_weight(x);",
			"        x = root(x); y = root(y);",
			"        if(x == y) return get_diff(x, y) == w;",
			"        if(rank[x] < rank[y]) swap(x, y), w = -w;",
			"        rank[x] += rank[y];",
			"        par[y] = x;",
			"        weight[y] = -w;",
			"        return true;",
			"    }",
			"    ",
			"    S get_diff(int x, int y){",
			"        return get_weight(x) - get_weight(y);",
			"    }",
			"};"
		]
	},
	
	"z_algorithm": {
		"prefix": "z_algorithm",
		"body": [
			"vector<int> z_algorithm(const string& s){",
			"    int n = s.size();",
			"    vector<int> res(n);",
			"    res[0] = n;",
			"    int l = 1, w = 0;",
			"    while(l < n){",
			"        while(l+w < n && s[l+w] == s[w]) w++;",
			"        res[l] = w;",
			"        w = max(w, 1);",
			"        int k = 1;",
			"        if(l+1 != n) while(k+res[k] < w){",
			"            res[l+k] = res[k];",
			"            k++;",
			"        }",
			"        l += k;",
			"        w -= k;",
			"    }",
			"    return res;",
			"}"
		]
	}
}
