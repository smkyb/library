{
	"0_cpptosnippet": {
		"prefix": "0_cpptosnippet",
		"body": [
			"#include <iostream>",
			"#include <filesystem>",
			"#include <fstream>",
			"#include <vector>",
			"#include <string>",
			"",
			"namespace fs = std::filesystem;",
			"",
			"std::string escapeJsonString(const std::string& input) {",
			"    std::string output;",
			"    for (char c : input) {",
			"        switch(c) {",
			"            case '\\\"': output += \"\\\\\\\"\"; break;",
			"            case '\\\\': output += \"\\\\\\\\\"; break;",
			"            default: output += c; break;",
			"        }",
			"    }",
			"    return output;",
			"}",
			"",
			"void generateSnippetJson(const std::string& directory, const std::string& outputFile) {",
			"    std::ofstream outFile(outputFile);",
			"    if (!outFile) {",
			"        std::cerr << \"Failed to open output file: \" << outputFile << std::endl;",
			"        return;",
			"    }",
			"    ",
			"    outFile << \"{\\n\";",
			"    ",
			"    bool firstEntry = true;",
			"    for (const auto& entry : fs::recursive_directory_iterator(directory)) {",
			"        if (entry.path().extension() == \".cpp\" || entry.path().extension() == \".hpp\") {",
			"            if (!firstEntry) {",
			"                outFile << \",\\n\\t\\n\";",
			"            }",
			"            firstEntry = false;",
			"            ",
			"            std::ifstream inFile(entry.path());",
			"            if (!inFile) continue;",
			"            ",
			"            std::cout << entry << std::endl;",
			"            ",
			"            std::vector<std::string> lines;",
			"            std::string line;",
			"            while (std::getline(inFile, line)) {",
			"                std::string escapedLine = escapeJsonString(line);",
			"                lines.push_back(\"\\\"\" + escapedLine + \"\\\"\");",
			"            }",
			"            ",
			"            std::string key = entry.path().stem().string();",
			"            outFile << \"\\t\\\"\" << escapeJsonString(key) << \"\\\": {\\n\";",
			"            outFile << \"\\t\\t\\\"prefix\\\": \\\"\" << escapeJsonString(key) << \"\\\",\\n\";",
			"            outFile << \"\\t\\t\\\"body\\\": [\\n\";",
			"            for (size_t i = 0; i < lines.size(); ++i) {",
			"                outFile << \"\\t\\t\\t\" << lines[i];",
			"                if (i != lines.size() - 1) {",
			"                    outFile << \",\";",
			"                }",
			"                outFile << \"\\n\";",
			"            }",
			"            outFile << \"\\t\\t]\\n\";",
			"            outFile << \"\\t}\";",
			"        }",
			"    }",
			"    ",
			"    outFile << \"\\n}\";",
			"    outFile.close();",
			"    std::cout << std::endl;",
			"    std::cout << \"cpp.json has been generated successfully.\" << std::endl;",
			"}",
			"",
			"int main(){",
			"    //.cppや.hppが入っているフォルダを指定する",
			"    std::string directory = \"C:\\\\vscode programs\\\\Libraries\";",
			"    //出力に使用するファイルを指定する（無い場合は新たに作られる？）",
			"    std::string outputfile = \"0_output.txt\";",
			"    ",
			"    generateSnippetJson(directory, outputfile);",
			"}"
		]
	},
	
	"4dydx": {
		"prefix": "4dydx",
		"body": [
			"for(int dk = 0; dk < 4; dk++){",
			"    int ny = y+dy[dk], nx = x+dx[dk];",
			"    $1",
			"}"
		]
	},
	
	"binary_trie": {
		"prefix": "binary_trie",
		"body": [
			"template <typename T>",
			"struct binary_trie{",
			"    private:",
			"    ",
			"    struct node_t{",
			"        T value;",
			"        int count = 0;",
			"        int child[2] = {-1, -1};",
			"        int width = 0;",
			"        node_t& operator=(const node_t& o){",
			"            value = o.value;",
			"            count = o.count;",
			"            child[0] = o.child[0];",
			"            child[1] = o.child[1];",
			"            width = o.width;",
			"            return *this;",
			"        }",
			"    };",
			"    ",
			"    using uT = typename make_unsigned<T>::type;",
			"    static constexpr T one = 1;",
			"    static constexpr int bit_width = sizeof(T) * 8;",
			"    vector<node_t> node;",
			"    T xor_val = 0;",
			"    int root = -1;",
			"    int siz = 0;",
			"    ",
			"    //[l, r)のマスクを返す",
			"    T mask(int l, int r) const {",
			"        if(r == bit_width) return ~((one<<l)-1);",
			"        return (((one<<r)-1) & ~((one<<l)-1));",
			"    }",
			"    ",
			"    //[l, r)bitを取り出す",
			"    T masked(T v, int l, int r) const {",
			"        return mask(l, r) & v;",
			"    }",
			"    ",
			"    //上位から数えて初めて異なるbitを返す。無ければ-1",
			"    int diff_bit(T x, T y) const {",
			"        return bit_width-1 - countl_zero(uT(x^y));",
			"    }",
			"    ",
			"    //ノードを返す",
			"    int make_node(T v){",
			"        node.emplace_back();",
			"        node.back().value = v;",
			"        return ssize(node)-1;",
			"    }",
			"    ",
			"    public:",
			"    ",
			"    binary_trie(){",
			"        root = make_node(0);",
			"        node[0].width = bit_width;",
			"        node[0].child[0] = -1;",
			"        node[0].child[1] = -1;",
			"    }",
			"    ",
			"    binary_trie<T>& operator=(binary_trie<T>&& o) noexcept {",
			"        node = move(o.node);",
			"        root = o.root;",
			"        siz = o.siz;",
			"    }",
			"    ",
			"    binary_trie(binary_trie&& o) noexcept {",
			"        *this = move(o);",
			"    }",
			"    ",
			"    void insert(T v){",
			"        int pos = root;",
			"        int bit = bit_width;",
			"        siz++;",
			"        v ^= xor_val;",
			"        while(node[pos].child[0] != -1){",
			"            T mv = masked(v, bit-node[pos].width, bit);",
			"            T mnv = masked(node[pos].value, bit-node[pos].width, bit);",
			"            if(mv != mnv){",
			"                int diff = diff_bit(mv, mnv);",
			"                bool b = (mv>>diff)&1;",
			"                int inter = make_node(node[pos].value);",
			"                int leaf = make_node(v);",
			"                node[inter] = node[pos];",
			"                node[inter].width = node[inter].width - (bit - diff - 1);",
			"                node[pos].child[b] = leaf;",
			"                node[pos].child[!b] = inter;",
			"                node[pos].count++;",
			"                node[pos].width = bit - diff - 1;",
			"                bit -= node[pos].width;",
			"                node[leaf].width = bit;",
			"                pos = leaf;",
			"            } else {",
			"                node[pos].count++;",
			"                bit -= node[pos].width;",
			"                pos = node[pos].child[(v>>(bit-1))&1];",
			"            }",
			"        }",
			"        ",
			"        if(node[pos].value == v){",
			"            node[pos].count++;",
			"            return;",
			"        }",
			"        ",
			"        int diff = diff_bit(v, node[pos].value);",
			"        bool b = (v>>diff)&1;",
			"        int leafv = make_node(v);",
			"        int leafn = make_node(node[pos].value);",
			"        node[pos].child[b] = leafv;",
			"        node[pos].child[!b] = leafn;",
			"        node[leafn].count = node[pos].count;",
			"        node[pos].count += 1;",
			"        node[leafv].width = node[leafn].width = node[pos].width - (bit - diff - 1);",
			"        node[pos].width = bit - diff - 1;",
			"        node[leafv].count = 1;",
			"    }",
			"    ",
			"    int count(T v) const {",
			"        int pos = root;",
			"        int bit = bit_width;",
			"        v ^= xor_val;",
			"        while(node[pos].child[0] != -1){",
			"            T mv = masked(v, bit-node[pos].width, bit);",
			"            T mnv = masked(node[pos].value, bit-node[pos].width, bit);",
			"            if(mv != mnv) return 0;",
			"            bit -= node[pos].width;",
			"            pos = node[pos].child[(v>>(bit-1))&1];",
			"        }",
			"        ",
			"        if(node[pos].value != v) return 0;",
			"        else return node[pos].count;",
			"    }",
			"    ",
			"    void erase(T v, int n = -1){",
			"        if(n == -1) n = count(v);",
			"        if(n == 0) return;",
			"        int pos = root;",
			"        int bit = bit_width;",
			"        siz -= n;",
			"        v ^= xor_val;",
			"        while(node[pos].child[0] != -1){",
			"            node[pos].count -= n;",
			"            bit -= node[pos].width;",
			"            pos = node[pos].child[(v>>(bit-1))&1];",
			"        }",
			"        node[pos].count -= n;",
			"    }",
			"    ",
			"    T xor_min(T v) {",
			"        assert(siz != 0);",
			"        apply_xor(v);",
			"        T res = get_smallest(0);",
			"        apply_xor(v);",
			"        return res^v;",
			"    }",
			"    ",
			"    T xor_max(T v) {",
			"        assert(siz != 0);",
			"        apply_xor(v);",
			"        T res = get_largest(0);",
			"        apply_xor(v);",
			"        return res^v;",
			"    }",
			"    ",
			"    T get_largest(int k) const {",
			"        assert(0 <= k && k < siz);",
			"        k++;",
			"        int pos = root;",
			"        int bit = bit_width-1;",
			"        while(node[pos].child[0] != -1){",
			"            bool b = (xor_val>>(bit-node[pos].width))&1;",
			"            bit -= node[pos].width;",
			"            if(k <= node[node[pos].child[!b]].count){",
			"                pos = node[pos].child[!b];",
			"            } else {",
			"                k -= node[node[pos].child[!b]].count;",
			"                pos = node[pos].child[b];",
			"            }",
			"        }",
			"        return node[pos].value^xor_val;",
			"    }",
			"    ",
			"    T get_smallest(int k) const {",
			"        return get_largest(siz - k - 1);",
			"    }",
			"    ",
			"    int size() const {",
			"        return siz;",
			"    }",
			"    ",
			"    //以下の要素の個数",
			"    int order(T v) const {",
			"        int res = 0;",
			"        int pos = root;",
			"        int bit = bit_width;",
			"        while(node[pos].child[0] != -1){",
			"            T mv = masked(v, bit-node[pos].width, bit);",
			"            T mnv = masked(node[pos].value^xor_val, bit-node[pos].width, bit);",
			"            if(mv < mnv){",
			"                return res;",
			"            } else if(mv > mnv){",
			"                return res + node[pos].count;",
			"            } else {",
			"                bit -= node[pos].width;",
			"                bool b = ((v>>(bit-1))&1);",
			"                if(b){",
			"                    res += node[node[pos].child[((xor_val)>>(bit-1))&1]].count;",
			"                }",
			"                pos = node[pos].child[b^((xor_val>>(bit-1))&1)];",
			"            }",
			"        }",
			"        if((node[pos].value^xor_val) <= v) res += node[pos].count;",
			"        return res;",
			"    }",
			"    ",
			"    T lower_bound(T v) const {",
			"        int ord = v ? order(v-1) : 0;",
			"        if(siz == ord) return -1;",
			"        else return get_smallest(ord);",
			"    }",
			"    ",
			"    T less_bound(T v) const {",
			"        int ord = order(v);",
			"        if(ord == 0) return -1;",
			"        else return get_smallest(ord-1);",
			"    }",
			"    ",
			"    void apply_xor(T x) {",
			"        xor_val ^= x;",
			"    }",
			"    ",
			"    void reserve(int n){",
			"        node.reserve(2*n+1);",
			"    }",
			"};"
		]
	},
	
	"calc_area": {
		"prefix": "calc_area",
		"body": [
			"using _CA_T = long long;",
			"auto calc_area = [](_CA_T a1, _CA_T a2, _CA_T b1, _CA_T b2, _CA_T c1, _CA_T c2, bool sign = 0){",
			"    a1 -= b1; a2 -= b2;",
			"    c1 -= b1; c2 -= b2;",
			"    _CA_T res = (a1*c2 - a2*c1);",
			"    if(!sign) res = abs(res);",
			"    return res;",
			"};"
		]
	},
	
	"calc_pl_dist": {
		"prefix": "calc_pl_dist",
		"body": [
			"using _CPLD_T = long double;",
			"auto calc_pl_dist = [](_CPLD_T p1, _CPLD_T p2, _CPLD_T e1, _CPLD_T e2, _CPLD_T e3, _CPLD_T e4){",
			"    p1 -= e1; p2 -= e2;",
			"    e3 -= e1; e4 -= e2;",
			"    _CPLD_T len = e3*e3 + e4*e4;",
			"    _CPLD_T t = (p1*e3 + p2*e4) / len;",
			"    t = max(0.0L, min(1.0L, t));",
			"    return hypot(e3*t-p1, e4*t-p2);",
			"};"
		]
	},
	
	"combination": {
		"prefix": "combination",
		"body": [
			"auto comb = [](long long N, long long K, int mod = 0)->long long {",
			"    constexpr int COMBSIZ = 200000;",
			"    assert(mod >= 0);",
			"    if(N < K || K < 0) return 0;",
			"    if(mod != 0){",
			"        assert(N <= COMBSIZ);",
			"        static vector<long long> combf(COMBSIZ+9, -1);",
			"        if(combf[0] == -1){",
			"            combf[0] = 1;",
			"            for(long long i = 1; i <= COMBSIZ; i++) combf[i] = (combf[i-1]*i)%mod;",
			"        }",
			"        return (combf[N]*power((combf[N-K]*combf[K])%mod, mod-2, mod))%mod;",
			"    } else {",
			"        long long a=1, b=1;",
			"        K = min(K, N-K);",
			"        for(long long i = N; i > N-K; i--) a *= i;",
			"        for(long long i = 2; i <= K; i++) b *= i;",
			"        return a/b;",
			"    }",
			"};"
		]
	},
	
	"compression": {
		"prefix": "compression",
		"body": [
			"void _compression_merge(...){}",
			"template<typename T, typename... Args>",
			"void _compression_merge(vector<T>& C, vector<T>& v, Args&... args){",
			"    for(auto& i : v) C.push_back(i);",
			"    _compression_merge(C, args...);",
			"}",
			"void _compression_apply(...){}",
			"template<typename T, typename... Args>",
			"void _compression_apply(vector<T>& C, vector<T>& v, Args&... args){",
			"    for(auto& i : v) i = lower_bound(C.begin(), C.end(), i) - C.begin();",
			"    _compression_apply(C, args...);",
			"}",
			"template<typename T, typename... Args>",
			"vector<T> compression(vector<T>& v, Args&... args){",
			"    vector<T> C;",
			"    _compression_merge(C, v, args...);",
			"    sort(C.begin(), C.end());",
			"    C.erase(unique(C.begin(), C.end()), C.end());",
			"    _compression_apply(C, v, args...);",
			"    return C;",
			"}"
		]
	},
	
	"convert": {
		"prefix": "convert",
		"body": [
			"auto convert = [](long long x, int n, int len = 1){",
			"    string res = \"\";",
			"    while(x){",
			"        int num = x%n;",
			"        if(num >= 10) res += 'A'+(num-10);",
			"        else res += '0'+(num);",
			"        x /= n;",
			"    }",
			"    while((int)res.size() < len) res += '0';",
			"    reverse(res.begin(), res.end());",
			"    return res;",
			"};"
		]
	},
	
	"coutans": {
		"prefix": "coutans",
		"body": [
			"cout << ans << el;"
		]
	},
	
	"csr": {
		"prefix": "csr",
		"body": [
			"void read_csr_ud_graph(vector<int>& g, vector<int>& start, int m, int num = -1){",
			"    assert(ssize(g) == 2*m);",
			"    int n = ssize(start)-1;",
			"    ",
			"    vector<array<int, 2>> E(m);",
			"    for(int i = 0; i < m; i++){",
			"        int u, v;",
			"        cin >> u >> v;",
			"        u += num; v += num;",
			"        start[u+1]++;",
			"        start[v+1]++;",
			"        E[i][0] = u;",
			"        E[i][1] = v;",
			"    }",
			"    for(int i = 1; i <= n; i++) start[i] += start[i-1];",
			"    auto C = start;",
			"    for(int i = 0; i < m; i++){",
			"        auto [u, v] = E[i];",
			"        g[C[u]++] = v;",
			"        g[C[v]++] = u;",
			"    }",
			"}",
			"void read_csr_d_graph(vector<int>& g, vector<int>& start, int m, int num = -1){",
			"    assert(ssize(g) == m);",
			"    int n = ssize(start)-1;",
			"    ",
			"    vector<array<int, 2>> E(m);",
			"    for(int i = 0; i < m; i++){",
			"        int u, v;",
			"        cin >> u >> v;",
			"        u += num; v += num;",
			"        start[u+1]++;",
			"        E[i][0] = u;",
			"        E[i][1] = v;",
			"    }",
			"    for(int i = 1; i <= n; i++) start[i] += start[i-1];",
			"    auto C = start;",
			"    for(int i = 0; i < m; i++){",
			"        auto [u, v] = E[i];",
			"        g[C[u]++] = v;",
			"    }",
			"}"
		]
	},
	
	"dfs2d": {
		"prefix": "dfs2d",
		"body": [
			"using _B2_T = vector<string>;",
			"auto bfs2d = [](const _B2_T& v, const vector<pair<int, int>>& spos, char wall){",
			"    int h = v.size(), w = v[0].size();",
			"    vector<int> dy = {0, 1, 0, -1}, dx = {1, 0, -1, 0};",
			"    vector<vector<int>> dist(h, vector<int>(w, INF));",
			"    queue<pair<int, int>> Q;",
			"    for(auto [sy, sx] : spos){",
			"        Q.emplace(sy, sx);",
			"        dist[sy][sx] = 0;",
			"    }",
			"    while(!Q.empty()){",
			"        int y = Q.front().first, x = Q.front().second;",
			"        Q.pop();",
			"        for(int dk = 0; dk < (int)dy.size(); dk++){",
			"            int ny = y+dy[dk], nx = x+dx[dk];",
			"            if(ny < 0 || ny >= h || nx < 0 || nx >= w || dist[ny][nx] != INF || v[ny][nx] == wall) continue;",
			"            dist[ny][nx] = dist[y][x]+1;",
			"            Q.emplace(ny, nx);",
			"        }",
			"    }",
			"    return dist;",
			"};"
		]
	},
	
	"dijkstra": {
		"prefix": "dijkstra",
		"body": [
			"auto dijkstra = [](const vector<vector<pair<long long, int>>>& v, const vector<int>& s){",
			"    int siz = v.size();",
			"    vector<long long> dist(siz, LLINF);",
			"    vector<int> path(siz, -1);",
			"    priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<pair<long long, int>>> pq;",
			"    for(int i : s){",
			"        dist[i] = 0;",
			"        pq.emplace(0, i);",
			"    }",
			"    while(!pq.empty()){",
			"        auto [d, pos] = pq.top();",
			"        pq.pop();",
			"        if(d > dist[pos]) continue;",
			"        for(auto [cost, nex] : v[pos]){",
			"            long long nex_cost = dist[pos] + cost;",
			"            if(dist[nex] > nex_cost){",
			"                dist[nex] = nex_cost;",
			"                pq.emplace(dist[nex], nex);",
			"                path[nex] = pos;",
			"            }",
			"        }",
			"    }",
			"    return make_pair(dist, path);",
			"}"
		]
	},
	
	"durtime": {
		"prefix": "durtime",
		"body": [
			"chrono::duration_cast<chrono::milliseconds>($1)"
		]
	},
	
	"dydx": {
		"prefix": "dydx",
		"body": [
			"dy[] = {0, 1, 0, -1}, dx[] = {1, 0, -1, 0}"
		]
	},
	
	"enum_comb": {
		"prefix": "enum_comb",
		"body": [
			"auto enum_comb = [](vector<vector<int>>& res, int n, int k) {",
			"    vector<int> now(k);",
			"    iota(now.begin(), now.end(), 0);",
			"    while(true){",
			"        res.emplace_back(now);",
			"        int ind = k-1;",
			"        while(ind >= 0 && now[ind] == ind+n-k) --ind;",
			"        if(ind == -1) break;",
			"        ++now[ind];",
			"        for(int i = ind+1; i < k; ++i) now[i] = now[i-1] + 1;",
			"    }",
			"    return res;",
			"};"
		]
	},
	
	"enum_prime": {
		"prefix": "enum_prime",
		"body": [
			"auto enum_prime = [](int n){",
			"    if(n < 2) return vector<int>(0);",
			"    vector<int> prime = {2};",
			"    vector<bool> check((n+1)/2, 1);",
			"    if(n > 1000) prime.reserve((int)(n/(log(n)-1)));",
			"    int lim = sqrt(n);",
			"    if(lim%2 == 0) lim--;",
			"    for(long long i = 3; i <= lim; i+=2){",
			"        if(check[i/2] == 1){",
			"            prime.emplace_back(i);",
			"            for(long long j = i*i; j <= n; j+=2*i) check[j/2] = 0;",
			"        }",
			"    }",
			"    for(int i = lim+2; i <= n; i+=2){",
			"        if(check[i/2] == 1) prime.emplace_back(i);",
			"    }",
			"    return prime;",
			"};"
		]
	},
	
	"eular_tour": {
		"prefix": "eular_tour",
		"body": [
			"struct euler_tour{",
			"    int n, root;",
			"    vector<vector<int>> graph;",
			"    vector<int> val, in, out, par;",
			"    //↓1-index",
			"    vector<int> route;",
			"    ",
			"    //segtree<pair<int, int>, [](const auto& a, const auto& b){return a.first < b.first ? a : b;}, [](){return make_pair(INF, -1);}> tree;",
			"    ",
			"    euler_tour() = default;",
			"    euler_tour(const vector<vector<int>>& v, int r = 0):",
			"        n(v.size()), root(r), graph(v), in(n), out(n), par(n){",
			"            auto dfs = [&](auto self, int pos, int pre, int d)->void {",
			"                in[pos] = route.size();",
			"                par[pos] = pre;",
			"                route.push_back(pos+1);",
			"                val.push_back(d);",
			"                for(int nex : graph[pos]){",
			"                    if(nex == pre) continue;",
			"                    self(self, nex, pos, d+1);",
			"                }",
			"                out[pos] = route.size();",
			"                route.push_back(-(pos+1));",
			"                val.push_back(d-1);",
			"            };",
			"            route.reserve(n*2);",
			"            val.reserve(n*2);",
			"            dfs(dfs, r, -1, 0);",
			"            ",
			"            //vec<pair<int, int>> V(n*2);",
			"            //for(int i = 0; i < n*2; i++) V[i] = {val[i], route[i] >= 0 ? route[i]-1 : par[-route[i]-1]};",
			"            //tree.init(V);",
			"        }",
			"    ",
			"    ",
			"    //int lca(int a, int b){",
			"    //    return tree.prod(min(in[a], in[b]), max(in[a], in[b])).second;",
			"    //}",
			"};"
		]
	},
	
	"extgcd": {
		"prefix": "extgcd",
		"body": [
			"pair<long long, long long> extgcd(long long a, long long b) {",
			"    if (b == 0){",
			"        return {1, 0};",
			"    }",
			"    auto [y, x] = extgcd(b, a%b);",
			"    y -= a/b * x;",
			"    return {x, y};",
			"}"
		]
	},
	
	"factorize": {
		"prefix": "factorize",
		"body": [
			"using _FZ_T = int;",
			"auto factorize = [](_FZ_T n){",
			"    vector<pair<_FZ_T, int>> res;",
			"    for(unsigned long long i = 2; i*i <= static_cast<unsigned long long>(n) || i == static_cast<unsigned long long>(n);){",
			"        if(n%i != 0) ++i;",
			"        else if(res.empty() || res.back().first != static_cast<_FZ_T>(i)) res.emplace_back(static_cast<_FZ_T>(i), 1), n/=i;",
			"        else ++res.back().second, n/=i;",
			"    }",
			"    if(n >= 2) res.emplace_back(n, 1);",
			"    return res;",
			"};"
		]
	},
	
	"fastset": {
		"prefix": "fastset",
		"body": [
			"struct fastset{",
			"    using ull = unsigned long long;",
			"    static constexpr ull bit64 = 0b111111;",
			"    ull n = 1, siz;",
			"    vector<ull> node;",
			"    ",
			"    fastset(ull _n){",
			"        build(_n);",
			"    }",
			"    ",
			"    void build(ull _n){",
			"        while((n<<6) < _n) n <<= 6;",
			"        siz = (n+1)/63;",
			"        node.resize((n+1)/63 + (_n+63)/64);",
			"    }",
			"    ",
			"    void insert(ull x){",
			"        assert(x < (n<<6));",
			"        for(ull i = (x>>6)+siz;; i = ((i-1ull)>>6)){",
			"            x = (1ull<<(x & bit64));",
			"            if(node[i] & x) return;",
			"            node[i] |= x;",
			"            x = (i-1ull);",
			"            if(!i) return;",
			"        }",
			"    }",
			"    ",
			"    void erase(ull x){",
			"        assert(x < (n<<6));",
			"        for(ull i = (x>>6)+siz;; i = ((i-1ull)>>6)){",
			"            x = (1ull<<(x & bit64));",
			"            if(!(node[i] & x)) return;",
			"            node[i] &= (~x);",
			"            x = (i-1ull);",
			"            if((!i) || node[i]) return;",
			"        }",
			"    }",
			"    ",
			"    bool count(ull x){",
			"        assert(x < (n<<6));",
			"        return node[siz + (x>>6)] & (1ull<<(x & bit64));",
			"    }",
			"    ",
			"    ull lower_bound(ull x){",
			"        assert(x < (n<<6));",
			"        if(count(x)) return x;",
			"        ull mask;",
			"        for(ull i = (x>>6)+siz;; i = ((i-1ull)>>6)){",
			"            x = (1ull<<(x & bit64));",
			"            mask = ~((x<<1)-1);",
			"            if(node[i] & mask){",
			"                if(i >= siz) return (((i-siz)<<6) + __builtin_ctzll(node[i]&mask));",
			"                i = (i<<6) + __builtin_ctzll(node[i]&mask)+1ull;",
			"                while(true){",
			"                    if(i >= siz) return (((i-siz)<<6) + __builtin_ctzll(node[i]));",
			"                    else i = (i<<6) + __builtin_ctzll(node[i])+1ull;",
			"                }",
			"            }",
			"            x = (i-1ull);",
			"            if(!i) return -1ull;",
			"        }",
			"    }",
			"    ",
			"    ull less_bound(ull x){",
			"        assert(x < (n<<6));",
			"        if(count(x)) return x;",
			"        ull mask;",
			"        for(ull i = (x>>6)+siz;; i = ((i-1ull)>>6)){",
			"            x = (1ull<<(x & bit64));",
			"            mask = x-1;",
			"            if(node[i] & mask){",
			"                if(i >= siz) return (((i-siz)<<6) + 63 - __builtin_clzll(node[i]&mask));",
			"                i = (i<<6) + 64 - __builtin_clzll(node[i]&mask);",
			"                while(true){",
			"                    if(i >= siz) return (((i-siz)<<6) + 63 - __builtin_clzll(node[i]));",
			"                    else i = (i<<6) + 64 - __builtin_clzll(node[i]);",
			"                }",
			"            }",
			"            x = (i-1ull);",
			"            if(!i) return -1ull;",
			"        }",
			"    }",
			"};"
		]
	},
	
	"fastvector": {
		"prefix": "fastvector",
		"body": [
			"template<typename T>",
			"struct fast_vector{",
			"    static constexpr int n = 100000;",
			"    using value_type = T;",
			"    using size_type = size_t;",
			"    using reference = T&;",
			"    using const_reference = const T&;",
			"    using iterator = T*;",
			"    using const_iterator = const T*;",
			"    ",
			"    T arr[n];",
			"    int en;",
			"    ",
			"    fast_vector():",
			"        en{0} {}",
			"    ",
			"    void open() {en = n;}",
			"    ",
			"    void assign(int siz, const T& x){",
			"        fill(arr, arr+siz, x);",
			"        en = siz;",
			"    }",
			"    ",
			"    void push_back(const T& x){",
			"        arr[en++] = x;",
			"    }",
			"    ",
			"    void push_back(T&& x){",
			"        arr[en++] = move(x);",
			"    }",
			"    ",
			"    void pop_back(){",
			"        en--;",
			"    }",
			"    ",
			"    iterator insert(iterator it, const T& x){",
			"        for(auto i = arr+en; i > it; i--){",
			"            *i = move(*prev(i));",
			"        }",
			"        *it = x;",
			"        en++;",
			"        return it;",
			"    }",
			"    ",
			"    iterator erase(iterator it){",
			"        en--;",
			"        for(auto i = it; i < arr+en; i++){",
			"            *i = move(*next(i));",
			"        }",
			"        return it;",
			"    }",
			"    ",
			"    void swap(fast_vector& x){",
			"        std::swap(en, x.en);",
			"        std::swap(arr, x.arr);",
			"    }",
			"    ",
			"    void clear(){",
			"        en = 0;",
			"    }",
			"    ",
			"    T& operator[](int p) {return arr[p];}",
			"    ",
			"    const T& operator[](int p) const {return arr[p];}",
			"    ",
			"    T& at(int p) {return arr[p];}",
			"    ",
			"    const T& at(int p) const {return arr[p];}",
			"    ",
			"    T* data() {return arr;}",
			"    ",
			"    T& front() {return arr[0];}",
			"    ",
			"    const T& front() const {return arr[0];}",
			"    ",
			"    T& back() {return arr[en-1];}",
			"    ",
			"    const T& back() const {return arr[en-1];}",
			"    ",
			"    size_type size() const {return en;}",
			"    ",
			"    bool empty() const {return en == 0;}",
			"    ",
			"    void reserve() {}",
			"    ",
			"    void resize(int siz) {",
			"        if(en > siz){",
			"            fill(arr+en, arr+siz, T());",
			"        }",
			"        en = siz;",
			"    }",
			"    ",
			"    void resize(int siz, const T& x) {",
			"        if(en > siz){",
			"            fill(arr+en, arr+siz, x);",
			"        }",
			"        en = siz;",
			"    }",
			"    ",
			"    iterator begin() {return arr;}",
			"    ",
			"    iterator end() {return arr+en;}",
			"};",
			"#define fvec fast_vector"
		]
	},
	
	"fenwick_tree": {
		"prefix": "fenwick_tree",
		"body": [
			"template<typename T>",
			"struct fenwick_tree{",
			"    int n;",
			"    vector<T> node, val;",
			"    ",
			"    fenwick_tree() = default;",
			"    fenwick_tree(unsigned siz):",
			"        n(siz), node(n+1), val(n){}",
			"    fenwick_tree(const vector<T>& v):",
			"        n(v.size()), node(n+1), val(v){",
			"            for(int i = 0; i < n; i++) node[i+1] = v[i];",
			"            for(int i = 1; i < n; i++) if(i+(i&-i) <= n) node[i+(i&-i)] += node[i];",
			"        }",
			"    ",
			"    void add(int p, const T x){",
			"        assert(0 <= p && p < n);",
			"        val[p] += x;",
			"        p++;",
			"        for(; p <= n; p += p&(-p)){",
			"            node[p] += x;",
			"        }",
			"    }",
			"    ",
			"    T sum(int l, int r){",
			"        assert(0 <= l && l <= r && r <= n);",
			"        if(__builtin_popcount(l) + __builtin_popcount(r) > r-l){",
			"            T res = 0;",
			"            for(int i = l; i < r; i++) res += val[i];",
			"            return res;",
			"        } else return sum(r) - sum(l);",
			"    }",
			"    ",
			"    T sum(int r){",
			"        T res = 0;",
			"        for(; r > 0; r -= r&(-r)){",
			"            res += node[r];",
			"        }",
			"        return res;",
			"    }",
			"    ",
			"    T prod(int l, int r){",
			"        return sum(l, r);",
			"    }",
			"    ",
			"    T get(int p){",
			"        return val[p];",
			"    }",
			"    ",
			"    void set(int p, const T x){",
			"        add(p, x - sum(p, p+1));",
			"    }",
			"    ",
			"    int max_right(T x){",
			"        if(x < 0) return 0;",
			"        int res = 0, w = bit_floor((unsigned)n);",
			"        for(int len = w; len > 0; len>>=1){",
			"            if(len+res<= n && node[len+res] <= x){",
			"                x -= node[len+res];",
			"                res += len;",
			"            }",
			"        }",
			"        return res;",
			"    }",
			"};"
		]
	},
	
	"fiostream": {
		"prefix": "fiostream",
		"body": [
			"struct FIstream{",
			"    #ifndef LOCAL",
			"    #define fread fread_unlocked",
			"    #endif",
			"    ",
			"    static constexpr unsigned SIZ = 1 << 17;",
			"    char buf[SIZ], *p1 = buf, *p2 = buf;",
			"    ",
			"    inline char _getchar(){",
			"        if(p1 == p2){",
			"            p2 = (p1 = buf) + fread(buf, 1, SIZ, stdin);",
			"            if(p1 == p2) return EOF;",
			"        }",
			"        return *p1++;",
			"    }",
			"    ",
			"    inline char ignore_space(){",
			"        char c;",
			"        while((c = _getchar()) <= 0x20);",
			"        return c;",
			"    }",
			"    ",
			"    template<typename T>",
			"    inline void _read(T& res){",
			"        T x = 0, f = 1;",
			"        char c = ignore_space();",
			"        if(c == '-'){",
			"            f = -1;",
			"            c = _getchar();",
			"        }",
			"        while('0' <= c && c <= '9'){",
			"            x = x*10 + (c-'0');",
			"            c = _getchar();",
			"        }",
			"        res = x*f;",
			"    }",
			"    ",
			"    template<typename T>",
			"    inline FIstream& operator>>(T& x){_read(x); return *this;}",
			"    inline FIstream& operator>>(char& x){x = ignore_space(); return *this;}",
			"    #ifdef _GLIBCXX_STRING",
			"    inline FIstream& operator>>(std::string& x){",
			"        std::string().swap(x);",
			"        char c = ignore_space();",
			"        while(c > 0x20){",
			"            x.push_back(c);",
			"            c = _getchar();",
			"        }",
			"        return *this;",
			"    }",
			"    #endif",
			"    #ifndef LOCAL",
			"    #undef fread",
			"    #endif",
			"} _cin;",
			"#define cin _cin",
			"#define istream FIstream",
			"",
			"struct FOstream_Pre{",
			"    char num[10000][4];",
			"    constexpr FOstream_Pre():num(){",
			"        for(int i = 0; i < 10000; i++){",
			"            int x = i;",
			"            for(int j = 3; j >= 0; j--){",
			"                num[i][j] = x%10 + '0';",
			"                x /= 10;",
			"            }",
			"        }",
			"    }",
			"} constexpr _FOstream_pre;",
			"",
			"struct FOstream{",
			"    #ifndef LOCAL",
			"    #define fwrite fwrite_unlocked",
			"    #endif",
			"    ",
			"    static constexpr unsigned SIZ = 1 << 17;",
			"    char buf[SIZ], *p1 = buf, *p2 = buf+SIZ;",
			"    ",
			"    inline void _write(){",
			"        fwrite(buf, 1, p1-buf, stdout);",
			"        p1 = buf;",
			"    }",
			"    ",
			"    inline void _putchar(char c){",
			"        if(p1 == p2){",
			"            fwrite(buf, 1, p1 - buf, stdout);",
			"            p1 = buf;",
			"        }",
			"        *p1++ = c;",
			"    }",
			"    ",
			"    template<typename T>",
			"    void _write_i(T x){",
			"        char num[100], *idxp = num+100;",
			"        if(x < 0){",
			"            _putchar('-');",
			"            x = -x;",
			"        }",
			"        if(p1 - buf < 100) _write();",
			"        while(x >= 10000){",
			"            idxp -= 4;",
			"            memcpy(idxp, _FOstream_pre.num[x%10000], 4);",
			"            x /= 10000;",
			"        }",
			"        if(x >= 1000){",
			"            memcpy(p1, _FOstream_pre.num[x], 4);",
			"            p1 += 4;",
			"        } else if(x >= 100){",
			"            memcpy(p1, _FOstream_pre.num[x]+1, 3);",
			"            p1 += 3;",
			"        } else if(x >= 10){",
			"            memcpy(p1, _FOstream_pre.num[x]+2, 2);",
			"            p1 += 2;",
			"        } else *p1++ = x+'0';",
			"        memcpy(p1, idxp, num+100 - idxp);",
			"        p1 += num+100 - idxp;",
			"    }",
			"    ",
			"    template<typename T>",
			"    FOstream& operator<<(T x){",
			"        if constexpr(is_same_v<T, char>){",
			"            _putchar(x);",
			"        } else if constexpr(is_same_v<decay_t<T>, const char*> || is_same_v<decay_t<T>, char*>){",
			"            while(*x) _putchar(*x++);",
			"        } else if constexpr(is_integral_v<T> || is_same_v<T, __int128>){",
			"            _write_i(x);",
			"        } else if constexpr(is_same_v<T, float> || is_same_v<T, double>){",
			"            char _b[100];",
			"            snprintf(_b, sizeof(_b), \"%.*f\", 15, x);",
			"            *this << _b;",
			"        } else if constexpr(is_same_v<T, long double>){",
			"            char _b[100];",
			"            snprintf(_b, sizeof(_b), \"%.*Lf\", 15, x);",
			"            *this << _b;",
			"        } else assert(0);",
			"        return *this;",
			"    }",
			"    #ifdef _GLIBCXX_STRING",
			"    FOstream& operator<<(const std::string& x){",
			"        for(char i : x) _putchar(i);",
			"        return *this;",
			"    }",
			"    #endif",
			"    ",
			"    ~FOstream(){",
			"        if(p1 != buf){",
			"            fwrite(buf, 1, p1 - buf, stdout);",
			"        }",
			"    }",
			"    ",
			"    #ifndef LOCAL",
			"    #undef fwrite",
			"    #endif",
			"} _cout;",
			"#define cout _cout",
			"#define ostream FOstream"
		]
	},
	
	"gettime": {
		"prefix": "gettime",
		"body": [
			"chrono::steady_clock::now()"
		]
	},
	
	"hld_treee": {
		"prefix": "hld_treee",
		"body": [
			"//非可換なら",
			"#define HLD_NON_COMMUTATIVE false",
			"//addが使えるなら",
			"#define HLD_HAS_OPERATION_ADD false",
			"//区間作用があるなら",
			"#define HLD_HAS_LAZY_APPLY false",
			"",
			"template<int MAXN, typename S, auto op, auto e>",
			"",
			"struct hld_tree{",
			"    using node_type = sparse_table<S, op, e>;",
			"    ",
			"    int n;",
			"    int dep[MAXN], in[MAXN], out[MAXN], head[MAXN], par[MAXN];",
			"    ",
			"    #if HLD_NON_COMMUTATIVE",
			"    node_type node[2];",
			"    #else",
			"    node_type node;",
			"    #endif",
			"    ",
			"    hld_tree(int _n, vector<pair<S, int>>& g, const vector<int>& start, int r = 0):",
			"        n(_n){",
			"            assert(0 <= r && r < n);",
			"            ",
			"            if(ssize(g) == (n-1)*2){",
			"                int sub_siz[MAXN], idx[MAXN+1];",
			"                fill(sub_siz, sub_siz+n, 1);",
			"                memcpy(idx, start.data(), sizeof(int)*start.size());",
			"                ",
			"                int cur = r;",
			"                par[r] = -1;",
			"                while(true){",
			"                    if(idx[cur] < start[cur+1]-(cur!=r)){",
			"                        int nex = g[idx[cur]++].second;",
			"                        if(nex == par[cur]){",
			"                            g[--idx[cur]] = g[start[cur+1]-1];",
			"                            continue;",
			"                        }",
			"                        par[nex] = cur;",
			"                        cur = nex;",
			"                    } else {",
			"                        if(cur == r) break;",
			"                        sub_siz[par[cur]] += sub_siz[cur];",
			"                        cur = par[cur];",
			"                    }",
			"                }",
			"                ",
			"                memcpy(idx, start.data(), sizeof(int)*start.size());",
			"                int state[MAXN]{}, heavy[MAXN];",
			"                ",
			"                int node_siz = 0;",
			"                cur = r;",
			"                head[cur] = r;",
			"                dep[cur] = 0;",
			"                while(1){",
			"                    if(state[cur] == 0){",
			"                        in[cur] = node_siz++;",
			"                        heavy[cur] = -1;",
			"                        for(int i = start[cur]; i < start[cur+1]-(cur!=r); i++){",
			"                            int nex = g[i].second;",
			"                            if(heavy[cur] == -1 || sub_siz[heavy[cur]] < sub_siz[nex]){",
			"                                heavy[cur] = nex;",
			"                            }",
			"                        }",
			"                        if(heavy[cur] != -1){",
			"                            int nex = heavy[cur];",
			"                            dep[nex] = dep[cur];",
			"                            head[nex] = head[cur];",
			"                            state[cur] = 2;",
			"                            cur = nex;",
			"                        } else state[cur] = 2;",
			"                    } else if(state[cur] == 2){",
			"                        if(idx[cur] < start[cur+1]-(cur!=r)){",
			"                            int nex = g[idx[cur]++].second;",
			"                            if(nex == heavy[cur]) continue;",
			"                            dep[nex] = dep[cur]+1;",
			"                            head[nex] = nex;",
			"                            cur = nex;",
			"                        } else state[cur] = 3;",
			"                    } else {",
			"                        out[cur] = node_siz;",
			"                        if(cur == r) break;",
			"                        cur = par[cur];",
			"                    }",
			"                }",
			"                ",
			"                vector<S> node_v(n);",
			"                for(int i = 0; i < n; i++){",
			"                    for(int j = start[i]; j < start[i+1]-(i!=r); j++){",
			"                        auto& [w, to] = g[j];",
			"                        node_v[in[to]] = w;",
			"                    }",
			"                }",
			"                ",
			"                #if HLD_NON_COMMUTATIVE",
			"                node[0] = node_type(node_v);",
			"                reverse(node_v.begin(), node_v.end());",
			"                node[1] = node_type(node_v);",
			"                #else",
			"                node = node_type(node_v);",
			"                #endif",
			"            } else if(ssize(g) == (n-1)){",
			"                int sub_siz[MAXN], idx[MAXN];",
			"                fill(sub_siz, sub_siz+n, 1);",
			"                memcpy(idx, start.data(), sizeof(int)*start.size());",
			"                ",
			"                int cur = r;",
			"                par[r] = -1;",
			"                while(true){",
			"                    if(idx[cur] < start[cur+1]){",
			"                        int nex = g[idx[cur]++].second;",
			"                        par[nex] = cur;",
			"                        cur = nex;",
			"                    } else {",
			"                        if(cur == r) break;",
			"                        sub_siz[par[cur]] += sub_siz[cur];",
			"                        cur = par[cur];",
			"                    }",
			"                }",
			"                ",
			"                memcpy(idx, start.data(), sizeof(int)*start.size());",
			"                int state[MAXN]{}, heavy[MAXN];",
			"                ",
			"                int node_siz = 0;",
			"                cur = r;",
			"                head[cur] = r;",
			"                dep[cur] = 0;",
			"                while(1){",
			"                    if(state[cur] == 0){",
			"                        in[cur] = node_siz++;",
			"                        heavy[cur] = -1;",
			"                        for(int i = start[cur]; i < start[cur+1]; i++){",
			"                            int nex = g[i].second;",
			"                            if(heavy[cur] == -1 || sub_siz[heavy[cur]] < sub_siz[nex]){",
			"                                heavy[cur] = nex;",
			"                            }",
			"                        }",
			"                        if(heavy[cur] != -1){",
			"                            int nex = heavy[cur];",
			"                            dep[nex] = dep[cur];",
			"                            head[nex] = head[cur];",
			"                            state[cur] = 2;",
			"                            cur = nex;",
			"                        } else state[cur] = 2;",
			"                    } else if(state[cur] == 2){",
			"                        if(idx[cur] < start[cur+1]){",
			"                            int nex = g[idx[cur]++].second;",
			"                            if(nex == heavy[cur]) continue;",
			"                            dep[nex] = dep[cur]+1;",
			"                            head[nex] = nex;",
			"                            cur = nex;",
			"                        } else state[cur] = 3;",
			"                    } else {",
			"                        out[cur] = node_siz;",
			"                        if(cur == r) break;",
			"                        cur = par[cur];",
			"                    }",
			"                }",
			"                ",
			"                vector<S> node_v(n);",
			"                for(int i = 0; i < n; i++){",
			"                    for(int j = start[i]; j < start[i+1]; j++){",
			"                        auto& [w, to] = g[j];",
			"                        node_v[in[to]] = w;",
			"                    }",
			"                }",
			"                ",
			"                #if HLD_NON_COMMUTATIVE",
			"                node[0] = node_type(node_v);",
			"                reverse(node_v.begin(), node_v.end());",
			"                node[1] = node_type(node_v);",
			"                #else",
			"                node = node_type(node_v);",
			"                #endif",
			"            } else assert(0);",
			"        }",
			"    ",
			"    #if HLD_NON_COMMUTATIVE",
			"    ",
			"    S prod(int l, int r){",
			"        assert(0 <= l && 0 <= r && l < n && r < n);",
			"        S l_ans = e();",
			"        S r_ans = e();",
			"        bool rev = false;",
			"        while(true){",
			"            if(dep[l] < dep[r]) swap(l, r), rev ^= 1;",
			"            if(dep[l] != dep[r] || head[l] != head[r]){",
			"                if(!rev) l_ans = op(l_ans, node[1].prod(n-in[l]-1, n-in[head[l]]));",
			"                else r_ans = op(node[0].prod(in[head[l]], in[l]+1), r_ans);",
			"                l = par[head[l]];",
			"            } else {",
			"                if(in[l] > in[r]) swap(l, r), rev ^= 1;",
			"                if(!rev) l_ans = op(l_ans, node[0].prod(in[l], in[r]+1));",
			"                else r_ans = op(node[1].prod(n-in[r]-1, n-in[l]), r_ans);",
			"                return op(l_ans, r_ans);",
			"            }",
			"        }",
			"    }",
			"    ",
			"    S prod(int r){",
			"        assert(0 <= r && r < n);",
			"        return node[0].prod(in[r], out[r]);",
			"    }",
			"    ",
			"    #else",
			"    ",
			"    S prod(int l, int r){",
			"        assert(0 <= l && 0 <= r && l < n && r < n);",
			"        S ans = e();",
			"        while(true){",
			"            if(dep[l] < dep[r]) swap(l, r);",
			"            if(dep[l] != dep[r] || head[l] != head[r]){",
			"                ans = op(ans, node.prod(in[head[l]], in[l]+1));",
			"                l = par[head[l]];",
			"            } else {",
			"                if(in[l] > in[r]) swap(l, r);",
			"                if(l != r) ans = op(ans, node.prod(in[l]+1, in[r]+1));",
			"                return ans;",
			"            }",
			"        }",
			"    }",
			"    ",
			"    S prod(int r){",
			"        assert(0 <= r && r < n);",
			"        return node.prod(in[r], out[r]);",
			"    }",
			"    ",
			"    #endif",
			"    ",
			"    int lca(int l, int r){",
			"        assert(0 <= l && 0 <= r && l < n && r < n);",
			"        while(true){",
			"            if(dep[l] < dep[r]) swap(l, r);",
			"            if(dep[l] != dep[r] || head[l] != head[r]){",
			"                l = par[head[l]];",
			"            } else {",
			"                if(in[l] > in[r]) swap(l, r);",
			"                return l;",
			"            }",
			"        }",
			"    }",
			"    ",
			"    int dist(int l, int r){",
			"        assert(0 <= l && 0 <= r && l < n && r < n);",
			"        int d = 0;",
			"        while(true){",
			"            if(dep[l] < dep[r]) swap(l, r);",
			"            if(dep[l] != dep[r] || head[l] != head[r]){",
			"                d += in[l] - in[head[l]] + 1;",
			"                l = par[head[l]];",
			"            } else {",
			"                if(in[l] > in[r]) swap(l, r);",
			"                d += in[r] - in[l];",
			"                return d;",
			"            }",
			"        }",
			"    }",
			"    ",
			"    #if HLD_HAS_LAZY_APPLY",
			"    ",
			"    #if HLD_NON_COMMUTATIVE",
			"    ",
			"    void apply(int l, int r, const F& x){",
			"        while(true){",
			"            if(dep[l] < dep[r]) swap(l, r);",
			"            if(dep[l] != dep[r] || head[l] != head[r]){",
			"                node[0].apply(in[head[l]], in[l]+1, x);",
			"                node[1].apply(n-in[l]-1, n-in[head[l]], x);",
			"                l = par[head[l]];",
			"            } else {",
			"                if(in[l] > in[r]) swap(l, r);",
			"                if(l != r) node[0].apply(in[l]+1, in[r]+1, x);",
			"                if(l != r) node[1].apply(n-in[r]-1, n-in[l]-1, x);",
			"                break;",
			"            }",
			"        }",
			"    }",
			"    ",
			"    void apply(int r, const F& x){",
			"        node[0].apply(in[r]+1, out[r], x);",
			"        node[1].apply(n-out[r], n-in[r]-1, x);",
			"    }",
			"    ",
			"    #else",
			"    ",
			"    void apply(int l, int r, const F& x){",
			"        while(true){",
			"            if(dep[l] < dep[r]) swap(l, r);",
			"            if(dep[l] != dep[r] || head[l] != head[r]){",
			"                node.apply(in[head[l]], in[l]+1, x);",
			"                l = par[head[l]];",
			"            } else {",
			"                if(in[l] > in[r]) swap(l, r);",
			"                if(l != r) node.apply(in[l]+1, in[r]+1, x);",
			"                break;",
			"            }",
			"        }",
			"    }",
			"    ",
			"    void apply(int r, const F& x){",
			"        node.apply(in[r]+1, out[r], x);",
			"    }",
			"    ",
			"    #endif",
			"    #endif",
			"};"
		]
	},
	
	"hld_treen": {
		"prefix": "hld_treen",
		"body": [
			"template<int MAXN>",
			"",
			"struct hld_tree{",
			"    int n;",
			"    int dep[MAXN], in[MAXN], head[MAXN], par[MAXN];",
			"    int node[MAXN];",
			"    ",
			"    hld_tree(int _n, vector<int>& g, const vector<int>& start, int r = 0):",
			"        n(_n){",
			"            assert(0 <= r && r < n);",
			"            ",
			"            if(ssize(g) == (n-1)*2){",
			"                int sub_siz[MAXN], idx[MAXN+1];",
			"                fill(sub_siz, sub_siz+n, 1);",
			"                memcpy(idx, start.data(), sizeof(int)*start.size());",
			"                ",
			"                int cur = r;",
			"                par[r] = -1;",
			"                while(true){",
			"                    if(idx[cur] < start[cur+1]-(cur!=r)){",
			"                        int nex = g[idx[cur]++];",
			"                        if(nex == par[cur]){",
			"                            g[--idx[cur]] = g[start[cur+1]-1];",
			"                            continue;",
			"                        }",
			"                        par[nex] = cur;",
			"                        cur = nex;",
			"                    } else {",
			"                        if(cur == r) break;",
			"                        sub_siz[par[cur]] += sub_siz[cur];",
			"                        cur = par[cur];",
			"                    }",
			"                }",
			"                ",
			"                memcpy(idx, start.data(), sizeof(int)*start.size());",
			"                int state[MAXN]{}, heavy[MAXN];",
			"                ",
			"                int node_siz = 0;",
			"                cur = r;",
			"                head[cur] = r;",
			"                dep[cur] = 0;",
			"                while(1){",
			"                    if(state[cur] == 0){",
			"                        in[cur] = node_siz++;",
			"                        heavy[cur] = -1;",
			"                        for(int i = start[cur]; i < start[cur+1]-(cur!=r); i++){",
			"                            int nex = g[i];",
			"                            if(heavy[cur] == -1 || sub_siz[heavy[cur]] < sub_siz[nex]){",
			"                                heavy[cur] = nex;",
			"                            }",
			"                        }",
			"                        if(heavy[cur] != -1){",
			"                            int nex = heavy[cur];",
			"                            dep[nex] = dep[cur];",
			"                            head[nex] = head[cur];",
			"                            state[cur] = 2;",
			"                            cur = nex;",
			"                        } else state[cur] = 2;",
			"                    } else if(state[cur] == 2){",
			"                        if(idx[cur] < start[cur+1]-(cur!=r)){",
			"                            int nex = g[idx[cur]++];",
			"                            if(nex == heavy[cur]) continue;",
			"                            dep[nex] = dep[cur]+1;",
			"                            head[nex] = nex;",
			"                            cur = nex;",
			"                        } else state[cur] = 3;",
			"                    } else {",
			"                        if(cur == r) break;",
			"                        cur = par[cur];",
			"                    }",
			"                }",
			"            } else if(ssize(g) == (n-1)){",
			"                int sub_siz[MAXN], idx[MAXN];",
			"                fill(sub_siz, sub_siz+n, 1);",
			"                memcpy(idx, start.data(), sizeof(int)*start.size());",
			"                ",
			"                int cur = r;",
			"                par[r] = -1;",
			"                while(true){",
			"                    if(idx[cur] < start[cur+1]){",
			"                        int nex = g[idx[cur]++];",
			"                        par[nex] = cur;",
			"                        cur = nex;",
			"                    } else {",
			"                        if(cur == r) break;",
			"                        sub_siz[par[cur]] += sub_siz[cur];",
			"                        cur = par[cur];",
			"                    }",
			"                }",
			"                ",
			"                memcpy(idx, start.data(), sizeof(int)*start.size());",
			"                int state[MAXN]{}, heavy[MAXN];",
			"                ",
			"                int node_siz = 0;",
			"                cur = r;",
			"                head[cur] = r;",
			"                dep[cur] = 0;",
			"                while(1){",
			"                    if(state[cur] == 0){",
			"                        in[cur] = node_siz++;",
			"                        heavy[cur] = -1;",
			"                        for(int i = start[cur]; i < start[cur+1]; i++){",
			"                            int nex = g[i];",
			"                            if(heavy[cur] == -1 || sub_siz[heavy[cur]] < sub_siz[nex]){",
			"                                heavy[cur] = nex;",
			"                            }",
			"                        }",
			"                        if(heavy[cur] != -1){",
			"                            int nex = heavy[cur];",
			"                            dep[nex] = dep[cur];",
			"                            head[nex] = head[cur];",
			"                            state[cur] = 2;",
			"                            cur = nex;",
			"                        } else state[cur] = 2;",
			"                    } else if(state[cur] == 2){",
			"                        if(idx[cur] < start[cur+1]){",
			"                            int nex = g[idx[cur]++];",
			"                            if(nex == heavy[cur]) continue;",
			"                            dep[nex] = dep[cur]+1;",
			"                            head[nex] = nex;",
			"                            cur = nex;",
			"                        } else state[cur] = 3;",
			"                    } else {",
			"                        if(cur == r) break;",
			"                        cur = par[cur];",
			"                    }",
			"                }",
			"            } else assert(0);",
			"            for(int i = 0; i < n; i++) node[in[i]] = i;",
			"        }",
			"    ",
			"        int prod(int l, int r, int k){",
			"            int lc = lca(l, r);",
			"            int dl = dist(l, lc), dr = dist(lc, r);",
			"            if(dl+dr < k) return -1;",
			"            if(dl >= k){",
			"                while(true){",
			"                    k -= in[l] - in[head[l]];",
			"                    if(k <= 0) return node[in[head[l]]-k];",
			"                    k--; l = par[head[l]];",
			"                }",
			"            } else {",
			"                k -= dl;",
			"                k = dr - k;",
			"                while(true){",
			"                    k -= in[r] - in[head[r]];",
			"                    if(k <= 0) return node[in[head[r]]-k];",
			"                    k--; r = par[head[r]];",
			"                }",
			"            }",
			"        }",
			"    ",
			"    int lca(int l, int r){",
			"        assert(0 <= l && 0 <= r && l < n && r < n);",
			"        while(true){",
			"            if(dep[l] < dep[r]) swap(l, r);",
			"            if(dep[l] != dep[r] || head[l] != head[r]){",
			"                l = par[head[l]];",
			"            } else {",
			"                if(in[l] > in[r]) swap(l, r);",
			"                return l;",
			"            }",
			"        }",
			"    }",
			"    ",
			"    int dist(int l, int r){",
			"        assert(0 <= l && 0 <= r && l < n && r < n);",
			"        int d = 0;",
			"        while(true){",
			"            if(dep[l] < dep[r]) swap(l, r);",
			"            if(dep[l] != dep[r] || head[l] != head[r]){",
			"                d += in[l] - in[head[l]] + 1;",
			"                l = par[head[l]];",
			"            } else {",
			"                if(in[l] > in[r]) swap(l, r);",
			"                d += in[r] - in[l];",
			"                return d;",
			"            }",
			"        }",
			"    }",
			"};"
		]
	},
	
	"hld_treev": {
		"prefix": "hld_treev",
		"body": [
			"//非可換なら",
			"#define HLD_NON_COMMUTATIVE true",
			"//addが使えるなら",
			"#define HLD_HAS_OPERATION_ADD false",
			"//区間作用があるなら",
			"#define HLD_HAS_LAZY_APPLY false",
			"",
			"template<int MAXN, typename S, auto op, auto e>",
			"//template<int MAXN, typename S, auto op, auto e, typename F, auto mapping, auto composition, auto id>",
			"",
			"struct hld_tree{",
			"    using node_type = segtree<S, op, e>;",
			"    //using node_type = segtree<S, op, e, F, mapping, composition, id>",
			"    ",
			"    int n, r, edge_idx;",
			"    int dep[MAXN], in[MAXN], out[MAXN], head[MAXN], par[MAXN];",
			"    array<int, 2> E[MAXN-1];",
			"    ",
			"    #if HLD_NON_COMMUTATIVE",
			"    node_type node[2];",
			"    #else",
			"    node_type node;",
			"    #endif",
			"    ",
			"    hld_tree(int _n, int _r = -1):",
			"        n(_n), r(_r), edge_idx(0){",
			"            if(r == -1) r = random_device()()%n;",
			"        }",
			"    ",
			"    void add_edge(int u, int v){",
			"        E[edge_idx][0] = u;",
			"        E[edge_idx][1] = v;",
			"        edge_idx++;",
			"    }",
			"    ",
			"    void build(const vector<S>& v){",
			"        int g[(MAXN-1)*2], start[MAXN+1], C[MAXN+1];",
			"        for(int i = 0; i < n-1; i++){",
			"            auto [u, v] = E[i];",
			"            start[u+1]++;",
			"            start[v+1]++;",
			"        }",
			"        for(int i = 1; i <= n; i++) start[i] += start[i-1];",
			"        memcpy(C, start, sizeof(int)*(n+1));",
			"        for(int i = 0; i < n-1; i++){",
			"            auto [u, v] = E[i];",
			"            g[C[u]++] = v;",
			"            g[C[v]++] = u;",
			"        }",
			"        ",
			"        int sub_siz[MAXN], idx[MAXN+1];",
			"        fill(sub_siz, sub_siz+n, 1);",
			"        memcpy(idx, start, sizeof(int)*(n+1));",
			"        ",
			"        int cur = r;",
			"        par[r] = -1;",
			"        while(true){",
			"            if(idx[cur] < start[cur+1]-(cur!=r)){",
			"                int nex = g[idx[cur]++];",
			"                if(nex == par[cur]){",
			"                    g[--idx[cur]] = g[start[cur+1]-1];",
			"                    continue;",
			"                }",
			"                par[nex] = cur;",
			"                cur = nex;",
			"            } else {",
			"                if(cur == r) break;",
			"                sub_siz[par[cur]] += sub_siz[cur];",
			"                cur = par[cur];",
			"            }",
			"        }",
			"        ",
			"        memcpy(idx, start, sizeof(int)*(n+1));",
			"        int state[MAXN]{}, heavy[MAXN];",
			"        ",
			"        int node_siz = 0;",
			"        cur = r;",
			"        head[cur] = r;",
			"        dep[cur] = 0;",
			"        while(1){",
			"            if(state[cur] == 0){",
			"                in[cur] = node_siz++;",
			"                heavy[cur] = -1;",
			"                for(int i = start[cur]; i < start[cur+1]-(cur!=r); i++){",
			"                    int nex = g[i];",
			"                    if(heavy[cur] == -1 || sub_siz[heavy[cur]] < sub_siz[nex]){",
			"                        heavy[cur] = nex;",
			"                    }",
			"                }",
			"                if(heavy[cur] != -1){",
			"                    int nex = heavy[cur];",
			"                    dep[nex] = dep[cur];",
			"                    head[nex] = head[cur];",
			"                    state[cur] = 2;",
			"                    cur = nex;",
			"                } else state[cur] = 2;",
			"            } else if(state[cur] == 2){",
			"                if(idx[cur] < start[cur+1]-(cur!=r)){",
			"                    int nex = g[idx[cur]++];",
			"                    if(nex == heavy[cur]) continue;",
			"                    dep[nex] = dep[cur]+1;",
			"                    head[nex] = nex;",
			"                    cur = nex;",
			"                } else state[cur] = 3;",
			"            } else {",
			"                out[cur] = node_siz;",
			"                if(cur == r) break;",
			"                cur = par[cur];",
			"            }",
			"        }",
			"        ",
			"        vector<S> node_v(n);",
			"        for(int i = 0; i < n; i++) node_v[in[i]] = v[i];",
			"        ",
			"        #if HLD_NON_COMMUTATIVE",
			"        node[0] = node_type(node_v);",
			"        reverse(node_v.begin(), node_v.end());",
			"        node[1] = node_type(node_v);",
			"        #else",
			"        node = node_type(node_v);",
			"        #endif",
			"    }",
			"    ",
			"    #if HLD_HAS_OPERATION_ADD",
			"    ",
			"    #if HLD_NON_COMMUTATIVE",
			"    ",
			"    void add(int p, const S& x){",
			"        assert(0 <= p && p < n);",
			"        node[0].add(in[p], x);",
			"        node[1].add(n-in[p]-1, x);",
			"    }",
			"    ",
			"    #else",
			"    ",
			"    void add(int p, const S& x){",
			"        assert(0 <= p && p < n);",
			"        node.add(in[p], x);",
			"    }",
			"    ",
			"    #endif",
			"    #endif",
			"    ",
			"    #if HLD_NON_COMMUTATIVE",
			"    ",
			"    S prod(int l, int r){",
			"        assert(0 <= l && 0 <= r && l < n && r < n);",
			"        S l_ans = e();",
			"        S r_ans = e();",
			"        bool rev = false;",
			"        while(true){",
			"            if(dep[l] < dep[r]) swap(l, r), rev ^= 1;",
			"            if(dep[l] != dep[r] || head[l] != head[r]){",
			"                if(!rev) l_ans = op(l_ans, node[1].prod(n-in[l]-1, n-in[head[l]]));",
			"                else r_ans = op(node[0].prod(in[head[l]], in[l]+1), r_ans);",
			"                l = par[head[l]];",
			"            } else {",
			"                if(in[l] > in[r]) swap(l, r), rev ^= 1;",
			"                if(!rev) l_ans = op(l_ans, node[0].prod(in[l], in[r]+1));",
			"                else r_ans = op(node[1].prod(n-in[r]-1, n-in[l]), r_ans);",
			"                return op(l_ans, r_ans);",
			"            }",
			"        }",
			"    }",
			"    ",
			"    S prod(int r){",
			"        assert(0 <= r && r < n);",
			"        return node[0].prod(in[r], out[r]);",
			"    }",
			"    ",
			"    S get(int p){",
			"        assert(0 <= p && p < n);",
			"        return node[0].get(in[p]);",
			"    }",
			"    ",
			"    void set(int p, const S& x){",
			"        assert(0 <= p && p < n);",
			"        node[0].set(in[p], x);",
			"        node[1].set(n-in[p]-1, x);",
			"    }",
			"    ",
			"    #else",
			"    ",
			"    S prod(int l, int r){",
			"        assert(0 <= l && 0 <= r && l < n && r < n);",
			"        S ans = e();",
			"        while(true){",
			"            if(dep[l] < dep[r]) swap(l, r);",
			"            if(dep[l] != dep[r] || head[l] != head[r]){",
			"                ans = op(ans, node.prod(in[head[l]], in[l]+1));",
			"                l = par[head[l]];",
			"            } else {",
			"                if(in[l] > in[r]) swap(l, r);",
			"                ans = op(ans, node.prod(in[l], in[r]+1));",
			"                return ans;",
			"            }",
			"        }",
			"    }",
			"    ",
			"    S prod(int r){",
			"        assert(0 <= r && r < n);",
			"        return node.prod(in[r], out[r]);",
			"    }",
			"    ",
			"    S get(int p){",
			"        assert(0 <= p && p < n);",
			"        return node.get(in[p]);",
			"    }",
			"    ",
			"    void set(int p, const S& x){",
			"        assert(0 <= p && p < n);",
			"        node.set(in[p], x);",
			"    }",
			"    ",
			"    #endif",
			"    ",
			"    int lca(int l, int r){",
			"        assert(0 <= l && 0 <= r && l < n && r < n);",
			"        while(true){",
			"            if(dep[l] < dep[r]) swap(l, r);",
			"            if(dep[l] != dep[r] || head[l] != head[r]){",
			"                l = par[head[l]];",
			"            } else {",
			"                if(in[l] > in[r]) swap(l, r);",
			"                return l;",
			"            }",
			"        }",
			"    }",
			"    ",
			"    int dist(int l, int r){",
			"        assert(0 <= l && 0 <= r && l < n && r < n);",
			"        int d = 0;",
			"        while(true){",
			"            if(dep[l] < dep[r]) swap(l, r);",
			"            if(dep[l] != dep[r] || head[l] != head[r]){",
			"                d += in[l] - in[head[l]] + 1;",
			"                l = par[head[l]];",
			"            } else {",
			"                if(in[l] > in[r]) swap(l, r);",
			"                d += in[r] - in[l];",
			"                return d;",
			"            }",
			"        }",
			"    }",
			"    ",
			"    #if HLD_HAS_LAZY_APPLY",
			"    ",
			"    #if HLD_NON_COMMUTATIVE",
			"    ",
			"    void apply(int l, int r, const F& x){",
			"        while(true){",
			"            if(dep[l] < dep[r]) swap(l, r);",
			"            if(dep[l] != dep[r] || head[l] != head[r]){",
			"                node[0].apply(in[head[l]], in[l]+1, x);",
			"                node[1].apply(n-in[l]-1, n-in[head[l]], x);",
			"                l = par[head[l]];",
			"            } else {",
			"                if(in[l] > in[r]) swap(l, r);",
			"                node[0].apply(in[l], in[r]+1, x);",
			"                node[1].apply(n-in[r]-1, n-in[l], x);",
			"                break;",
			"            }",
			"        }",
			"    }",
			"    ",
			"    void apply(int r, const F& x){",
			"        node[0].apply(in[r], out[r], x);",
			"        node[1].apply(n-out[r], n-in[r], x);",
			"    }",
			"    ",
			"    #else",
			"    ",
			"    void apply(int l, int r, const F& x){",
			"        while(true){",
			"            if(dep[l] < dep[r]) swap(l, r);",
			"            if(dep[l] != dep[r] || head[l] != head[r]){",
			"                node.apply(in[head[l]], in[l]+1, x);",
			"                l = par[head[l]];",
			"            } else {",
			"                if(in[l] > in[r]) swap(l, r);",
			"                node.apply(in[l], in[r]+1, x);",
			"                break;",
			"            }",
			"        }",
			"    }",
			"    ",
			"    void apply(int r, const F& x){",
			"        node.apply(in[r], out[r], x);",
			"    }",
			"    ",
			"    #endif",
			"    #endif",
			"};"
		]
	},
	
	"inversion": {
		"prefix": "inversion",
		"body": [
			"auto inversion = [](const vector<int>& v){",
			"    fenwick_tree<int> tree(v.size());",
			"    long long res = 0;",
			"    for(int i = 0; i < ssize(v); i++){",
			"        res += tree.sum(v[i]+1, ssize(v));",
			"        tree.add(v[i], 1);",
			"    }",
			"    return res;",
			"};"
		]
	},
	
	"iossync": {
		"prefix": "iossync",
		"body": [
			"ios::sync_with_stdio(0); cin.tie(0);"
		]
	},
	
	"janken": {
		"prefix": "janken",
		"body": [
			"auto janken = [](char R, char C, char P, char a, char b){",
			"    if(a == b) return 0;",
			"    if(a == R && b == C) return 1;",
			"    if(a == C && b == P) return 1;",
			"    if(a == P && b == R) return 1;",
			"    else return -1;",
			"};"
		]
	},
	
	"large_lcm": {
		"prefix": "large_lcm",
		"body": [
			"auto large_lcm = [](const vector<int>& v){",
			"    unordered_map<int, int> lc;",
			"    for(int i : v){",
			"        vector<pair<int, int>> f = factorize(i);",
			"        for(auto [e, n] : f){",
			"            lc[e] = max(lc[e], n);",
			"        }",
			"    }",
			"    vector<pair<int, int>> res;",
			"    for(auto [e, n] : lc){",
			"        res.emplace_back(e, n);",
			"    }",
			"    return res;",
			"};"
		]
	},
	
	"lazy_cheat": {
		"prefix": "lazy_cheat",
		"body": [
			"struct S{",
			"    long long value;",
			"    int size;",
			"};",
			"using F = long long;",
			"",
			"S op(S a, S b){ return {a.value+b.value, a.size+b.size}; }",
			"S e(){ return {0, 0}; }",
			"S mapping(F f, S x){ return {x.value + f*x.size, x.size}; }",
			"F composition(F f, F g){ return f+g; }",
			"F id(){ return 0; }"
		]
	},
	
	"lis": {
		"prefix": "lis",
		"body": [
			"using _LIS_T = int;",
			"auto lis = [](const vector<_LIS_T>& v){",
			"    //デフォルトで狭義単調増加",
			"    constexpr auto _LIS_T_bound = lower_bound<typename vector<_LIS_T>::iterator, _LIS_T>;",
			"    vector<_LIS_T> cur;",
			"    vector<vector<int>> ind;",
			"    for(int i = 0; i < (int)v.size(); i++){",
			"        auto itr = _LIS_T_bound(cur.begin(), cur.end(), v[i]);",
			"        if(itr == cur.end()){",
			"            ind.push_back({i});",
			"            cur.push_back(v[i]);",
			"        } else {",
			"            ind[itr - cur.begin()].push_back(i);",
			"            *itr = v[i];",
			"        }",
			"    }",
			"    vector<int> res(ind.size()+1, INF);",
			"    for(int i = (int)ind.size()-1; i >= 0; i--){",
			"        res[i] = *prev(upper_bound(ind[i].begin(), ind[i].end(), res[i+1]));",
			"    } res.pop_back();",
			"    return res;",
			"};"
		]
	},
	
	"mergesort_tree": {
		"prefix": "mergesort_tree",
		"body": [
			"template<typename T, auto comp = less<T>()>",
			"struct mergesort_tree{",
			"    int siz;",
			"    vector<vector<T>> node;",
			"    vector<vector<T>> prefix;",
			"    ",
			"    mergesort_tree(const vector<T>& v):",
			"        siz(v.size()), node(siz*2), prefix(siz*2, {0}){",
			"            for(int i = 0; i < siz; i++) node[i+siz] = {v[i]};",
			"            for(int i = siz-1; i > 0; i--){",
			"                node[i].reserve(node[i*2].size() + node[i*2+1].size());",
			"                merge(node[i*2].begin(), node[i*2].end(), node[i*2+1].begin(), node[i*2+1].end(), back_inserter(node[i]), comp);",
			"            }",
			"            for(int i = 1; i < 2*siz; i++){",
			"                prefix[i].reserve(node[i].size()+1);",
			"                for(int j = 0; j < node[i].size(); j++){",
			"                    prefix[i].emplace_back(prefix[i].back() + node[i][j]);",
			"                }",
			"            }",
			"        }",
			"    ",
			"    T prod(int left, int right, T val){",
			"        T ans = 0;",
			"        assert(0 <= left && right <= siz);",
			"        for(left+=siz, right+=siz; left < right; left>>=1, right>>=1){",
			"            if(left&1){",
			"                ans = ans + prefix[left][upper_bound(node[left].begin(), node[left].end(), val, comp)-node[left].begin()];",
			"                left++;",
			"            }",
			"            if(right&1){",
			"                right--;",
			"                ans = ans + prefix[right][upper_bound(node[right].begin(), node[right].end(), val, comp)-node[right].begin()];",
			"            }",
			"        }",
			"        return ans;",
			"    }",
			"};"
		]
	},
	
	"out": {
		"prefix": "out",
		"body": [
			"auto out = [&](int y, int x){return (y < 0 || x < 0 || y >= h || x >= w);};"
		]
	},
	
	"qcfium": {
		"prefix": "qcfium",
		"body": [
			"#pragma GCC target(\"avx2\")",
			"#pragma GCC optimize(\"O3\")",
			"#pragma GCC optimize(\"unroll-loops\")"
		]
	},
	
	"random32": {
		"prefix": "random32",
		"body": [
			"random_device seed_gen;",
			"mt19937 engine(seed_gen());"
		]
	},
	
	"random64": {
		"prefix": "random64",
		"body": [
			"random_device seed_gen;",
			"mt19937_64 engine(seed_gen());"
		]
	},
	
	"rangeset": {
		"prefix": "rangeset",
		"body": [
			"template<typename T = long long>",
			"struct rangeset{",
			"    set<pair<T, T>> S;",
			"    static constexpr T T_MAX = numeric_limits<T>::max();",
			"    static constexpr T T_MIN = numeric_limits<T>::min();",
			"    ",
			"    void insert(T x){",
			"        insert(x, x+1);",
			"    }",
			"    ",
			"    auto S_lower_bound(T x){",
			"        return S.lower_bound({x, T_MIN});",
			"    }",
			"    ",
			"    auto S_upper_bound(T x){",
			"        return S.upper_bound({x, T_MAX});",
			"    }",
			"    ",
			"    void insert(T xl, T xr){",
			"        T l = xl, r = xr;",
			"        auto litr = S_lower_bound(xl);",
			"        auto ritr = S_upper_bound(xr);",
			"        ",
			"        if(litr != S.begin()){",
			"            auto plitr = prev(litr);",
			"            if(plitr->second >= xl){",
			"                l = plitr->first;",
			"                litr = plitr;",
			"            }",
			"        }",
			"        if(ritr != S.begin()){",
			"            auto pritr = prev(ritr);",
			"            if(pritr->second > xr){",
			"                r = pritr->second;",
			"            }",
			"        }",
			"        ",
			"        S.erase(litr, ritr);",
			"        S.insert({l, r});",
			"    }",
			"    ",
			"    void erase(T x){",
			"        erase(x, x+1);",
			"    }",
			"    ",
			"    void erase(T xl, T xr){",
			"        auto litr = S_lower_bound(xl);",
			"        auto ritr = S_lower_bound(xr);",
			"        ",
			"        if(ritr == S.begin()) return;",
			"        ",
			"        vector<pair<T, T>> insert_list;",
			"        ",
			"        if(litr != S.begin()){",
			"            auto plitr = prev(litr);",
			"            if(plitr->second > xl){",
			"                insert_list.emplace_back(plitr->first, xl);",
			"                litr = plitr;",
			"            }",
			"        }",
			"        if(ritr != S.begin()){",
			"            auto pritr = prev(ritr);",
			"            if(pritr->second > xr){",
			"                insert_list.emplace_back(xr, pritr->second);",
			"            }",
			"        }",
			"        ",
			"        S.erase(litr, ritr);",
			"        for(auto& i : insert_list) S.insert(i);",
			"    }",
			"    ",
			"    T lower_bound(T x){",
			"        auto itr = S_lower_bound(x);",
			"        if(itr != S.begin()){",
			"            auto pitr = prev(itr);",
			"            if(pitr->second > x) return x;",
			"        }",
			"        if(itr != S.end()) return itr->first;",
			"        return -1;",
			"    }",
			"    ",
			"    T mex(T x){",
			"        auto itr = S_upper_bound(x);",
			"        if(itr != S.begin()){",
			"            auto pitr = prev(itr);",
			"            if(pitr->second <= x) return x;",
			"            else return pitr->second;",
			"        }",
			"        return x;",
			"    }",
			"    ",
			"    bool covered(T x){",
			"        return covered(x, x+1);",
			"    }",
			"    ",
			"    bool covered(T xl, T xr){",
			"        auto itr = S_upper_bound(xl);",
			"        if(itr != S.begin() && prev(itr)->second > xr) return true;",
			"        return false;",
			"    }",
			"    ",
			"    pair<T, T> get_range(T x){",
			"        return *prev(S_upper_bound(x));",
			"    }",
			"};"
		]
	},
	
	"ran_length": {
		"prefix": "ran_length",
		"body": [
			"auto ran_length = [](const string& s){",
			"    vector<pair<char, int>> res;",
			"    int from = 0;",
			"    for(int i = 1; i < (int)s.size(); i++){",
			"        if(s[from] != s[i]){",
			"            res.emplace_back(s[from], i-from);",
			"            from = i;",
			"        }",
			"    }",
			"    res.emplace_back(s[from], ssize(s)-from);",
			"    return res;",
			"};"
		]
	},
	
	"rolling_hash": {
		"prefix": "rolling_hash",
		"body": [
			"struct rolling_hash{",
			"    using ull = unsigned long long;",
			"    mt19937 engine;",
			"    static inline bool initialized = false;",
			"    static inline ull R[] = {31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113};",
			"    static inline ull P[] = {212562751716319399, 254150812527087877, 491859170460856777, 779029955103971911, 801832197883117157, 1033574886982806739, 1115092592140010779, 1182176896119698579, 1200561753880207919, 1439883598574699989, 1441397709672925351, 1513361481786013063, 1524202854880601089, 1580711312213798981, 1613089974317192531, 1663113980666846003, 1707697571117085817, 1716899325535203269, 1829970195202798609, 1931278105495932761, 2119625388329395181, 2202627600796689953, 2219065490389373191, 2220184659765199801, 2222495685144301331, 2364895621425713903, 2471798774321069737, 2506584517777251419, 2569473443732170429, 2686475138425954621, 2689907617283980729, 2699251905445339159, 2739819703862432417, 2911372461289883417, 3080943651256916719, 3126978275318795167, 3251073280892604019, 3402698976016055543, 3500475145109080361, 3580889503834535153, 3618109790683137247, 3811390337963814077, 3815848984604524697, 3861935671782926599, 4017051305964851839, 4336971325138309859, 4359220188255753599, 4366540026317365931, 4378397072517011743, 4575372321883762909};",
			"    constexpr static int key_siz = 2;",
			"    struct T{",
			"        ull val, pow;",
			"    };",
			"    using S = array<T, key_siz>;",
			"    segtree<S, [](const S& l, const S& r){",
			"        S res;",
			"        for(int t = 0; t < key_siz; t++){",
			"            res[t].val = (r[t].val + __int128(l[t].val)*r[t].pow)%P[t];",
			"            res[t].pow = (__int128(l[t].pow)*r[t].pow)%P[t];",
			"        }",
			"        return res;",
			"    }, []()->S{return {0, 0};}> hashed;",
			"    ",
			"    rolling_hash(const string& s, ull seed):",
			"        engine(seed), hashed(s.size()){",
			"            if(!initialized){",
			"                shuffle(R, R+20, engine);",
			"                shuffle(P, P+50, engine);",
			"                initialized = true;",
			"            }",
			"            ",
			"            for(int i = 0; i < (int)s.size(); i++){",
			"                S res;",
			"                for(int j = 0; j < key_siz; j++) res[j] = {ull(s[i]-'a'+1), R[j]};",
			"                hashed.set(i, res);",
			"            }",
			"        }",
			"    ",
			"    vector<ull> prod(int l, int r){",
			"        S _res = hashed.prod(l, r);",
			"        vec<ull> res(key_siz);",
			"        for(int i = 0; i < key_siz; i++) res[i] = _res[i].val;",
			"        return res;",
			"    }",
			"    ",
			"    void set(int p, char x){",
			"        S res;",
			"        for(int i = 0; i < key_siz; i++) res[i] = {ull(x-'a'+1), R[i]};",
			"        hashed.set(p, res);",
			"    }",
			"};"
		]
	},
	
	"rotate": {
		"prefix": "rotate",
		"body": [
			"using T = string;",
			"auto rotate = [](vector<T>& defa){",
			"    int siz = defa.size();",
			"    vector<T> res(siz, T(siz, ' '));",
			"    for(int i = 0; i < siz; i++) for(int j = 0; j < siz; j++) res[j][siz-1-i] = defa[i][j];",
			"    defa = res;",
			"};"
		]
	},
	
	"sat": {
		"prefix": "sat",
		"body": [
			"template<typename T>",
			"T add_sat(T a, T b){",
			"    T MAX = numeric_limits<T>::max(), MIN = numeric_limits<T>::min();",
			"    if(a > 0 && b > MAX - a) return MAX;",
			"    if(a < 0 && b < MIN - a) return MIN;",
			"    return a+b;",
			"}",
			"template<typename T>",
			"T mul_sat(T a, T b){",
			"    T MAX = numeric_limits<T>::max(), MIN = numeric_limits<T>::min();",
			"    T res;",
			"    if(__builtin_mul_overflow(a, b, &res)){",
			"        if((a>0)^(b>0)) return MIN;",
			"        else return MAX;",
			"    }",
			"    return a*b;",
			"}"
		]
	},
	
	"segtree": {
		"prefix": "segtree",
		"body": [
			"template<typename T, auto ope, auto e>",
			"struct segtree{",
			"    int siz;",
			"    vector<T> node;",
			"    ",
			"    segtree() = default;",
			"    segtree(unsigned n):",
			"        siz(bit_ceil(n)), node(siz*2, e()){}",
			"    segtree(const vector<T>& v){init(v);}",
			"    void init(const vector<T>& v){",
			"        siz = bit_ceil(v.size()); node.resize(siz*2, e());",
			"        for(int i = 0; i < (int)v.size(); i++) node[i+siz] = v[i];",
			"        for(int i = siz-1; i >= 1; i--) node[i] = ope(node[i*2], node[i*2+1]);",
			"    }",
			"    ",
			"    T operator[](int pos) const {return node[pos+siz];}",
			"    ",
			"    T get(int pos) const {return node[pos+siz];}",
			"    ",
			"    void set(int pos, T x){",
			"        pos += siz;",
			"        node[pos] = x;",
			"        while(pos>>=1) node[pos] = ope(node[pos<<1], node[(pos<<1)+1]);",
			"    }",
			"    ",
			"    T prod(int left, int right){",
			"        assert(0 <= left && right <= siz);",
			"        T l_ans = e(), r_ans = e();",
			"        for(left+=siz, right+=siz; left < right; left>>=1, right>>=1){",
			"            if(left&1) l_ans = ope(l_ans, node[left++]);",
			"            if(right&1) r_ans = ope(node[--right], r_ans);",
			"        }",
			"        return ope(l_ans, r_ans);",
			"    }",
			"    ",
			"    T all_prod(){",
			"        return node[1];",
			"    }",
			"};"
		]
	},
	
	"sinit": {
		"prefix": "sinit",
		"body": [
			"#ifdef LOCAL",
			"#include <bits/Lstdc++.h>",
			"#else",
			"#include <bits/stdc++.h>",
			"struct fast_io{fast_io(){std::ios::sync_with_stdio(0); std::cin.tie(0);}} _fast_io_ins;",
			"#endif",
			"using namespace std;",
			"",
			"using uint = unsigned;",
			"using ull = unsigned long long;",
			"using ll = long long;",
			"using ld = long double;",
			"#define el '\\n'",
			"#define all(x) begin(x), end(x)",
			"#define initv2(t,a,...) (a), vector<t>(__VA_ARGS__)",
			"#define initv3(t,a,b,...) (a), vector<vector<t>>((b), vector<t>(__VA_ARGS__))",
			"#define vec vector",
			"#define elif else if",
			"",
			"constexpr long long LLINF = (1ll<<62)-1; constexpr int INF = (1<<30)-1;",
			"template<typename T, typename U> istream& operator>>(istream& ist, pair<T, U>& p) {ist >> p.first >> p.second; return ist;} template<typename T> istream& operator>>(istream& ist, vector<T>& v) {for(T& i : v) ist >> i; return ist;} void read_d_graph(vector<vector<pair<long long, int>>>& v, int m, int num = -1); void read_d_graph(vector<vector<int>>& v, int m, int num = -1); void read_ud_graph(vector<vector<pair<long long, int>>>& v, int m, int num = -1); void read_ud_graph(vector<vector<int>>& v, int m, int num = -1); template<typename T> void read_multi() {} template<typename T, typename... U> void read_multi(int n, vector<T>& v, U&&... args) {if(n < ssize(v)) {cin >> v[n]; read_multi(args..., n+1, v);}} template<typename T, typename... U> void read_multi(vector<T>& v, U&&... args) {read_multi(args..., 0, v);} template<typename T = string> T input() {T res; cin >> res; return res;} template<typename T, typename U> ostream& operator<<(ostream& ost, const pair<T, U> p) {ost << '{' << p.first << ' ' << p.second << '}'; return ost;} template<typename T> ostream& operator<<(ostream& ost, const vector<T>& v) {for(int i = 0; i < ssize(v); i++) {ost << (i ? \" \" : \"\") << v[i];} return ost;} template<typename T> ostream& operator<<(ostream& ost, const vector<vector<T>>& v) {for(int i = 0; i < ssize(v); i++) {ost << (i ? \"\\n\" : \"\") << v[i];} return ost;}",
			"void add_each(...) {} template<typename T, typename... U> void add_each(long long n, vector<T>& v, U&... args); template<typename T, typename U> inline bool chmin(T& a, U b) {if(a > b){a = b; return true;} return false;} template<typename T, typename U> inline bool chmax(T& a, U b) {if(a < b){a = b; return true;} return false;} template<typename T> inline T minv(const vector<T>& v) {return *min_element(v.begin(), v.end());} template<typename T> inline T maxv(const vector<T>& v) {return *max_element(v.begin(), v.end());} long long power(long long val, long long num, long long mod = LLONG_MAX);",
			"",
			"#if __has_include(<atcoder/modint>)",
			"#include <atcoder/modint>",
			"using namespace atcoder;",
			"using mint9 = modint998244353;",
			"using mint1 = modint1000000007;",
			"ostream& operator<<(ostream& ost, const mint1& x) {ost << x.val(); return ost;} ostream& operator<<(ostream& ost, const mint9& x) {ost << x.val(); return ost;}",
			"#endif",
			"",
			"//*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*/",
			"//*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*/",
			"",
			"",
			"",
			"signed main(){",
			"    $1",
			"    ",
			"}",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"",
			"//*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*/",
			"//*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*!?*/",
			"",
			"void read_d_graph(vector<vector<pair<long long, int>>>& v, int m, int num){",
			"    int a, b; long long c;",
			"    for(int _ = 0; _ < m; _++){",
			"        cin >> a >> b >> c;",
			"        a += num; b += num;",
			"        v[a].emplace_back(c, b);",
			"    }",
			"}",
			"void read_d_graph(vector<vector<int>>& v, int m, int num){",
			"    int a, b;",
			"    for(int _ = 0; _ < m; _++){",
			"        cin >> a >> b;",
			"        a += num; b += num;",
			"        v[a].emplace_back(b);",
			"    }",
			"}",
			"void read_ud_graph(vector<vector<pair<long long, int>>>& v, int m, int num){",
			"    int a, b; long long c;",
			"    for(int _ = 0; _ < m; _++){",
			"        cin >> a >> b >> c;",
			"        a += num; b += num;",
			"        v[a].emplace_back(c, b);",
			"        v[b].emplace_back(c, a);",
			"    }",
			"}",
			"void read_ud_graph(vector<vector<int>>& v, int m, int num){",
			"    int a, b;",
			"    for(int _ = 0; _ < m; _++){",
			"        cin >> a >> b;",
			"        a += num; b += num;",
			"        v[a].emplace_back(b);",
			"        v[b].emplace_back(a);",
			"    }",
			"}",
			"template<typename T, typename... U> void add_each(long long n, vector<T>& v, U&... args){",
			"    for(auto& i : v) i += n;",
			"    add_each(n, args...);",
			"}",
			"long long power(long long val, long long num, long long mod){",
			"    assert(mod >= 0); assert(num >= 0);",
			"    long long res = 1;",
			"    val %= mod;",
			"    while(num){",
			"        if(num&1) res = (res*val)%mod;",
			"        val = (val*val)%mod;",
			"        num >>= 1;",
			"    }",
			"    return res;",
			"}",
			"//PgUp5回"
		]
	},
	
	"sparse_table": {
		"prefix": "sparse_table",
		"body": [
			"template<typename T, auto op, auto e>",
			"struct sparse_table{",
			"    int n;",
			"    vector<T> table;",
			"    vector<T> start;",
			"    ",
			"    sparse_table() = default;",
			"    sparse_table(const vector<T>& v):",
			"        n(v.size()), table(v), start(1){",
			"            if(v.empty()) return;",
			"            int l2n = 31 - __builtin_clz((unsigned)n);",
			"            table.reserve(n*(1+l2n) - (1<<(l2n+1)) + 2 + l2n);",
			"            for(int bi = 1; (1<<bi) <= n; bi++){",
			"                start.push_back(table.size());",
			"                for(int i = 0; i+(1<<bi) <= n; i++){",
			"                    table.push_back(op(table[start[bi-1]+i], table[start[bi-1]+i+(1<<(bi-1))]));",
			"                }",
			"            }",
			"        }",
			"    ",
			"    T prod(int l, int r){",
			"        assert(0 <= l && l <= r && r <= n);",
			"        if(l == r) return e();",
			"        int bi = 31 - __builtin_clz(r-l);",
			"        return op(table[start[bi]+l], table[start[bi]+r-(1<<bi)]);",
			"    }",
			"};"
		]
	},
	
	"suugaku": {
		"prefix": "suugaku",
		"body": [
			"auto _suugaku = [](auto self, const string& s)->long long {",
			"    long long num = 0;",
			"    for(int i = 0; i < s.size(); i++){",
			"        if(s[i] == ' '){",
			"            continue;",
			"        } else if('0' <= s[i] && s[i] <= '9'){",
			"            num *= 10;",
			"            num += s[i]-'0';",
			"        } else if(s[i] == '('){",
			"            int nex = i+1, cnt = 1;",
			"            while(cnt && ++nex < s.size()){",
			"                if(s[nex] == ')') cnt--;",
			"                if(s[nex] == '(') cnt++;",
			"            }",
			"            num *= self(self, s.substr(i+1, nex-i-1));",
			"            i = nex-1;",
			"        } else{",
			"            if(s[i] == '*' || s[i] == 'x'){",
			"                int nex = i+1;",
			"                while(nex < s.size() && (s[nex] == ' ' || ('0' <= s[nex] && s[nex] <= '9'))) nex++;",
			"                num *= self(self, s.substr(i+1, nex-i-1));",
			"                i = nex-1;",
			"            } else if(s[i] == '/'){",
			"                int nex = i+1;",
			"                while(nex < s.size() && (s[nex] == ' ' || ('0' <= s[nex] && s[nex] <= '9'))) nex++;",
			"                num /= self(self, s.substr(i+1, nex-i-1));",
			"                i = nex-1;",
			"            } else if(s[i] == '+'){",
			"                num += self(self, s.substr(i+1));",
			"                break;",
			"            } else if(s[i] == '-'){",
			"                num -= self(self, s.substr(i+1));",
			"                break;",
			"            } else assert(false);",
			"        }",
			"    }",
			"    return num;",
			"};",
			"auto suugaku = [](const string& s) {return _suugaku(_suugaku, s);};"
		]
	},
	
	"topological_sort": {
		"prefix": "topological_sort",
		"body": [
			"auto topological_sort = [](const vector<vector<int>>& g){",
			"    int n = g.size();",
			"    vector<int> cnt(n);",
			"    vector<int> res; res.reserve(n);",
			"    queue<int> Q;",
			"    for(const auto& v : g) for(auto i : v) cnt[i]++;",
			"    for(int i = 0; i < n; i++) if(cnt[i] == 0) Q.push(i);",
			"    while(!Q.empty()){",
			"        int pos = Q.front();",
			"        Q.pop();",
			"        res.push_back(pos);",
			"        for(int i : g[pos]) if(--cnt[i] == 0) Q.push(i);",
			"    }",
			"    assert(res.size() == g.size());",
			"    return res;",
			"};"
		]
	},
	
	"trie": {
		"prefix": "trie",
		"body": [
			"struct trie{",
			"    using ar = array<pair<int, int>, 27>;",
			"    vector<ar> node;",
			"    deque<int> reuse;",
			"    ar def;",
			"    char ex;",
			"    trie(int n, char s = '_'){",
			"        node.reserve(n);",
			"        def.fill({-1, 0});",
			"        ex = s;",
			"        make_node();",
			"    }",
			"    ",
			"    int make_node(){",
			"        if(reuse.empty()){",
			"            node.push_back(def);",
			"            return node.size()-1;",
			"        } else {",
			"            int res = reuse.back();",
			"            reuse.pop_back();",
			"            return res;",
			"        }",
			"    }",
			"    ",
			"    void add(const string& s){",
			"        int now = 0, str;",
			"        for(int i = 0; i < (int)s.size(); i++){",
			"            if(s[i] == ex) str = 26;",
			"            else str = s[i]-'a';",
			"            if(node[now][str].first == -1){",
			"                node[now][str].first = make_node();",
			"            }",
			"            node[now][str].second++;",
			"            now = node[now][str].first;",
			"        }",
			"    }",
			"    ",
			"    int count(const string& s){",
			"        if(s.size() == 0) return 0;",
			"        int now = 0, str;",
			"        for(int i = 0; i < (int)s.size(); i++){",
			"            str = s[i]-'a';",
			"            if(s[i] == ex) str = 26;",
			"            if(node[now][str].first == -1){",
			"                return 0;",
			"            }",
			"            if(i != (int)s.size()-1) now = node[now][str].first;",
			"        }",
			"        int cnt = 0;",
			"        for(int i = 0; i < 27; i++) cnt += node[node[now][str].first][i].second;",
			"        return node[now][str].second - cnt;",
			"    }",
			"    ",
			"    int erase(const string& s, int num = INF){",
			"        num = min(num, count(s));",
			"        if(num == 0) return 0;",
			"        int now = 0, str;",
			"        vector<pair<int, int>> del_node;",
			"        for(int i = 0; i < (int)s.size(); i++){",
			"            str = s[i]-'a';",
			"            if(s[i] == ex) str = 26;",
			"            node[now][str].second -= num;",
			"            if(node[now][str].second == 0) del_node.emplace_back(now, str);",
			"            now = node[now][str].first;",
			"        }",
			"        for(auto [pos, str] : del_node){",
			"            reuse.emplace_back(node[pos][str].first);",
			"            node[pos][str].first = -1;",
			"        }",
			"        return num;",
			"    }",
			"};"
		]
	},
	
	"unionfind": {
		"prefix": "unionfind",
		"body": [
			"struct unionfind{",
			"    vector<int> par, rank;",
			"    int siz;",
			"    ",
			"    unionfind(int n):",
			"        par(n), rank(n, 1), siz(n){",
			"            iota(par.begin(), par.end(), 0);",
			"        }",
			"    unionfind(const vector<vector<int>>& v):",
			"    unionfind(v.size()){",
			"        for(int i = 0; i < siz; i++){",
			"            for(int j : v[i]) merge(i, j);",
			"        }",
			"    }",
			"    ",
			"    int root(int x){",
			"        if(par[x] == x) return x;",
			"        return par[x] = root(par[x]);",
			"    }",
			"    ",
			"    bool merge(int x, int y){",
			"        x = root(x);",
			"        y = root(y);",
			"        if(x == y) return false;",
			"        if(rank[x] < rank[y]) swap(x, y);",
			"        par[y] = x;",
			"        rank[x] += rank[y];",
			"        return true;",
			"    }",
			"    ",
			"    bool same(int x, int y){",
			"        return root(x) == root(y);",
			"    }",
			"    ",
			"    vector<vector<int>> groups(){",
			"        vector<vector<int>> res_memo(siz);",
			"        for(int i = 0; i < siz; i++){",
			"            res_memo[root(i)].emplace_back(i);",
			"        }",
			"        vector<vector<int>> res;",
			"        for(int i = 0; i < siz; i++){",
			"            if(!res_memo[i].empty()) res.emplace_back(res_memo[i]);",
			"        }",
			"        return res;",
			"    }",
			"};"
		]
	},
	
	"weighted_unionfind": {
		"prefix": "weighted_unionfind",
		"body": [
			"template<class S> struct weighted_unionfind {",
			"    vector<int> par, rank;",
			"    vector<S> weight;",
			"    ",
			"    weighted_unionfind(int n):",
			"        par(n), rank(n), weight(n) {",
			"            iota(par.begin(), par.end(), 0);",
			"        }",
			"    ",
			"    int root(int x){",
			"        if(par[x] == x) return x;",
			"        else {",
			"            int r = root(par[x]);",
			"            weight[x] += weight[par[x]];",
			"            return par[x] = r;",
			"        }",
			"    }",
			"    ",
			"    S get_weight(int x){",
			"        root(x);",
			"        return weight[x];",
			"    }",
			"    ",
			"    bool same(int x, int y){",
			"        return root(x) == root(y);",
			"    }",
			"    ",
			"    //x - y == w",
			"    bool merge(int x, int y, S w){",
			"        w += get_weight(y) - get_weight(x);",
			"        x = root(x); y = root(y);",
			"        if(x == y) return get_diff(x, y) == w;",
			"        if(rank[x] < rank[y]) swap(x, y), w = -w;",
			"        rank[x] += rank[y];",
			"        par[y] = x;",
			"        weight[y] = -w;",
			"        return true;",
			"    }",
			"    ",
			"    S get_diff(int x, int y){",
			"        return get_weight(x) - get_weight(y);",
			"    }",
			"};"
		]
	},
	
	"z_algorithm": {
		"prefix": "z_algorithm",
		"body": [
			"vector<int> z_algorithm(const string& s){",
			"    int n = s.size();",
			"    vector<int> res(n);",
			"    res[0] = n;",
			"    int l = 1, w = 0;",
			"    while(l < n){",
			"        while(l+w < n && s[l+w] == s[w]) w++;",
			"        res[l] = w;",
			"        w = max(w, 1);",
			"        int k = 1;",
			"        if(l+1 != n) while(k+res[k] < w){",
			"            res[l+k] = res[k];",
			"            k++;",
			"        }",
			"        l += k;",
			"        w -= k;",
			"    }",
			"    return res;",
			"}"
		]
	}
}
