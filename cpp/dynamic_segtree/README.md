# dynamic_segtree
静的セグメント木に似ていますが、ノードの動的な生成が可能です。これにより、要素の追加や削除が効率的に行え、空間計算量を抑えることができます。特に、要素のキー（値）が範囲に偏りがある場合に有効です。

<br>

## コンストラクタ

```cpp
dynamic_segtree<T, S, op, e> seg;
```

*   `T`: 要素のキーの型。非負整数を想定しています。
*   `S`: 各ノードが保持する値の型。
*   `op`: `S`に対する二項演算子。結合律を満たす必要があります。
*   `e`: `op`の単位元。

初期状態では、空のツリーが構築されます。

<br>

### 制約

*   `T`は非負整数を想定しています。

### 計算量

*   O(1)

<br>

## set

```cpp
void set(T key, S value);
```

指定された`key`を持つ要素の値を`value`に変更します。もし`key`に対応する要素が存在しない場合は、新しく要素が追加されます。

### 制約

*   `key`は非負整数であること。

### 計算量

*   `T`のビット幅を`W`とすると、O(W)。

<br>

## get

```cpp
S get(T key) const;
```

指定された`key`を持つ要素の値を返します。もし`key`に対応する要素が存在しない場合は、単位元`e()`が返されます。

### 制約

*   `key`は非負整数であること。

### 計算量

*   `T`のビット幅を`W`とすると、O(W)。

<br>

## prod

```cpp
S prod(T l, T r) const;
```

`[l, r)`の範囲（`l`は含む、`r`は含まない）のキーを持つ要素の値に対して、`op`演算を適用した結果を返します。

### 制約

*   `0 <= l <= r`
*   `l`および`r`は非負整数であること。

### 計算量

*   `T`のビット幅を`W`とすると、O(W)。

<br>

## all_prod

```cpp
S all_prod() const;
```

ツリー全体に存在する全ての要素の値に対して、`op`演算を適用した結果を返します。

### 計算量

*   O(1)

<br>

## reserve

```cpp
void reserve(int n);
```

ツリーが最大で`n`個の要素を持つことを想定し、内部メモリを事前に確保します。これにより、要素追加時のメモリ再確保によるオーバーヘッドを減らすことができます。

### 制約

*   `n`は正の整数であること。

### 計算量

*   O(n)