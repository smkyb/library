<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>smkyb's library</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&display=swap">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.5.1/github-markdown.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
<style>
    body { margin: 80px; margin-top: 60px; font-family:'Noto Sans JP', Arial, sans-serif; font-size:large; background: repeating-linear-gradient(-45deg, rgb(245, 245, 245), 40px, rgb(255, 255, 255) 40px, rgb(255, 255, 255) 70px); overflow-y: scroll; }
    .markdown-body { box-sizing: border-box; max-width: 900px; margin: 0 auto; background: #ffffff56; backdrop-filter: blur(3px); color: black; padding: 40px; }
    .markdown-body pre { padding: 16px; overflow: auto; }
    .button_sq button       { display: flex; font-size: 22px; flex-direction: column; gap: 20px; margin-bottom: 10px; padding: 10px; padding-left: 30px; padding-right: 30px; background-color: rgb(89, 158, 157); color: white; border: none; cursor: pointer; text-align: center; transition: 0.5s; }
    .button_sq button:hover { display: flex; font-size: 22px; flex-direction: column; gap: 20px; margin-bottom: 10px; padding: 10px; padding-left: 90px; padding-right: 90px; background-color: rgb(0, 67, 67);    color: white; border: none; cursor: pointer; text-align: center; transition: 0.5s; }
    #button_copy { display: flex; font-size: 14px; }
    #button_copy_oneline { display: flex; font-size: 14px; }
    #status_bar { display: flex; justify-content: center; position: fixed; height: 70px; width:100%; top: 0px; left: 0px; background-color: rgba(255, 255, 255, 0.258);  backdrop-filter: blur(20px); font-family: sans-serif; font-size: 20px; font-weight: bolder; align-content: center; color: white; z-index: 998244353; }
    #status_bar a { margin: 20px; text-decoration: none; color: rgb(63, 97, 144); }
</style>
</head>
<body>
<div id="status_bar">
    <a href="/library/index.html">home</a>
    <a href="/library/about">about</a>
</div>
<article id="md_content" class="markdown-body">
# dynamic_segtree
列のサイズが`numeric_limits&lt;T&gt;::max()`+1のセグ木です．  
仕様は`atcoder::segtree`とほぼ同じです  
</article>

<button id="button_copy" data-copy="template &lt;typename T, typename S, auto op, auto e&gt;
struct dynamic_segtree{
    private:
    
    struct node_t{
        S sum;
        T value;
        array&lt;int, 4&gt; child = {};
        int width = 0;
        node_t() : sum{e()} {}
        node_t(const node_t &amp;o) noexcept = default;
        node_t(node_t &amp;&amp;o) noexcept = default;
        node_t &amp;operator=(const node_t &amp;o) noexcept = default;
        node_t &amp;operator=(node_t &amp;&amp;o) noexcept = default;
    };
    
    static constexpr T one = 1;
    static constexpr int bit_width = sizeof(T) * 8;
    vector&lt;node_t&gt; node;
    int root = -1;
    
    //__builtin_clz
    template&lt;typename _Tp&gt;
    inline int clz(_Tp x) const {
        if constexpr(sizeof(_Tp) == 8ull) return __builtin_clzll(x);
        else return __builtin_clz(x);
    }
    
    inline T mask(int l, int r) const {
        if(r &gt;= bit_width) return -(one&lt;&lt;l);
        return (one&lt;&lt;r) - (one&lt;&lt;l);
    }
    
    inline T masked(T v, int l, int r) const {
        return mask(l, r) &amp; v;
    }
    
    inline int diff_bit(T x, T y) const {
        return ((bit_width-1 - clz(x^y))|1) + 1;
    }
    
    inline int make_node(T v, S x){
        node.emplace_back();
        node.back().value = v;
        node.back().sum = move(x);
        return ssize(node)-1;
    }
    
    public:
    
    dynamic_segtree(){
        make_node(0, e());
        root = make_node(0, e());
        node[root].width = bit_width;
    }
    
    dynamic_segtree&lt;T, S, op, e&gt;&amp; operator=(dynamic_segtree&lt;T, S, op, e&gt;&amp;&amp; o) noexcept = default;
    
    dynamic_segtree(dynamic_segtree&amp;&amp; o) noexcept = default;
    
    void set(T v, const S &amp;x) {
        int pos = root;
        int bit = bit_width;
        int route[65], route_cnt = 0;
        while(true){
            T mv = masked(v, bit-node[pos].width, bit);
            T mnv = masked(node[pos].value, bit-node[pos].width, bit);
            if(mv != mnv){
                route[route_cnt++] = pos;
                int diff = diff_bit(mv, mnv);
                int b = (mv&gt;&gt;(diff-2))&amp;3;
                int nb = (mnv&gt;&gt;(diff-2))&amp;3;
                int inter = make_node(node[pos].value, node[pos].sum);
                int leaf = make_node(v, x);
                node[inter] = node[pos];
                node[inter].width -= bit - diff;
                memset(node[pos].child.data(), 0, sizeof(int)*4);
                node[pos].child[b] = leaf;
                node[pos].child[nb] = inter;
                node[pos].width = bit - diff;
                bit = diff;
                node[leaf].width = bit;
                pos = leaf;
                break;
            } else {
                
                bit -= node[pos].width;
                if(bit == 0){
                    node[pos].sum = x;
                    break;
                }
                route[route_cnt++] = pos;
                int nex = node[pos].child[(v&gt;&gt;(bit-2))&amp;3];
                if(nex == 0){
                    nex = node[pos].child[(v&gt;&gt;(bit-2))&amp;3] = make_node(v, x);
                    node[nex].width = bit;
                    break;
                }
                pos = nex;
            }
        }
        for(int i = route_cnt-1; i &gt;= 0; i--){
            int idx = route[i];
            auto &amp;child = node[idx].child;
            node[idx].sum = op(op(op(node[child[0]].sum, node[child[1]].sum), node[child[2]].sum), node[child[3]].sum);
        }
    }
    
    S get(T p) const {
        int pos = root;
        int bit = bit_width;
        while(pos != 0){
            bit -= node[pos].width;
            if(bit == 0) return node[pos].value==p ? node[pos].sum : e();
            pos = node[pos].child[(p&gt;&gt;(bit-2))&amp;3];
        }
        return e();
    }
    
    S prod(T l, T r) const {
        return _prod(l, r, root, bit_width);
    }
    S _prod(T l, T r, int pos, int bit) const {
        if(pos == 0) return e();
        bit -= node[pos].width;
        T mv = masked(node[pos].value, bit, bit_width);
        if(r &lt;= mv) return e();
        if(l != numeric_limits&lt;T&gt;::min() &amp;&amp; mv-1+(one&lt;&lt;bit) &lt; l) return e();
        if(l &lt;= mv &amp;&amp; mv-1+(one&lt;&lt;bit) &lt; r){
            return node[pos].sum;
        }
        auto &amp;child = node[pos].child;
        return op(op(op(_prod(l, r, child[0], bit), _prod(l, r, child[1], bit)), _prod(l, r, child[2], bit)), _prod(l, r, child[3], bit));
    }
    
    S all_prod() const {
        return node[root].sum;
    }
    
    void reserve(int n) {
        node.reserve(2*n+2);
    }
};
">copy</button>
<button id="button_copy_oneline" data-copy="template &lt;typename T, typename S, auto op, auto e&gt; struct dynamic_segtree{ private: struct node_t{ S sum; T value; array&lt;int, 4&gt; child = {}; int width = 0; node_t() : sum{e()} {} node_t(const node_t &amp;o) noexcept = default; node_t(node_t &amp;&amp;o) noexcept = default; node_t &amp;operator=(const node_t &amp;o) noexcept = default; node_t &amp;operator=(node_t &amp;&amp;o) noexcept = default; }; static constexpr T one = 1; static constexpr int bit_width = sizeof(T) * 8; vector&lt;node_t&gt; node; int root = -1; template&lt;typename _Tp&gt; inline int clz(_Tp x) const { if constexpr(sizeof(_Tp) == 8ull) return __builtin_clzll(x); else return __builtin_clz(x); } inline T mask(int l, int r) const { if(r &gt;= bit_width) return -(one&lt;&lt;l); return (one&lt;&lt;r) - (one&lt;&lt;l); } inline T masked(T v, int l, int r) const { return mask(l, r) &amp; v; } inline int diff_bit(T x, T y) const { return ((bit_width-1 - clz(x^y))|1) + 1; } inline int make_node(T v, S x){ node.emplace_back(); node.back().value = v; node.back().sum = move(x); return ssize(node)-1; } public: dynamic_segtree(){ make_node(0, e()); root = make_node(0, e()); node[root].width = bit_width; } dynamic_segtree&lt;T, S, op, e&gt;&amp; operator=(dynamic_segtree&lt;T, S, op, e&gt;&amp;&amp; o) noexcept = default; dynamic_segtree(dynamic_segtree&amp;&amp; o) noexcept = default; void set(T v, const S &amp;x) { int pos = root; int bit = bit_width; int route[65], route_cnt = 0; while(true){ T mv = masked(v, bit-node[pos].width, bit); T mnv = masked(node[pos].value, bit-node[pos].width, bit); if(mv != mnv){ route[route_cnt++] = pos; int diff = diff_bit(mv, mnv); int b = (mv&gt;&gt;(diff-2))&amp;3; int nb = (mnv&gt;&gt;(diff-2))&amp;3; int inter = make_node(node[pos].value, node[pos].sum); int leaf = make_node(v, x); node[inter] = node[pos]; node[inter].width -= bit - diff; memset(node[pos].child.data(), 0, sizeof(int)*4); node[pos].child[b] = leaf; node[pos].child[nb] = inter; node[pos].width = bit - diff; bit = diff; node[leaf].width = bit; pos = leaf; break; } else { bit -= node[pos].width; if(bit == 0){ node[pos].sum = x; break; } route[route_cnt++] = pos; int nex = node[pos].child[(v&gt;&gt;(bit-2))&amp;3]; if(nex == 0){ nex = node[pos].child[(v&gt;&gt;(bit-2))&amp;3] = make_node(v, x); node[nex].width = bit; break; } pos = nex; } } for(int i = route_cnt-1; i &gt;= 0; i--){ int idx = route[i]; auto &amp;child = node[idx].child; node[idx].sum = op(op(op(node[child[0]].sum, node[child[1]].sum), node[child[2]].sum), node[child[3]].sum); } } S get(T p) const { int pos = root; int bit = bit_width; while(pos != 0){ bit -= node[pos].width; if(bit == 0) return node[pos].value==p ? node[pos].sum : e(); pos = node[pos].child[(p&gt;&gt;(bit-2))&amp;3]; } return e(); } S prod(T l, T r) const { return _prod(l, r, root, bit_width); } S _prod(T l, T r, int pos, int bit) const { if(pos == 0) return e(); bit -= node[pos].width; T mv = masked(node[pos].value, bit, bit_width); if(r &lt;= mv) return e(); if(l != numeric_limits&lt;T&gt;::min() &amp;&amp; mv-1+(one&lt;&lt;bit) &lt; l) return e(); if(l &lt;= mv &amp;&amp; mv-1+(one&lt;&lt;bit) &lt; r){ return node[pos].sum; } auto &amp;child = node[pos].child; return op(op(op(_prod(l, r, child[0], bit), _prod(l, r, child[1], bit)), _prod(l, r, child[2], bit)), _prod(l, r, child[3], bit)); } S all_prod() const { return node[root].sum; } void reserve(int n) { node.reserve(2*n+2); } };">copy_oneline</button>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script>
    marked.setOptions({ gfm: true, breaks: true, headerIds: true, mangle: false, highlight: (code, lang) => { if (lang && hljs.getLanguage(lang)) { return hljs.highlight(code, { language: lang }).value; } return hljs.highlightAuto(code).value; } });
    const mdContent = document.getElementById("md_content");
    if(mdContent) mdContent.innerHTML = marked.parse(mdContent.textContent);
    
    const copyButton = document.getElementById("button_copy")
    if(copyButton){
        copyButton.addEventListener("click", () => {
            const text = copyButton.dataset.copy;
            navigator.clipboard.writeText(text);
        })
    }
    const copyButtonOneline = document.getElementById("button_copy_oneline")
    if(copyButtonOneline){
        copyButtonOneline.addEventListener("click", () => {
            const text = copyButtonOneline.dataset.copy;
            navigator.clipboard.writeText(text);
        })
    }
</script>
</body>
</html>