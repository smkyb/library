<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>smkyb's library</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&display=swap">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.5.1/github-markdown.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
<style>
    html { background: repeating-linear-gradient(-45deg, rgb(245, 245, 245), 40px, rgb(255, 255, 255) 40px, rgb(255, 255, 255) 70px); }
    body { margin: 60px; margin-top: 60px; min-height: 100vh; font-family:'Noto Sans JP', Arial, sans-serif; font-size:large; }
    .markdown-body { box-sizing: border-box; max-width: 900px; margin: 0 auto; background: #ffffff56; backdrop-filter: blur(3px); color: black; padding: 40px; }
    .markdown-body pre { padding: 16px; overflow: auto; }
    .button_sq button       { display: flex; font-size: 22px; flex-direction: column; gap: 20px; margin-bottom: 10px; padding: 10px; padding-left: 30px; padding-right: 30px; background-color: rgb(89, 158, 157); color: white; border: none; cursor: pointer; text-align: center; transition: 0.5s; }
    .button_sq button:hover { display: flex; font-size: 22px; flex-direction: column; gap: 20px; margin-bottom: 10px; padding: 10px; padding-left: 90px; padding-right: 90px; background-color: rgb(0, 67, 67);    color: white; border: none; cursor: pointer; text-align: center; transition: 0.5s; }
    #button_copy { display: flex; font-size: 14px; }
    #button_copy_oneline { display: flex; font-size: 14px; }
    #status_bar { display: flex; justify-content: center; position: fixed; height: 70px; width:100%; top: 0px; left: 0px; background-color: rgba(255, 255, 255, 0.258);  backdrop-filter: blur(20px); font-family: sans-serif; font-size: 20px; font-weight: bolder; align-content: center; color: white; z-index: 998244353; }
    #status_bar a { margin: 20px; text-decoration: none; color: rgb(63, 97, 144); }
</style>
</head>
<body>
<div id="status_bar">
    <a href="/library/index.html">home</a>
    <a href="/library/about">about</a>
    <a href="/library/link">link</a>
</div>
<article id="md_content" class="markdown-body">
# Dijkstra

グラフ上の最短経路問題を解くためのアルゴリズムです。

<br>

## 構造体 `graph`

グラフの隣接リスト表現を管理します。

```cpp
struct graph {
    vector&lt;pair&lt;int, long long&gt;&gt; G;
    vector&lt;int&gt; idx;
    struct ref_t {
        vector&lt;pair&lt;int, long long&gt;&gt;::iterator begin_, end_;
        auto begin() const noexcept { return begin_; }
        auto end() const noexcept { return end_; }
        auto size() const noexcept { return end_ - begin_; }
        pair&lt;int, long long&gt; operator[](int p) const { return begin_[p]; }
    };
    graph() = default;
    graph(int n, const vector&lt;pair&lt;int, pair&lt;int, long long&gt;&gt;&gt; &amp;E) { build(n, E); }
    void build(int n, const vector&lt;pair&lt;int, pair&lt;int, long long&gt;&gt;&gt; &amp;E) {
        G.resize(E.size());
        idx.resize(n + 1);
        for (auto &amp;[u, v] : E) {
            idx[u + 1]++;
        }
        for (int i = 1; i &lt;= n; i++) idx[i] += idx[i - 1];
        auto C = idx;
        for (auto &amp;[u, v] : E) {
            G[C[u]++] = v;
        }
    }
    ref_t operator[](int p) { return {G.begin() + idx[p], G.begin() + idx[p + 1]}; }
};
```

*   `graph(int n, const vector&lt;pair&lt;int, pair&lt;int, long long&gt;&gt;&gt; &amp;E)`: 頂点数`n`と辺のリスト`E`からグラフを構築します。辺のリスト`E`は `{u, {v, cost}}` の形式です。

### 制約

*   `n`は正の整数。
*   `E`の各要素 `{u, {v, cost}}` において、`0 &lt;= u &lt; n`、`0 &lt;= v &lt; n`、`cost &gt;= 0`。

### 計算量

*   コンストラクタ: O(V + E) (V: 頂点数, E: 辺数)

<br>

## Dijkstra クラス

ダイクストラ法による最短経路計算を行います。

```cpp
struct _Dijkstra {
    // ... graph struct ...
    struct _comp { bool operator()(const pair&lt;int, long long&gt; &amp;l, const pair&lt;int, long long&gt; &amp;r) { return l.second &gt; r.second; } };
    
    // 一般呼び出し用
    pair&lt;vector&lt;long long&gt;, vector&lt;int&gt;&gt; operator()(int n, const vector&lt;pair&lt;int, pair&lt;int, long long&gt;&gt;&gt; &amp;E, const vector&lt;int&gt; &amp;s);
    
    // template&lt;typename graphlike, ...&gt; operator() ... (内部利用)
};
```

### `operator()`

ダイクストラ法を実行し、各頂点への最短距離と最短経路の直前の頂点を返します。

```cpp
pair&lt;vector&lt;long long&gt;, vector&lt;int&gt;&gt; operator()(int n, const vector&lt;pair&lt;int, pair&lt;int, long long&gt;&gt;&gt; &amp;E, const vector&lt;int&gt; &amp;s)
```

*   `n`: グラフの頂点数。
*   `E`: グラフの辺のリスト。各要素は `{u, {v, cost}}` の形式です。
    *   `u`: 始点
    *   `v`: 終点
    *   `cost`: 辺の重み (非負)
*   `s`: 始点となる頂点のリスト。

### 制約

*   `n`は正の整数。
*   `E`の各要素 `{u, {v, cost}}` において、`0 &lt;= u &lt; n`、`0 &lt;= v &lt; n`、`cost &gt;= 0`。
*   `s`の各要素 `i` において、`0 &lt;= i &lt; n`。

### 計算量

*   O(E log V)

### 返り値

*   `vector&lt;long long&gt;`: 各頂点への最短距離。到達不可能な場合は `-1`。
*   `vector&lt;int&gt;`: 各頂点への最短経路における直前の頂点。始点や到達不可能な頂点は `-1`。

<br></article>

<button id="button_copy" data-copy="struct _Dijkstra {
    struct graph { vector&lt;pair&lt;int, long long&gt;&gt; G; vector&lt;int&gt; idx; struct ref_t { vector&lt;pair&lt;int, long long&gt;&gt;::iterator begin_, end_; auto begin() const noexcept {return begin_;} auto end() const noexcept {return end_;} auto size() const noexcept {return end_ - begin_;} pair&lt;int, long long&gt; operator[](int p) const {return begin_[p];} }; graph() = default; graph(int n, const vector&lt;pair&lt;int, pair&lt;int, long long&gt;&gt;&gt; &amp;E){ build(n, E); } void build(int n, const vector&lt;pair&lt;int, pair&lt;int, long long&gt;&gt;&gt; &amp;E){ G.resize(E.size()); idx.resize(n+1); for(auto &amp;[u, v] : E){ idx[u+1]++; } for(int i = 1; i &lt;= n; i++) idx[i] += idx[i-1]; auto C = idx; for(auto &amp;[u, v] : E){ G[C[u]++] = v; } } ref_t operator[](int p) {return {G.begin()+idx[p], G.begin()+idx[p+1]};} };
    struct _comp { bool operator()(const pair&lt;int, long long&gt; &amp;l, const pair&lt;int, long long&gt; &amp;r) {return l.second &gt; r.second;} };
    //一般呼び出し用
    pair&lt;vector&lt;long long&gt;, vector&lt;int&gt;&gt; operator()(int n, const vector&lt;pair&lt;int, pair&lt;int, long long&gt;&gt;&gt; &amp;E, const vector&lt;int&gt; &amp;s){
        graph G(n, E);
        return (*this)(n, G, s);
    }
    //「自分用に」graph構造体でも呼び出せるようにしているので, これはREADMEに書かなくても良い
    template&lt;typename graphlike, typename = enable_if_t&lt;!is_same_v&lt;decay_t&lt;graphlike&gt;, vector&lt;pair&lt;int, pair&lt;int, long long&gt;&gt;&gt;&gt;&gt;&gt;
    pair&lt;vector&lt;long long&gt;, vector&lt;int&gt;&gt; operator()(int n, graphlike &amp;G, const vector&lt;int&gt; &amp;s){
        vector&lt;long long&gt; dist(n, (1ll&lt;&lt;60));
        vector&lt;int&gt; path(n, -1);
        priority_queue&lt;pair&lt;int, long long&gt;, vector&lt;pair&lt;int, long long&gt;&gt;, _comp&gt; Q;
        for(int i : s){
            dist[i] = 0;
            Q.emplace(i, 0);
        }
        while(!Q.empty()){
            auto [pos, d] = Q.top();
            Q.pop();
            if(d &gt; dist[pos]) continue;
            for(auto [nex, cost] : G[pos]){
                long long nex_cost = d + cost;
                if(dist[nex] &gt; nex_cost){
                    dist[nex] = nex_cost;
                    Q.emplace(nex, nex_cost);
                    path[nex] = pos;
                }
            }
        }
        for(auto &amp;i : dist) if(i &gt;= (1ll&lt;&lt;60)) i = -1;
        return make_pair(dist, path);
    }
} dijkstra;">copy</button>
<button id="button_copy_oneline" data-copy="struct _Dijkstra { struct graph { vector&lt;pair&lt;int, long long&gt;&gt; G; vector&lt;int&gt; idx; struct ref_t { vector&lt;pair&lt;int, long long&gt;&gt;::iterator begin_, end_; auto begin() const noexcept {return begin_;} auto end() const noexcept {return end_;} auto size() const noexcept {return end_ - begin_;} pair&lt;int, long long&gt; operator[](int p) const {return begin_[p];} }; graph() = default; graph(int n, const vector&lt;pair&lt;int, pair&lt;int, long long&gt;&gt;&gt; &amp;E){ build(n, E); } void build(int n, const vector&lt;pair&lt;int, pair&lt;int, long long&gt;&gt;&gt; &amp;E){ G.resize(E.size()); idx.resize(n+1); for(auto &amp;[u, v] : E){ idx[u+1]++; } for(int i = 1; i &lt;= n; i++) idx[i] += idx[i-1]; auto C = idx; for(auto &amp;[u, v] : E){ G[C[u]++] = v; } } ref_t operator[](int p) {return {G.begin()+idx[p], G.begin()+idx[p+1]};} }; struct _comp { bool operator()(const pair&lt;int, long long&gt; &amp;l, const pair&lt;int, long long&gt; &amp;r) {return l.second &gt; r.second;} }; pair&lt;vector&lt;long long&gt;, vector&lt;int&gt;&gt; operator()(int n, const vector&lt;pair&lt;int, pair&lt;int, long long&gt;&gt;&gt; &amp;E, const vector&lt;int&gt; &amp;s){ graph G(n, E); return (*this)(n, G, s); } template&lt;typename graphlike, typename = enable_if_t&lt;!is_same_v&lt;decay_t&lt;graphlike&gt;, vector&lt;pair&lt;int, pair&lt;int, long long&gt;&gt;&gt;&gt;&gt;&gt; pair&lt;vector&lt;long long&gt;, vector&lt;int&gt;&gt; operator()(int n, graphlike &amp;G, const vector&lt;int&gt; &amp;s){ vector&lt;long long&gt; dist(n, (1ll&lt;&lt;60)); vector&lt;int&gt; path(n, -1); priority_queue&lt;pair&lt;int, long long&gt;, vector&lt;pair&lt;int, long long&gt;&gt;, _comp&gt; Q; for(int i : s){ dist[i] = 0; Q.emplace(i, 0); } while(!Q.empty()){ auto [pos, d] = Q.top(); Q.pop(); if(d &gt; dist[pos]) continue; for(auto [nex, cost] : G[pos]){ long long nex_cost = d + cost; if(dist[nex] &gt; nex_cost){ dist[nex] = nex_cost; Q.emplace(nex, nex_cost); path[nex] = pos; } } } for(auto &amp;i : dist) if(i &gt;= (1ll&lt;&lt;60)) i = -1; return make_pair(dist, path); } } dijkstra;">copy_oneline</button>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script>
    marked.setOptions({ gfm: true, breaks: true, headerIds: true, mangle: false, highlight: (code, lang) => { if (lang && hljs.getLanguage(lang)) { return hljs.highlight(code, { language: lang }).value; } return hljs.highlightAuto(code).value; } });
    const mdContent = document.getElementById("md_content");
    if(mdContent) mdContent.innerHTML = marked.parse(mdContent.textContent);
    
    const copyButton = document.getElementById("button_copy")
    if(copyButton){
        copyButton.addEventListener("click", () => {
            const text = copyButton.dataset.copy;
            navigator.clipboard.writeText(text);
        })
    }
    const copyButtonOneline = document.getElementById("button_copy_oneline")
    if(copyButtonOneline){
        copyButtonOneline.addEventListener("click", () => {
            const text = copyButtonOneline.dataset.copy;
            navigator.clipboard.writeText(text);
        })
    }
</script>
</body>
</html>