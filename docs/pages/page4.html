<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>smkyb's library</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&display=swap">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.5.1/github-markdown.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
<style>
<<<<<<< HEAD
    html { background: repeating-linear-gradient(-45deg, rgb(245, 245, 245), 40px, rgb(255, 255, 255) 40px, rgb(255, 255, 255) 70px); }
    body { margin: 60px; margin-top: 60px; min-height: 100vh; font-family:'Noto Sans JP', Arial, sans-serif; font-size:large; }
=======
    body { margin: 80px; margin-top: 60px; font-family:'Noto Sans JP', Arial, sans-serif; font-size:large; background: repeating-linear-gradient(-45deg, rgb(245, 245, 245), 40px, rgb(255, 255, 255) 40px, rgb(255, 255, 255) 70px); overflow-y: scroll; }
>>>>>>> 728e16fe85e92cd2a8d6a210d25163cff019ce13
    .markdown-body { box-sizing: border-box; max-width: 900px; margin: 0 auto; background: #ffffff56; backdrop-filter: blur(3px); color: black; padding: 40px; }
    .markdown-body pre { padding: 16px; overflow: auto; }
    .button_sq button       { display: flex; font-size: 22px; flex-direction: column; gap: 20px; margin-bottom: 10px; padding: 10px; padding-left: 30px; padding-right: 30px; background-color: rgb(89, 158, 157); color: white; border: none; cursor: pointer; text-align: center; transition: 0.5s; }
    .button_sq button:hover { display: flex; font-size: 22px; flex-direction: column; gap: 20px; margin-bottom: 10px; padding: 10px; padding-left: 90px; padding-right: 90px; background-color: rgb(0, 67, 67);    color: white; border: none; cursor: pointer; text-align: center; transition: 0.5s; }
    #button_copy { display: flex; font-size: 14px; }
    #button_copy_oneline { display: flex; font-size: 14px; }
    #status_bar { display: flex; justify-content: center; position: fixed; height: 70px; width:100%; top: 0px; left: 0px; background-color: rgba(255, 255, 255, 0.258);  backdrop-filter: blur(20px); font-family: sans-serif; font-size: 20px; font-weight: bolder; align-content: center; color: white; z-index: 998244353; }
    #status_bar a { margin: 20px; text-decoration: none; color: rgb(63, 97, 144); }
</style>
</head>
<body>
<div id="status_bar">
    <a href="/library/index.html">home</a>
    <a href="/library/about">about</a>
</div>
<article id="md_content" class="markdown-body">
# fastio
少し遅い`fastio`です  
多分cinとcoutで大体いつもどおり使えると思います．(小数はわからない)
</article>

<button id="button_copy" data-copy="struct FIstream{
    static constexpr unsigned SIZ = 1 &lt;&lt; 17;
    char buf[SIZ], *p1 = buf, *p2 = buf;
    
    inline char _getchar(){
        if(p1 == p2){
            p2 = (p1 = buf) + fread(buf, 1, SIZ, stdin);
            if(p1 == p2) [[unlikely]] assert(0&amp;&amp;&quot;EOF&quot;);
        }
        return *p1++;
    }
    
    inline char ignore_space(){
        char c;
        while((c = _getchar()) &lt;= 0x20);
        return c;
    }
    
    template&lt;typename T&gt;
    inline void _read(T&amp; res){
        T x = 0, f = 1;
        char c = ignore_space();
        if(c == &#x27;-&#x27;){
            f = -1;
            c = _getchar();
        }
        while(&#x27;0&#x27; &lt;= c &amp;&amp; c &lt;= &#x27;9&#x27;){
            x = x*10 + (c-&#x27;0&#x27;);
            c = _getchar();
        }
        res = x*f;
    }
    
    template&lt;typename T&gt;
    inline FIstream&amp; operator&gt;&gt;(T&amp; x){_read(x); return *this;}
    inline FIstream&amp; operator&gt;&gt;(char&amp; x){x = ignore_space(); return *this;}
    inline FIstream&amp; operator&gt;&gt;(string&amp; x){
        string().swap(x);
        char c = ignore_space();
        while(c &gt; 0x20){
            x.push_back(c);
            c = _getchar();
        }
        return *this;
    }
} _cin;

struct FOstream_Pre{
    char num[10000][4];
    constexpr FOstream_Pre():num(){
        for(int i = 0; i &lt; 10000; i++){
            int x = i;
            for(int j = 3; j &gt;= 0; j--){
                num[i][j] = x%10 + &#x27;0&#x27;;
                x /= 10;
            }
        }
    }
} constexpr _FOstream_pre;

struct FOstream{
    static constexpr unsigned SIZ = 1 &lt;&lt; 17;
    char buf[SIZ], *p1 = buf, *p2 = buf+SIZ;
    
    inline void _write(){
        fwrite(buf, 1, p1-buf, stdout);
        p1 = buf;
    }
    
    inline void _putchar(char c){
        if(p1 == p2) [[unlikely]] {
            _write();
        }
        *p1++ = c;
    }
    
    template&lt;typename T&gt;
    void _write_i(T x){
        constexpr int DIGIT_SIZ = 40;
        static_assert(DIGIT_SIZ &lt;= SIZ);
        char num[DIGIT_SIZ], *idxp = num+DIGIT_SIZ;
        if(x &lt; 0){
            _putchar(&#x27;-&#x27;);
            x = -x;
        }
        if(p2 - p1 &lt; DIGIT_SIZ) _write();
        while(x &gt;= 10000){
            idxp -= 4;
            memcpy(idxp, _FOstream_pre.num[size_t(x%10000)], 4);
            x /= 10000;
        }
        if(x &gt;= 1000){
            memcpy(p1, _FOstream_pre.num[size_t(x)], 4);
            p1 += 4;
        } else if(x &gt;= 100){
            memcpy(p1, _FOstream_pre.num[size_t(x)]+1, 3);
            p1 += 3;
        } else if(x &gt;= 10){
            memcpy(p1, _FOstream_pre.num[size_t(x)]+2, 2);
            p1 += 2;
        } else *p1++ = char(x)+&#x27;0&#x27;;
        memcpy(p1, idxp, num+DIGIT_SIZ - idxp);
        p1 += num+DIGIT_SIZ - idxp;
    }
    
    template&lt;typename T&gt;
    FOstream &amp;operator&lt;&lt;(const T &amp;x) {_write_i(x); return *this;}
    FOstream &amp;operator&lt;&lt;(char x) {_putchar(x); return *this;}
    FOstream &amp;operator&lt;&lt;(const char *x) {
        while(*x) _putchar(*x++);
        return *this;
    }
    FOstream &amp;operator&lt;&lt;(char *x) {return *this &lt;&lt; const_cast&lt;const char*&gt;(x);}
    FOstream &amp;operator&lt;&lt;(double x) {
        if(isnan(x)) [[unlikely]] return *this &lt;&lt; &quot;nan&quot;;
        char _b[70];
        snprintf(_b, sizeof(_b), &quot;%.*f&quot;, 15, x);
        return *this &lt;&lt; const_cast&lt;const char*&gt;(_b);
    }
    FOstream &amp;operator&lt;&lt;(long double x) {
        if(isnan(x)) [[unlikely]] return *this &lt;&lt; &quot;nan&quot;;
        char _b[330];
        snprintf(_b, sizeof(_b), &quot;%.*Lf&quot;, 15, x);
        return *this &lt;&lt; const_cast&lt;const char*&gt;(_b);
    }
    FOstream&amp; operator&lt;&lt;(const string&amp; x){
        for(char i : x) _putchar(i);
        return *this;
    }
    
    ~FOstream(){
        if(p1 != buf){
            fwrite(buf, 1, p1 - buf, stdout);
        }
    }
} _cout;

#define cin _cin
#define istream FIstream
#define cout _cout
#define ostream FOstream
">copy</button>
<button id="button_copy_oneline" data-copy="struct FIstream{ static constexpr unsigned SIZ = 1 &lt;&lt; 17; char buf[SIZ], *p1 = buf, *p2 = buf; inline char _getchar(){ if(p1 == p2){ p2 = (p1 = buf) + fread(buf, 1, SIZ, stdin); if(p1 == p2) [[unlikely]] assert(0&amp;&amp;&quot;EOF&quot;); } return *p1++; } inline char ignore_space(){ char c; while((c = _getchar()) &lt;= 0x20); return c; } template&lt;typename T&gt; inline void _read(T&amp; res){ T x = 0, f = 1; char c = ignore_space(); if(c == &#x27;-&#x27;){ f = -1; c = _getchar(); } while(&#x27;0&#x27; &lt;= c &amp;&amp; c &lt;= &#x27;9&#x27;){ x = x*10 + (c-&#x27;0&#x27;); c = _getchar(); } res = x*f; } template&lt;typename T&gt; inline FIstream&amp; operator&gt;&gt;(T&amp; x){_read(x); return *this;} inline FIstream&amp; operator&gt;&gt;(char&amp; x){x = ignore_space(); return *this;} inline FIstream&amp; operator&gt;&gt;(string&amp; x){ string().swap(x); char c = ignore_space(); while(c &gt; 0x20){ x.push_back(c); c = _getchar(); } return *this; } } _cin; struct FOstream_Pre{ char num[10000][4]; constexpr FOstream_Pre():num(){ for(int i = 0; i &lt; 10000; i++){ int x = i; for(int j = 3; j &gt;= 0; j--){ num[i][j] = x%10 + &#x27;0&#x27;; x /= 10; } } } } constexpr _FOstream_pre; struct FOstream{ static constexpr unsigned SIZ = 1 &lt;&lt; 17; char buf[SIZ], *p1 = buf, *p2 = buf+SIZ; inline void _write(){ fwrite(buf, 1, p1-buf, stdout); p1 = buf; } inline void _putchar(char c){ if(p1 == p2) [[unlikely]] { _write(); } *p1++ = c; } template&lt;typename T&gt; void _write_i(T x){ constexpr int DIGIT_SIZ = 40; static_assert(DIGIT_SIZ &lt;= SIZ); char num[DIGIT_SIZ], *idxp = num+DIGIT_SIZ; if(x &lt; 0){ _putchar(&#x27;-&#x27;); x = -x; } if(p2 - p1 &lt; DIGIT_SIZ) _write(); while(x &gt;= 10000){ idxp -= 4; memcpy(idxp, _FOstream_pre.num[size_t(x%10000)], 4); x /= 10000; } if(x &gt;= 1000){ memcpy(p1, _FOstream_pre.num[size_t(x)], 4); p1 += 4; } else if(x &gt;= 100){ memcpy(p1, _FOstream_pre.num[size_t(x)]+1, 3); p1 += 3; } else if(x &gt;= 10){ memcpy(p1, _FOstream_pre.num[size_t(x)]+2, 2); p1 += 2; } else *p1++ = char(x)+&#x27;0&#x27;; memcpy(p1, idxp, num+DIGIT_SIZ - idxp); p1 += num+DIGIT_SIZ - idxp; } template&lt;typename T&gt; FOstream &amp;operator&lt;&lt;(const T &amp;x) {_write_i(x); return *this;} FOstream &amp;operator&lt;&lt;(char x) {_putchar(x); return *this;} FOstream &amp;operator&lt;&lt;(const char *x) { while(*x) _putchar(*x++); return *this; } FOstream &amp;operator&lt;&lt;(char *x) {return *this &lt;&lt; const_cast&lt;const char*&gt;(x);} FOstream &amp;operator&lt;&lt;(double x) { if(isnan(x)) [[unlikely]] return *this &lt;&lt; &quot;nan&quot;; char _b[70]; snprintf(_b, sizeof(_b), &quot;%.*f&quot;, 15, x); return *this &lt;&lt; const_cast&lt;const char*&gt;(_b); } FOstream &amp;operator&lt;&lt;(long double x) { if(isnan(x)) [[unlikely]] return *this &lt;&lt; &quot;nan&quot;; char _b[330]; snprintf(_b, sizeof(_b), &quot;%.*Lf&quot;, 15, x); return *this &lt;&lt; const_cast&lt;const char*&gt;(_b); } FOstream&amp; operator&lt;&lt;(const string&amp; x){ for(char i : x) _putchar(i); return *this; } ~FOstream(){ if(p1 != buf){ fwrite(buf, 1, p1 - buf, stdout); } } } _cout; #define cin _cin
#define istream FIstream
#define cout _cout
#define ostream FOstream
">copy_oneline</button>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script>
    marked.setOptions({ gfm: true, breaks: true, headerIds: true, mangle: false, highlight: (code, lang) => { if (lang && hljs.getLanguage(lang)) { return hljs.highlight(code, { language: lang }).value; } return hljs.highlightAuto(code).value; } });
    const mdContent = document.getElementById("md_content");
    if(mdContent) mdContent.innerHTML = marked.parse(mdContent.textContent);
    
    const copyButton = document.getElementById("button_copy")
    if(copyButton){
        copyButton.addEventListener("click", () => {
            const text = copyButton.dataset.copy;
            navigator.clipboard.writeText(text);
        })
    }
    const copyButtonOneline = document.getElementById("button_copy_oneline")
    if(copyButtonOneline){
        copyButtonOneline.addEventListener("click", () => {
            const text = copyButtonOneline.dataset.copy;
            navigator.clipboard.writeText(text);
        })
    }
</script>
</body>
</html>