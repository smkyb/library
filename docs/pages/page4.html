<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>smkyb's library</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&display=swap">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.5.1/github-markdown.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
<style>
    html { background: repeating-linear-gradient(-45deg, rgb(245, 245, 245), 40px, rgb(255, 255, 255) 40px, rgb(255, 255, 255) 70px); }
    body { margin: 60px; margin-top: 60px; min-height: 100vh; font-family:'Noto Sans JP', Arial, sans-serif; font-size:large; }
    .markdown-body { box-sizing: border-box; max-width: 900px; margin: 0 auto; background: #ffffff56; backdrop-filter: blur(3px); color: black; padding: 40px; }
    .markdown-body pre { padding: 16px; overflow: auto; }
    .button_sq button       { display: flex; font-size: 22px; flex-direction: column; gap: 20px; margin-bottom: 10px; padding: 10px; padding-left: 30px; padding-right: 30px; background-color: rgb(89, 158, 157); color: white; border: none; cursor: pointer; text-align: center; transition: 0.5s; }
    .button_sq button:hover { display: flex; font-size: 22px; flex-direction: column; gap: 20px; margin-bottom: 10px; padding: 10px; padding-left: 90px; padding-right: 90px; background-color: rgb(0, 67, 67);    color: white; border: none; cursor: pointer; text-align: center; transition: 0.5s; }
    #button_copy { display: flex; font-size: 14px; }
    #button_copy_oneline { display: flex; font-size: 14px; }
    #status_bar { display: flex; justify-content: center; position: fixed; height: 70px; width:100%; top: 0px; left: 0px; background-color: rgba(255, 255, 255, 0.258);  backdrop-filter: blur(20px); font-family: sans-serif; font-size: 20px; font-weight: bolder; align-content: center; color: white; z-index: 998244353; }
    #status_bar a { margin: 20px; text-decoration: none; color: rgb(63, 97, 144); }
</style>
</head>
<body>
<div id="status_bar">
    <a href="/library/index.html">home</a>
    <a href="/library/about">about</a>
</div>
<article id="md_content" class="markdown-body">
# Fast I/O

このライブラリは、標準入出力の速度を向上させるためのC++の入出力ストリーム実装です。

## 機能

*   **高速な整数・文字列入力**: `FIstream` クラスは、標準入力から整数や文字列を高速に読み込むためのバッファリングされた入力を提供します。
*   **高速な整数・文字列出力**: `FOstream` クラスは、標準出力へ整数、文字、文字列、浮動小数点数を高速に書き込むためのバッファリングされた出力を提供します。
*   **operator overloading**: `cin` と `cout` のエイリアスが提供されており、標準の C++ ストリームライクなインターフェースで使用できます。

## 使用例

```cpp
#include &lt;iostream&gt;
#include &lt;string&gt;
#include &lt;vector&gt;

// FIstream, FOstream, cin, cout, istream, ostream の定義が含まれていると仮定

int main() {
    // 整数入力
    int a;
    cin &gt;&gt; a;

    // 文字列入力
    std::string s;
    cin &gt;&gt; s;

    // 整数出力
    cout &lt;&lt; a &lt;&lt; std::endl;

    // 文字列出力
    cout &lt;&lt; &quot;Hello, &quot; &lt;&lt; s &lt;&lt; &quot;!&quot; &lt;&lt; std::endl;

    // 浮動小数点数出力
    double pi = 3.1415926535;
    cout &lt;&lt; pi &lt;&lt; std::endl;

    // 複数入力
    int x, y;
    cin &gt;&gt; x &gt;&gt; y;
    cout &lt;&lt; x + y &lt;&lt; std::endl;

    return 0;
}
```

## クラス詳細

### `FIstream`

*   **`_getchar()`**: バッファから1文字読み込みます。バッファが空の場合は標準入力から読み込みます。
*   **`ignore_space()`**: 空白文字（ASCIIコード 0x20 以下）をスキップし、最初の非空白文字を返します。
*   **`_read(T&amp; res)`**: テンプレート関数。整数型 `T` の値を読み込みます。空白文字、符号（`-`）を処理し、数値をパースします。
*   **`operator&gt;&gt;(T&amp; x)`**: 整数型 `T` の値を `x` に読み込みます。
*   **`operator&gt;&gt;(char&amp; x)`**: 最初の非空白文字を `x` に読み込みます。
*   **`operator&gt;&gt;(string&amp; x)`**: 空白文字をスキップした後、次の空白文字が出現するまで文字を読み込み、`std::string` `x` に格納します。

### `FOstream`

*   **`_write()`**: バッファの内容を標準出力に書き込みます。
*   **`_putchar(char c)`**: バッファに1文字書き込みます。バッファが満杯の場合は、書き込む前にバッファの内容をフラッシュします。
*   **`_write_i(T x)`**: テンプレート関数。整数型 `T` の値を高速に文字列に変換してバッファに書き込みます。負の数も処理します。
*   **`operator&lt;&lt;(const T&amp; x)`**: 整数型 `T` の値を標準出力に書き込みます。
*   **`operator&lt;&lt;(char x)`**: 文字 `x` を標準出力に書き込みます。
*   **`operator&lt;&lt;(const char* x)`**: Cスタイルの文字列 `x` を標準出力に書き込みます。
*   **`operator&lt;&lt;(char* x)`**: `const char*` のバージョンにキャストして呼び出します。
*   **`operator&lt;&lt;(double x)`**: `double` 型の値をフォーマットして出力します。`snprintf` を使用して、最大15桁の精度で浮動小数点数を出力します。NaN も処理します。
*   **`operator&lt;&lt;(long double x)`**: `long double` 型の値をフォーマットして出力します。`snprintf` を使用して、最大15桁の精度で浮動小数点数を出力します。NaN も処理します。
*   **`operator&lt;&lt;(const string&amp; x)`**: `std::string` `x` を標準出力に書き込みます。
*   **`~FOstream()`**: デストラクタ。バッファに残っている内容があれば、標準出力に書き込みます。

## マクロ

*   `cin`: `_cin` ( `FIstream` のインスタンス) のエイリアス。
*   `istream`: `FIstream` のエイリアス。
*   `cout`: `_cout` ( `FOstream` のインスタンス) のエイリアス。
*   `ostream`: `FOstream` のエイリアス。</article>

<button id="button_copy" data-copy="struct FIstream{
    static constexpr unsigned SIZ = 1 &lt;&lt; 17;
    char buf[SIZ], *p1 = buf, *p2 = buf;
    
    inline char _getchar(){
        if(p1 == p2){
            p2 = (p1 = buf) + fread(buf, 1, SIZ, stdin);
            if(p1 == p2) [[unlikely]] assert(0&amp;&amp;&quot;EOF&quot;);
        }
        return *p1++;
    }
    
    inline char ignore_space(){
        char c;
        while((c = _getchar()) &lt;= 0x20);
        return c;
    }
    
    template&lt;typename T&gt;
    inline void _read(T&amp; res){
        T x = 0, f = 1;
        char c = ignore_space();
        if(c == &#x27;-&#x27;){
            f = -1;
            c = _getchar();
        }
        while(&#x27;0&#x27; &lt;= c &amp;&amp; c &lt;= &#x27;9&#x27;){
            x = x*10 + (c-&#x27;0&#x27;);
            c = _getchar();
        }
        res = x*f;
    }
    
    template&lt;typename T&gt;
    inline FIstream&amp; operator&gt;&gt;(T&amp; x){_read(x); return *this;}
    inline FIstream&amp; operator&gt;&gt;(char&amp; x){x = ignore_space(); return *this;}
    inline FIstream&amp; operator&gt;&gt;(string&amp; x){
        string().swap(x);
        char c = ignore_space();
        while(c &gt; 0x20){
            x.push_back(c);
            c = _getchar();
        }
        return *this;
    }
} _cin;

struct FOstream_Pre{
    char num[10000][4];
    constexpr FOstream_Pre():num(){
        for(int i = 0; i &lt; 10000; i++){
            int x = i;
            for(int j = 3; j &gt;= 0; j--){
                num[i][j] = x%10 + &#x27;0&#x27;;
                x /= 10;
            }
        }
    }
} constexpr _FOstream_pre;

struct FOstream{
    static constexpr unsigned SIZ = 1 &lt;&lt; 17;
    char buf[SIZ], *p1 = buf, *p2 = buf+SIZ;
    
    inline void _write(){
        fwrite(buf, 1, p1-buf, stdout);
        p1 = buf;
    }
    
    inline void _putchar(char c){
        if(p1 == p2) [[unlikely]] {
            _write();
        }
        *p1++ = c;
    }
    
    template&lt;typename T&gt;
    void _write_i(T x){
        constexpr int DIGIT_SIZ = 40;
        static_assert(DIGIT_SIZ &lt;= SIZ);
        char num[DIGIT_SIZ], *idxp = num+DIGIT_SIZ;
        if(x &lt; 0){
            _putchar(&#x27;-&#x27;);
            x = -x;
        }
        if(p2 - p1 &lt; DIGIT_SIZ) _write();
        while(x &gt;= 10000){
            idxp -= 4;
            memcpy(idxp, _FOstream_pre.num[size_t(x%10000)], 4);
            x /= 10000;
        }
        if(x &gt;= 1000){
            memcpy(p1, _FOstream_pre.num[size_t(x)], 4);
            p1 += 4;
        } else if(x &gt;= 100){
            memcpy(p1, _FOstream_pre.num[size_t(x)]+1, 3);
            p1 += 3;
        } else if(x &gt;= 10){
            memcpy(p1, _FOstream_pre.num[size_t(x)]+2, 2);
            p1 += 2;
        } else *p1++ = char(x)+&#x27;0&#x27;;
        memcpy(p1, idxp, num+DIGIT_SIZ - idxp);
        p1 += num+DIGIT_SIZ - idxp;
    }
    
    template&lt;typename T&gt;
    FOstream &amp;operator&lt;&lt;(const T &amp;x) {_write_i(x); return *this;}
    FOstream &amp;operator&lt;&lt;(char x) {_putchar(x); return *this;}
    FOstream &amp;operator&lt;&lt;(const char *x) {
        while(*x) _putchar(*x++);
        return *this;
    }
    FOstream &amp;operator&lt;&lt;(char *x) {return *this &lt;&lt; const_cast&lt;const char*&gt;(x);}
    FOstream &amp;operator&lt;&lt;(double x) {
        if(isnan(x)) [[unlikely]] return *this &lt;&lt; &quot;nan&quot;;
        char _b[70];
        snprintf(_b, sizeof(_b), &quot;%.*f&quot;, 15, x);
        return *this &lt;&lt; const_cast&lt;const char*&gt;(_b);
    }
    FOstream &amp;operator&lt;&lt;(long double x) {
        if(isnan(x)) [[unlikely]] return *this &lt;&lt; &quot;nan&quot;;
        char _b[330];
        snprintf(_b, sizeof(_b), &quot;%.*Lf&quot;, 15, x);
        return *this &lt;&lt; const_cast&lt;const char*&gt;(_b);
    }
    FOstream&amp; operator&lt;&lt;(const string&amp; x){
        for(char i : x) _putchar(i);
        return *this;
    }
    
    ~FOstream(){
        if(p1 != buf){
            fwrite(buf, 1, p1 - buf, stdout);
        }
    }
} _cout;

#define cin _cin
#define istream FIstream
#define cout _cout
#define ostream FOstream
">copy</button>
<button id="button_copy_oneline" data-copy="struct FIstream{ static constexpr unsigned SIZ = 1 &lt;&lt; 17; char buf[SIZ], *p1 = buf, *p2 = buf; inline char _getchar(){ if(p1 == p2){ p2 = (p1 = buf) + fread(buf, 1, SIZ, stdin); if(p1 == p2) [[unlikely]] assert(0&amp;&amp;&quot;EOF&quot;); } return *p1++; } inline char ignore_space(){ char c; while((c = _getchar()) &lt;= 0x20); return c; } template&lt;typename T&gt; inline void _read(T&amp; res){ T x = 0, f = 1; char c = ignore_space(); if(c == &#x27;-&#x27;){ f = -1; c = _getchar(); } while(&#x27;0&#x27; &lt;= c &amp;&amp; c &lt;= &#x27;9&#x27;){ x = x*10 + (c-&#x27;0&#x27;); c = _getchar(); } res = x*f; } template&lt;typename T&gt; inline FIstream&amp; operator&gt;&gt;(T&amp; x){_read(x); return *this;} inline FIstream&amp; operator&gt;&gt;(char&amp; x){x = ignore_space(); return *this;} inline FIstream&amp; operator&gt;&gt;(string&amp; x){ string().swap(x); char c = ignore_space(); while(c &gt; 0x20){ x.push_back(c); c = _getchar(); } return *this; } } _cin; struct FOstream_Pre{ char num[10000][4]; constexpr FOstream_Pre():num(){ for(int i = 0; i &lt; 10000; i++){ int x = i; for(int j = 3; j &gt;= 0; j--){ num[i][j] = x%10 + &#x27;0&#x27;; x /= 10; } } } } constexpr _FOstream_pre; struct FOstream{ static constexpr unsigned SIZ = 1 &lt;&lt; 17; char buf[SIZ], *p1 = buf, *p2 = buf+SIZ; inline void _write(){ fwrite(buf, 1, p1-buf, stdout); p1 = buf; } inline void _putchar(char c){ if(p1 == p2) [[unlikely]] { _write(); } *p1++ = c; } template&lt;typename T&gt; void _write_i(T x){ constexpr int DIGIT_SIZ = 40; static_assert(DIGIT_SIZ &lt;= SIZ); char num[DIGIT_SIZ], *idxp = num+DIGIT_SIZ; if(x &lt; 0){ _putchar(&#x27;-&#x27;); x = -x; } if(p2 - p1 &lt; DIGIT_SIZ) _write(); while(x &gt;= 10000){ idxp -= 4; memcpy(idxp, _FOstream_pre.num[size_t(x%10000)], 4); x /= 10000; } if(x &gt;= 1000){ memcpy(p1, _FOstream_pre.num[size_t(x)], 4); p1 += 4; } else if(x &gt;= 100){ memcpy(p1, _FOstream_pre.num[size_t(x)]+1, 3); p1 += 3; } else if(x &gt;= 10){ memcpy(p1, _FOstream_pre.num[size_t(x)]+2, 2); p1 += 2; } else *p1++ = char(x)+&#x27;0&#x27;; memcpy(p1, idxp, num+DIGIT_SIZ - idxp); p1 += num+DIGIT_SIZ - idxp; } template&lt;typename T&gt; FOstream &amp;operator&lt;&lt;(const T &amp;x) {_write_i(x); return *this;} FOstream &amp;operator&lt;&lt;(char x) {_putchar(x); return *this;} FOstream &amp;operator&lt;&lt;(const char *x) { while(*x) _putchar(*x++); return *this; } FOstream &amp;operator&lt;&lt;(char *x) {return *this &lt;&lt; const_cast&lt;const char*&gt;(x);} FOstream &amp;operator&lt;&lt;(double x) { if(isnan(x)) [[unlikely]] return *this &lt;&lt; &quot;nan&quot;; char _b[70]; snprintf(_b, sizeof(_b), &quot;%.*f&quot;, 15, x); return *this &lt;&lt; const_cast&lt;const char*&gt;(_b); } FOstream &amp;operator&lt;&lt;(long double x) { if(isnan(x)) [[unlikely]] return *this &lt;&lt; &quot;nan&quot;; char _b[330]; snprintf(_b, sizeof(_b), &quot;%.*Lf&quot;, 15, x); return *this &lt;&lt; const_cast&lt;const char*&gt;(_b); } FOstream&amp; operator&lt;&lt;(const string&amp; x){ for(char i : x) _putchar(i); return *this; } ~FOstream(){ if(p1 != buf){ fwrite(buf, 1, p1 - buf, stdout); } } } _cout; #define cin _cin
#define istream FIstream
#define cout _cout
#define ostream FOstream
">copy_oneline</button>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script>
    marked.setOptions({ gfm: true, breaks: true, headerIds: true, mangle: false, highlight: (code, lang) => { if (lang && hljs.getLanguage(lang)) { return hljs.highlight(code, { language: lang }).value; } return hljs.highlightAuto(code).value; } });
    const mdContent = document.getElementById("md_content");
    if(mdContent) mdContent.innerHTML = marked.parse(mdContent.textContent);
    
    const copyButton = document.getElementById("button_copy")
    if(copyButton){
        copyButton.addEventListener("click", () => {
            const text = copyButton.dataset.copy;
            navigator.clipboard.writeText(text);
        })
    }
    const copyButtonOneline = document.getElementById("button_copy_oneline")
    if(copyButtonOneline){
        copyButtonOneline.addEventListener("click", () => {
            const text = copyButtonOneline.dataset.copy;
            navigator.clipboard.writeText(text);
        })
    }
</script>
</body>
</html>