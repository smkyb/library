<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>smkyb's library</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&display=swap">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.5.1/github-markdown.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
<link rel="preload" href="/library/docs/k-font/keifont.ttf" as="font" type="font/ttf" crossorigin>
<style>
    @font-face { font-family: "keifont"; src: url("/library/docs/k-font/keifont.ttf") format("truetype"), url("/docs/k-font/keifont.ttf") format("truetype"); font-display: swap; }
    html { background: repeating-linear-gradient(-45deg, rgb(245, 245, 245), 40px, rgb(255, 255, 255) 40px, rgb(255, 255, 255) 70px); }
    body { margin: 60px; margin-top: 60px; min-height: 100vh; font-family:'Noto Sans JP', Arial, sans-serif; font-size:17px; }
    .title { padding-top: 20px; font-family: keifont; font-weight: lighter; }
    .markdown-body { box-sizing: border-box; max-width: 900px; margin: 0 auto; background: #ffffff56; backdrop-filter: blur(3px); color: black; padding: 40px; }
    .markdown-body pre { padding: 16px; overflow: auto; }
    .button_sq button       { display: flex; font-size: 22px; flex-direction: column; gap: 20px; margin-bottom: 10px; padding: 10px; padding-left: 30px; padding-right: 30px; background-color: rgb(89, 158, 157); color: white; border: none; cursor: pointer; text-align: center; transition: 0.5s; }
    .button_sq button:hover { display: flex; font-size: 22px; flex-direction: column; gap: 20px; margin-bottom: 10px; padding: 10px; padding-left: 90px; padding-right: 90px; background-color: rgb(0, 67, 67);    color: white; border: none; cursor: pointer; text-align: center; transition: 0.5s; }
    .links { text-decoration: none; color: rgb(10, 56, 117); font-weight: bold; }
    #button_copy { display: flex; font-size: 14px; }
    #button_copy_oneline { display: flex; font-size: 14px; }
    #status_bar { display: flex; justify-content: center; position: fixed; height: 70px; width:100%; top: 0px; left: 0px; background-color: rgba(255, 255, 255, 0.258);  backdrop-filter: blur(20px); font-family: sans-serif; font-size: 20px; font-weight: bolder; align-content: center; color: white; z-index: 998244353; }
    #status_bar a { margin: 20px; text-decoration: none; color: rgb(63, 97, 144); }
</style>
</head>
<body>
<div id="status_bar">
    <a href="/library/index.html">home</a>
    <a href="/library/docs/about.html">about</a>
    <a href="/library/docs/link.html">link</a>
</div>
<article id="md_content" class="markdown-body">
# meldable_binary_trie
キーと値のペアを格納し、効率的な操作を提供するデータ構造です。キーは非負整数で、値は可換モノイドを形成します。

<br>

## コンストラクタ
```cpp
template&lt;typename T, typename S, auto op, auto e&gt;
meldable_binary_trie(T p, const S &amp;x);

template&lt;typename T, typename S, auto op, auto e&gt;
meldable_binary_trie(node_t *x);
```
* `T`: キーの型 (unsigned integer)
* `S`: 値の型 (可換モノイド)
* `op`: 値に対するモノイド演算
* `e`: 値の単位元

* `meldable_binary_trie(T p, const S &amp;x)`: キー `p`、値 `x` を持つ要素で初期化されたトライを構築します。
* `meldable_binary_trie(node_t *x)`: 指定されたノードをルートとするトライを構築します。

### 制約
* `T`は符号なし整数型である必要があります。
* `op`は結合律を満たす二項演算である必要があります。
* `e`は`op`の単位元である必要があります。

### 計算量
* O(1) (あるいは、内部ノードの構築にかかる時間)

<br>

## insert
```cpp
void insert(T v, const S &amp;x)
```
キー `v`、値 `x` の要素をトライに挿入します。キー `v` が既に存在する場合、その値は `op(既存の値, x)` で更新されます。

### 制約
* `0 &lt;= v`

### 計算量
* O(log(max(T)))

<br>

## count
```cpp
int count(T v) const
```
キー `v` を持つ要素の数を返します。

### 制約
* `0 &lt;= v`

### 計算量
* O(log(max(T)))

<br>

## size
```cpp
int size() const
```
トライに含まれる要素の総数を返します。

### 制約
* なし

### 計算量
* O(1)

<br>

## meld
```cpp
static node_t *meld(meldable_binary_trie &amp;l, meldable_binary_trie &amp;r);
static node_t *meld(node_t *l, node_t *r);
static node_t *meld(node_t *l, node_t *r, int bit);
```
2つのトライ `l` と `r` をマージし、新しいトライのルートノードへのポインタを返します。マージされたトライは、`l` と `r` のすべての要素を含みます。

### 制約
* `l` および `r` は有効なトライのルートノードである必要があります。

### 計算量
* O(log(max(T)))

<br>

## split
```cpp
pair&lt;meldable_binary_trie, meldable_binary_trie&gt; split(int p);
static pair&lt;node_t*, node_t*&gt; split(node_t *l, int p);
```
トライを、指定された要素数 `p` で2つのトライに分割します。最初のトライには最初の `p` 個の要素が、2番目のトライには残りの要素が含まれます。

### 制約
* `0 &lt;= p &lt;= size()`

### 計算量
* O(log(max(T)))

<br>

## split_one
```cpp
meldable_binary_trie split_one();
node_t *split_one(node_t *l);
node_t *split_one_rev(node_t *l);
```
トライから要素を1つ取り出し、それを新しいトライとして返します。元のトライからはその要素が削除されます。

### 制約
* トライが空でないこと。

### 計算量
* O(log(max(T)))

<br>

## all_prod
```cpp
S all_prod() const
```
トライに含まれるすべての要素の値に対して、モノイド演算 `op` を適用した結果を返します。

### 制約
* なし

### 計算量
* O(1)

<br>

## init
```cpp
void init(T p, const S &amp;x)
```
トライをキー `p`、値 `x` の要素で初期化します。既存のトライの内容は破棄されます。

### 制約
* `0 &lt;= p`

### 計算量
* O(1)

<br>

## get_size
```cpp
static int get_size(node_t *ptr);
```
指定されたノードをルートとする部分木のノード数を計算します。

### 制約
* `ptr` は有効なノードまたは `node_t::nil` である必要があります。

### 計算量
* O(N)、ここで N は部分木のノード数</article>

<button id="button_copy" data-copy="template&lt;typename T, typename S, auto op, auto e&gt;
struct meldable_binary_trie{
    static_assert(is_unsigned_v&lt;T&gt;);
    
    static constexpr T one = 1;
    static constexpr int bit_width = sizeof(T) * 8;
    
    struct node_t{
        T value;
        S sum;
        int width;
        int count;
        array&lt;node_t*, 4&gt; child;
        node_t() = default;
        node_t(T v, S s, int w, int c) : value(v), sum(s), width(w), count(c), child{&amp;nil, &amp;nil, &amp;nil, &amp;nil} {}
        node_t(T v, S s, int w, int c, node_t* c0, node_t* c1, node_t* c2, node_t* c3) : value(v), sum(s), width(w), count(c), child{c0, c1, c2, c3} {}
        static node_t nil;
    };
    
    struct ref_node_t{
        T val;
        bool exist;
        ref_node_t(T x, bool _e) : val{x}, exist{_e} {}
    };
    
    struct Pool {
        int cnt = 0;
        constexpr static int SIZ = 1&lt;&lt;17;
        node_t *ptr = nullptr, *en = nullptr;
        vector&lt;node_t*&gt; reuse;
        Pool() {
            ptr = new node_t[SIZ];
            en = ptr + SIZ;
        }
        node_t *get() {
            if(ptr == en) {
                if(!reuse.empty()) {
                    auto ptr = reuse.back();
                    reuse.pop_back();
                    return ptr;
                }
                ptr = new node_t[SIZ];
                en = ptr + SIZ;
            }
            return ptr++;
        }
        void push(node_t *p) {reuse.push_back(p);}
    };
    
    static Pool pool;
    node_t* root;
    bool rev = false;
    
    template&lt;typename _Tp&gt;
    inline static int clz(_Tp x) {
        if constexpr(sizeof(_Tp) == 8ull) return __builtin_clzll(x);
        else return __builtin_clz(x);
    }
    
    inline static T mask(int l, int r) {
        if(r &gt;= bit_width) return -(one&lt;&lt;l);
        return (one&lt;&lt;r) - (one&lt;&lt;l);
    }
    
    inline static T masked(T v, int l, int r) {
        return mask(l, r) &amp; v;
    }
    
    inline static int diff_bit(T x, T y) {
        return ((bit_width-1 - clz(x^y))|1) + 1;
    }
    
    //value, sum, width, count, child
    template&lt;typename... Args&gt;
    static inline node_t* make_node(Args ...args) {
        return &amp;((*pool.get()) = node_t(forward&lt;Args&gt;(args)...));
    }
    
    public:
    
    meldable_binary_trie(){
        root = make_node(0, e(), bit_width, 0);
    }
    meldable_binary_trie(T p, const S &amp;x){
        root = make_node(p, x, bit_width, 1);
    }
    meldable_binary_trie(node_t *x){
        root = x;
    }
    
    meldable_binary_trie&amp; operator=(meldable_binary_trie&amp;&amp; o) noexcept = default;
    
    meldable_binary_trie(meldable_binary_trie&amp;&amp; o) noexcept = default;
    
    void insert(T v, const S &amp;x) {
        node_t* pos = root;
        int bit = bit_width;
        node_t *route[65]; int route_cnt = 0;
        while(true){
            T mv = masked(v, bit-pos-&gt;width, bit);
            T mnv = masked(pos-&gt;value, bit-pos-&gt;width, bit);
            if(mv != mnv){
                route[route_cnt++] = pos;
                int diff = diff_bit(mv, mnv);
                int b = (mv&gt;&gt;(diff-2))&amp;3;
                int nb = (mnv&gt;&gt;(diff-2))&amp;3;
                node_t* inter = make_node(pos-&gt;value, pos-&gt;sum, pos-&gt;width-bit+diff, pos-&gt;count, pos-&gt;child[0], pos-&gt;child[1], pos-&gt;child[2], pos-&gt;child[3]);
                node_t* leaf = make_node(v, x, diff, 1);
                pos-&gt;width = bit-diff;
                pos-&gt;count++;
                pos-&gt;child = {&amp;node_t::nil, &amp;node_t::nil, &amp;node_t::nil, &amp;node_t::nil};
                pos-&gt;child[b] = leaf;
                pos-&gt;child[nb] = inter;
                break;
            } else {
                pos-&gt;count++;
                bit -= pos-&gt;width;
                if(bit == 0) {
                    pos-&gt;sum = x;
                    break;
                }
                route[route_cnt++] = pos;
                int b = (v&gt;&gt;(bit-2))&amp;3;
                if(pos-&gt;child[b] == &amp;node_t::nil){
                    pos-&gt;child[b] = make_node(v, x, bit, 1);
                    break;
                }
                pos = pos-&gt;child[b];
            }
        }
        for(int i = route_cnt-1; i &gt;= 0; i--){
            node_t *ptr = route[i];
            ptr-&gt;sum = op(op(op(ptr-&gt;child[0]-&gt;sum, ptr-&gt;child[1]-&gt;sum), ptr-&gt;child[2]-&gt;sum), ptr-&gt;child[3]-&gt;sum);
        }
    }
    
    int count(T v) const {
        node_t* pos = root;
        int bit = bit_width;
        while(pos != &amp;node_t::nil){
            T mv = masked(v, bit-pos-&gt;width, bit);
            T mnv = masked(pos-&gt;value, bit-pos-&gt;width, bit);
            if(mv != mnv) return 0;
            bit -= pos-&gt;width;
            if(bit == 0) return pos-&gt;count;
            pos = pos-&gt;child[(v&gt;&gt;(bit-2))&amp;3];
        }
        return 0;
    }
    
    int size() const {
        return root-&gt;count;
    }
    
    static node_t *meld(meldable_binary_trie &amp;l, meldable_binary_trie &amp;r){
        return meld(l.root, r.root);
    }
    static node_t *meld(node_t *l, node_t *r){
        node_t *res = meld(l, r, bit_width);
        return res;
    }
    static node_t *meld(node_t *l, node_t *r, int bit){
        if(l-&gt;count == 0){
            return r;
        }
        if(r-&gt;count == 0){
            return l;
        }
        T mlv = masked(l-&gt;value, min(bit-l-&gt;width, bit-r-&gt;width), bit);
        T mrv = masked(r-&gt;value, min(bit-l-&gt;width, bit-r-&gt;width), bit);
        if(mlv == mrv){
            if(l-&gt;width == r-&gt;width){
                l-&gt;count += r-&gt;count;
                if(bit == l-&gt;width){
                    l-&gt;sum = op(l-&gt;sum, r-&gt;sum);
                    return l;
                } else {
                    for(int i = 0; i &lt; 4; i++) l-&gt;child[i] = meld(l-&gt;child[i], r-&gt;child[i], bit - l-&gt;width);
                    pool.push(r);
                }
            } else {
                if(l-&gt;width &gt; r-&gt;width) swap(l, r);
                l-&gt;count += r-&gt;count;
                bit -= l-&gt;width;
                r-&gt;width -= l-&gt;width;
                int b = (r-&gt;value&gt;&gt;(bit-2))&amp;3;
                l-&gt;child[b] = meld(l-&gt;child[b], r, bit);
            }
        } else {
            if(l-&gt;width &gt; r-&gt;width) swap(l, r);
            int diff = diff_bit(mlv, mrv);
            if(l-&gt;width &lt;= bit - diff){
                l-&gt;count += r-&gt;count;
                r-&gt;width -= l-&gt;width;
                bit -= l-&gt;width;
                int b = (r-&gt;value&gt;&gt;(bit-2))&amp;3;
                l-&gt;child[b] = meld(l-&gt;child[b], r, bit);
            } else {
                node_t *ptr = make_node(l-&gt;value, l-&gt;sum, l-&gt;width-bit+diff, l-&gt;count, l-&gt;child[0], l-&gt;child[1], l-&gt;child[2], l-&gt;child[3]);
                memcpy(l-&gt;child.data(), node_t::nil.child.data(), sizeof(node_t*) * 4);
                r-&gt;width -= bit - diff;
                l-&gt;width = bit - diff;
                l-&gt;count += r-&gt;count;
                l-&gt;child[l-&gt;value&gt;&gt;(diff-2)&amp;3] = ptr;
                l-&gt;child[r-&gt;value&gt;&gt;(diff-2)&amp;3] = r;
            }
        }
        l-&gt;sum = op(op(op(l-&gt;child[0]-&gt;sum, l-&gt;child[1]-&gt;sum), l-&gt;child[2]-&gt;sum), l-&gt;child[3]-&gt;sum);
        return l;
    }
    
    pair&lt;meldable_binary_trie, meldable_binary_trie&gt; split(int p){
        if(rev) p = root-&gt;count-p;
        auto res = split(root, p);
        if(rev){
            meldable_binary_trie f(res.second), s(res.first);
            f.rev = true; s.rev = true;
            return make_pair(move(f), move(s));
        } else return {meldable_binary_trie(res.first), meldable_binary_trie(res.second)};
    }
    
    static pair&lt;node_t*, node_t*&gt; split(node_t *l, int p){
        if(p == 0) return {&amp;node_t::nil, l};
        if(p == l-&gt;count) return {l, &amp;node_t::nil};
        int acc = 0;
        
        for (int i = 0; i &lt; 4; i++) {
            int c = l-&gt;child[i]-&gt;count;
            if (p &lt; acc + c) {
                auto sub = split(l-&gt;child[i], p - acc);
                
                node_t *ptr = make_node(l-&gt;value, e(), l-&gt;width, 0);
                
                l-&gt;child[i] = sub.first;
                ptr-&gt;child[i] = sub.second;
                for(int j = i+1; j &lt; 4; j++) ptr-&gt;child[j] = l-&gt;child[j];
                for(int j = i+1; j &lt; 4; j++) l-&gt;child[j] = &amp;node_t::nil;
                
                l-&gt;count = 0;
                for(int j = 0; j &lt;= i; j++) l-&gt;count += l-&gt;child[j]-&gt;count;
                for(int j = i; j &lt; 4; j++) ptr-&gt;count += ptr-&gt;child[j]-&gt;count;
                
                l-&gt;sum = e();
                for(int j = 0; j &lt;= i; j++) l-&gt;sum = op(l-&gt;sum, l-&gt;child[j]-&gt;sum);
                for(int j = i; j &lt; 4; j++) ptr-&gt;sum = op(ptr-&gt;sum, ptr-&gt;child[j]-&gt;sum);
                
                return {l, ptr};
            }
            acc += c;
        }
        assert(false);
    }
    
    meldable_binary_trie split_one(){
        if(rev){
            meldable_binary_trie res(split_one_rev(root));
            res.rev = true;
            return move(res);
        } else {
            return meldable_binary_trie(split_one(root));
        }
    }
    node_t *split_one(node_t *l){
        if(l-&gt;count == 1) return &amp;node_t::nil;
        
        l-&gt;count--;
        for(int i = 0; i &lt; 4; i++){
            int c = l-&gt;child[i]-&gt;count;
            if(c == 0) continue;
            l-&gt;child[i] = split_one(l-&gt;child[i]);
            l-&gt;sum = e();
            for(int j = i; j &lt; 4; j++) l-&gt;sum = op(l-&gt;sum, l-&gt;child[j]-&gt;sum);
            return l;
        }
        assert(false);
    }
    node_t *split_one_rev(node_t *l){
        if(l-&gt;count == 1) return &amp;node_t::nil;
        
        l-&gt;count--;
        for(int i = 3; i &gt;= 0; i--){
            int c = l-&gt;child[i]-&gt;count;
            if(c == 0) continue;
            l-&gt;child[i] = split_one_rev(l-&gt;child[i]);
            l-&gt;sum = e();
            for(int j = 0; j &lt;= i; j++) l-&gt;sum = op(l-&gt;sum, l-&gt;child[j]-&gt;sum);
            return l;
        }
        assert(false);
    }
    
    S all_prod() const {return root-&gt;sum;}
    
    void init(T p, const S &amp;x){
        root = make_node(p, x, bit_width, 1);
    }
    
    static int get_size(node_t *ptr){
        if(ptr == &amp;node_t::nil) return 0;
        int res = 1;
        for(int i = 0; i &lt; 4; i++) res += get_size(ptr-&gt;child[i]);
        return res;
    }
};
template&lt;typename T, typename S, auto op, auto e&gt; typename meldable_binary_trie&lt;T, S, op, e&gt;::node_t meldable_binary_trie&lt;T, S, op, e&gt;::node_t::nil = meldable_binary_trie&lt;T, S, op, e&gt;::node_t(0, e(), bit_width, 0);
template&lt;typename T, typename S, auto op, auto e&gt; typename meldable_binary_trie&lt;T, S, op, e&gt;::Pool meldable_binary_trie&lt;T, S, op, e&gt;::pool = meldable_binary_trie&lt;T, S, op, e&gt;::Pool();">copy</button>
<button id="button_copy_oneline" data-copy="template&lt;typename T, typename S, auto op, auto e&gt; struct meldable_binary_trie{ static_assert(is_unsigned_v&lt;T&gt;); static constexpr T one = 1; static constexpr int bit_width = sizeof(T) * 8; struct node_t{ T value; S sum; int width; int count; array&lt;node_t*, 4&gt; child; node_t() = default; node_t(T v, S s, int w, int c) : value(v), sum(s), width(w), count(c), child{&amp;nil, &amp;nil, &amp;nil, &amp;nil} {} node_t(T v, S s, int w, int c, node_t* c0, node_t* c1, node_t* c2, node_t* c3) : value(v), sum(s), width(w), count(c), child{c0, c1, c2, c3} {} static node_t nil; }; struct ref_node_t{ T val; bool exist; ref_node_t(T x, bool _e) : val{x}, exist{_e} {} }; struct Pool { int cnt = 0; constexpr static int SIZ = 1&lt;&lt;17; node_t *ptr = nullptr, *en = nullptr; vector&lt;node_t*&gt; reuse; Pool() { ptr = new node_t[SIZ]; en = ptr + SIZ; } node_t *get() { if(ptr == en) { if(!reuse.empty()) { auto ptr = reuse.back(); reuse.pop_back(); return ptr; } ptr = new node_t[SIZ]; en = ptr + SIZ; } return ptr++; } void push(node_t *p) {reuse.push_back(p);} }; static Pool pool; node_t* root; bool rev = false; template&lt;typename _Tp&gt; inline static int clz(_Tp x) { if constexpr(sizeof(_Tp) == 8ull) return __builtin_clzll(x); else return __builtin_clz(x); } inline static T mask(int l, int r) { if(r &gt;= bit_width) return -(one&lt;&lt;l); return (one&lt;&lt;r) - (one&lt;&lt;l); } inline static T masked(T v, int l, int r) { return mask(l, r) &amp; v; } inline static int diff_bit(T x, T y) { return ((bit_width-1 - clz(x^y))|1) + 1; } template&lt;typename... Args&gt; static inline node_t* make_node(Args ...args) { return &amp;((*pool.get()) = node_t(forward&lt;Args&gt;(args)...)); } public: meldable_binary_trie(){ root = make_node(0, e(), bit_width, 0); } meldable_binary_trie(T p, const S &amp;x){ root = make_node(p, x, bit_width, 1); } meldable_binary_trie(node_t *x){ root = x; } meldable_binary_trie&amp; operator=(meldable_binary_trie&amp;&amp; o) noexcept = default; meldable_binary_trie(meldable_binary_trie&amp;&amp; o) noexcept = default; void insert(T v, const S &amp;x) { node_t* pos = root; int bit = bit_width; node_t *route[65]; int route_cnt = 0; while(true){ T mv = masked(v, bit-pos-&gt;width, bit); T mnv = masked(pos-&gt;value, bit-pos-&gt;width, bit); if(mv != mnv){ route[route_cnt++] = pos; int diff = diff_bit(mv, mnv); int b = (mv&gt;&gt;(diff-2))&amp;3; int nb = (mnv&gt;&gt;(diff-2))&amp;3; node_t* inter = make_node(pos-&gt;value, pos-&gt;sum, pos-&gt;width-bit+diff, pos-&gt;count, pos-&gt;child[0], pos-&gt;child[1], pos-&gt;child[2], pos-&gt;child[3]); node_t* leaf = make_node(v, x, diff, 1); pos-&gt;width = bit-diff; pos-&gt;count++; pos-&gt;child = {&amp;node_t::nil, &amp;node_t::nil, &amp;node_t::nil, &amp;node_t::nil}; pos-&gt;child[b] = leaf; pos-&gt;child[nb] = inter; break; } else { pos-&gt;count++; bit -= pos-&gt;width; if(bit == 0) { pos-&gt;sum = x; break; } route[route_cnt++] = pos; int b = (v&gt;&gt;(bit-2))&amp;3; if(pos-&gt;child[b] == &amp;node_t::nil){ pos-&gt;child[b] = make_node(v, x, bit, 1); break; } pos = pos-&gt;child[b]; } } for(int i = route_cnt-1; i &gt;= 0; i--){ node_t *ptr = route[i]; ptr-&gt;sum = op(op(op(ptr-&gt;child[0]-&gt;sum, ptr-&gt;child[1]-&gt;sum), ptr-&gt;child[2]-&gt;sum), ptr-&gt;child[3]-&gt;sum); } } int count(T v) const { node_t* pos = root; int bit = bit_width; while(pos != &amp;node_t::nil){ T mv = masked(v, bit-pos-&gt;width, bit); T mnv = masked(pos-&gt;value, bit-pos-&gt;width, bit); if(mv != mnv) return 0; bit -= pos-&gt;width; if(bit == 0) return pos-&gt;count; pos = pos-&gt;child[(v&gt;&gt;(bit-2))&amp;3]; } return 0; } int size() const { return root-&gt;count; } static node_t *meld(meldable_binary_trie &amp;l, meldable_binary_trie &amp;r){ return meld(l.root, r.root); } static node_t *meld(node_t *l, node_t *r){ node_t *res = meld(l, r, bit_width); return res; } static node_t *meld(node_t *l, node_t *r, int bit){ if(l-&gt;count == 0){ return r; } if(r-&gt;count == 0){ return l; } T mlv = masked(l-&gt;value, min(bit-l-&gt;width, bit-r-&gt;width), bit); T mrv = masked(r-&gt;value, min(bit-l-&gt;width, bit-r-&gt;width), bit); if(mlv == mrv){ if(l-&gt;width == r-&gt;width){ l-&gt;count += r-&gt;count; if(bit == l-&gt;width){ l-&gt;sum = op(l-&gt;sum, r-&gt;sum); return l; } else { for(int i = 0; i &lt; 4; i++) l-&gt;child[i] = meld(l-&gt;child[i], r-&gt;child[i], bit - l-&gt;width); pool.push(r); } } else { if(l-&gt;width &gt; r-&gt;width) swap(l, r); l-&gt;count += r-&gt;count; bit -= l-&gt;width; r-&gt;width -= l-&gt;width; int b = (r-&gt;value&gt;&gt;(bit-2))&amp;3; l-&gt;child[b] = meld(l-&gt;child[b], r, bit); } } else { if(l-&gt;width &gt; r-&gt;width) swap(l, r); int diff = diff_bit(mlv, mrv); if(l-&gt;width &lt;= bit - diff){ l-&gt;count += r-&gt;count; r-&gt;width -= l-&gt;width; bit -= l-&gt;width; int b = (r-&gt;value&gt;&gt;(bit-2))&amp;3; l-&gt;child[b] = meld(l-&gt;child[b], r, bit); } else { node_t *ptr = make_node(l-&gt;value, l-&gt;sum, l-&gt;width-bit+diff, l-&gt;count, l-&gt;child[0], l-&gt;child[1], l-&gt;child[2], l-&gt;child[3]); memcpy(l-&gt;child.data(), node_t::nil.child.data(), sizeof(node_t*) * 4); r-&gt;width -= bit - diff; l-&gt;width = bit - diff; l-&gt;count += r-&gt;count; l-&gt;child[l-&gt;value&gt;&gt;(diff-2)&amp;3] = ptr; l-&gt;child[r-&gt;value&gt;&gt;(diff-2)&amp;3] = r; } } l-&gt;sum = op(op(op(l-&gt;child[0]-&gt;sum, l-&gt;child[1]-&gt;sum), l-&gt;child[2]-&gt;sum), l-&gt;child[3]-&gt;sum); return l; } pair&lt;meldable_binary_trie, meldable_binary_trie&gt; split(int p){ if(rev) p = root-&gt;count-p; auto res = split(root, p); if(rev){ meldable_binary_trie f(res.second), s(res.first); f.rev = true; s.rev = true; return make_pair(move(f), move(s)); } else return {meldable_binary_trie(res.first), meldable_binary_trie(res.second)}; } static pair&lt;node_t*, node_t*&gt; split(node_t *l, int p){ if(p == 0) return {&amp;node_t::nil, l}; if(p == l-&gt;count) return {l, &amp;node_t::nil}; int acc = 0; for (int i = 0; i &lt; 4; i++) { int c = l-&gt;child[i]-&gt;count; if (p &lt; acc + c) { auto sub = split(l-&gt;child[i], p - acc); node_t *ptr = make_node(l-&gt;value, e(), l-&gt;width, 0); l-&gt;child[i] = sub.first; ptr-&gt;child[i] = sub.second; for(int j = i+1; j &lt; 4; j++) ptr-&gt;child[j] = l-&gt;child[j]; for(int j = i+1; j &lt; 4; j++) l-&gt;child[j] = &amp;node_t::nil; l-&gt;count = 0; for(int j = 0; j &lt;= i; j++) l-&gt;count += l-&gt;child[j]-&gt;count; for(int j = i; j &lt; 4; j++) ptr-&gt;count += ptr-&gt;child[j]-&gt;count; l-&gt;sum = e(); for(int j = 0; j &lt;= i; j++) l-&gt;sum = op(l-&gt;sum, l-&gt;child[j]-&gt;sum); for(int j = i; j &lt; 4; j++) ptr-&gt;sum = op(ptr-&gt;sum, ptr-&gt;child[j]-&gt;sum); return {l, ptr}; } acc += c; } assert(false); } meldable_binary_trie split_one(){ if(rev){ meldable_binary_trie res(split_one_rev(root)); res.rev = true; return move(res); } else { return meldable_binary_trie(split_one(root)); } } node_t *split_one(node_t *l){ if(l-&gt;count == 1) return &amp;node_t::nil; l-&gt;count--; for(int i = 0; i &lt; 4; i++){ int c = l-&gt;child[i]-&gt;count; if(c == 0) continue; l-&gt;child[i] = split_one(l-&gt;child[i]); l-&gt;sum = e(); for(int j = i; j &lt; 4; j++) l-&gt;sum = op(l-&gt;sum, l-&gt;child[j]-&gt;sum); return l; } assert(false); } node_t *split_one_rev(node_t *l){ if(l-&gt;count == 1) return &amp;node_t::nil; l-&gt;count--; for(int i = 3; i &gt;= 0; i--){ int c = l-&gt;child[i]-&gt;count; if(c == 0) continue; l-&gt;child[i] = split_one_rev(l-&gt;child[i]); l-&gt;sum = e(); for(int j = 0; j &lt;= i; j++) l-&gt;sum = op(l-&gt;sum, l-&gt;child[j]-&gt;sum); return l; } assert(false); } S all_prod() const {return root-&gt;sum;} void init(T p, const S &amp;x){ root = make_node(p, x, bit_width, 1); } static int get_size(node_t *ptr){ if(ptr == &amp;node_t::nil) return 0; int res = 1; for(int i = 0; i &lt; 4; i++) res += get_size(ptr-&gt;child[i]); return res; } }; template&lt;typename T, typename S, auto op, auto e&gt; typename meldable_binary_trie&lt;T, S, op, e&gt;::node_t meldable_binary_trie&lt;T, S, op, e&gt;::node_t::nil = meldable_binary_trie&lt;T, S, op, e&gt;::node_t(0, e(), bit_width, 0); template&lt;typename T, typename S, auto op, auto e&gt; typename meldable_binary_trie&lt;T, S, op, e&gt;::Pool meldable_binary_trie&lt;T, S, op, e&gt;::pool = meldable_binary_trie&lt;T, S, op, e&gt;::Pool();">copy_oneline</button>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script>
    marked.setOptions({ gfm: true, breaks: true, headerIds: true, mangle: false, highlight: (code, lang) => { if (lang && hljs.getLanguage(lang)) { return hljs.highlight(code, { language: lang }).value; } return hljs.highlightAuto(code).value; } });
    const mdContent = document.getElementById("md_content");
    if(mdContent) mdContent.innerHTML = marked.parse(mdContent.textContent);
    
    const copyButton = document.getElementById("button_copy")
    if(copyButton){
        copyButton.addEventListener("click", () => {
            const text = copyButton.dataset.copy;
            navigator.clipboard.writeText(text);
        })
    }
    const copyButtonOneline = document.getElementById("button_copy_oneline")
    if(copyButtonOneline){
        copyButtonOneline.addEventListener("click", () => {
            const text = copyButtonOneline.dataset.copy;
            navigator.clipboard.writeText(text);
        })
    }
</script>
</body>
</html>