<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="google-site-verification" content="81kYLtl-Z1udi-AqoyIz8Pl38ya4DdHB4epvzWAECkI" />
<title>smkyb's library</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&display=swap">
<link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.5.1/github-markdown.min.css" as="style" onload="this.rel='stylesheet'">
<link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" as="style" onload="this.rel='stylesheet'">
<link rel="preload" href="/library/docs/k-font/keifont.ttf" as="font" type="font/ttf" crossorigin>
<style>
    @font-face { font-family: "keifont"; src: url("/library/docs/k-font/keifont.ttf") format("truetype"); font-display: swap; }
    html { background: repeating-linear-gradient(-45deg, rgb(245, 245, 245), 40px, rgb(255, 255, 255) 40px, rgb(255, 255, 255) 70px); }
    h1 { font-size: 34px; }
    body { margin: 60px; margin-top: 60px; min-height: 100vh; font-family:'Noto Sans JP', Arial, sans-serif; font-size:17px; }
    .title { padding-top: 20px; font-family: keifont; font-weight: lighter; }
    .markdown-body { box-sizing: border-box; max-width: 900px; margin: 0 auto; background: #ffffff56; backdrop-filter: blur(3px); color: black; padding: 40px; }
    .markdown-body pre { padding: 16px; overflow: auto; }
    .button_sq button       { display: flex; font-size: 22px; flex-direction: column; gap: 20px; margin-bottom: 10px; padding: 10px; padding-left: 30px; padding-right: 30px; background-color: rgb(89, 158, 157); color: white; border: none; cursor: pointer; text-align: center; transition: 0.5s; }
    .button_sq button:hover { display: flex; font-size: 22px; flex-direction: column; gap: 20px; margin-bottom: 10px; padding: 10px; padding-left: 90px; padding-right: 90px; background-color: rgb(0, 67, 67);    color: white; border: none; cursor: pointer; text-align: center; transition: 0.5s; }
    .links { text-decoration: none; color: rgb(10, 56, 117); font-weight: bold; }
    #button_copy { display: flex; font-size: 14px; }
    #button_copy_oneline { display: flex; font-size: 14px; }
    #status_bar { display: flex; justify-content: center; position: fixed; height: 70px; width:100%; top: 0px; left: 0px; background-color: rgba(255, 255, 255, 0.258);  backdrop-filter: blur(15px); font-family: sans-serif; font-size: 20px; font-weight: bolder; align-content: center; color: white; z-index: 998244353; }
    #status_bar a { margin: 20px; text-decoration: none; color: rgb(63, 97, 144); }
</style>
</head>
<body>
<div id="status_bar">
    <a href="/library/index.html">home</a>
    <a href="/library/docs/about.html">about</a>
    <a href="/library/docs/link.html">link</a>
    <a href="/library/docs/library-checker.html">library-checker</a>
</div>
<article id="md_content" class="markdown-body">
# segtree
セグメント木です。モノイド（`op`, `e`）を扱うことができます。

## コンストラクタ
```cpp
segtree&lt;S, op, e&gt; seg(unsigned n);
segtree&lt;S, op, e&gt; seg(const vector&lt;S&gt;&amp; v);
```
*   `S`: 要素の型
*   `op`: モノイドの演算（例: `std::plus&lt;&gt;`, `std::multiplies&lt;&gt;`）
*   `e`: モノイドの単位元（例: `0`, `1`）
*   `n`: 木のサイズ（構築される配列のサイズ）
*   `v`: 初期値の配列

*   1つ目のコンストラクタは、サイズ`n`で単位元`e()`で初期化されたセグメント木を構築します。
*   2つ目のコンストラクタは、配列`v`で初期化されたセグメント木を構築します。

### 制約
*   `n`は非負整数。
*   `v`の要素数は非負整数。

### 計算量
*   1つ目のコンストラクタ: O(n)
*   2つ目のコンストラクタ: O(n)

## set
```cpp
void set(int pos, const S&amp; x);
```
`pos`番目の要素を`x`に変更します。

### 制約
*   `0 &lt;= pos &lt; siz` (`siz`は構築された配列のサイズ)

### 計算量
*   O(log siz)

## add
```cpp
void add(int pos, const S&amp; x);
```
`pos`番目の要素に`x`を適用します。`op(node[pos], x)`を実行します。

### 制約
*   `0 &lt;= pos &lt; siz`

### 計算量
*   O(log siz)

## get
```cpp
const S&amp; get(int pos) const;
```
`pos`番目の要素を取得します。

### 制約
*   `0 &lt;= pos &lt; siz`

### 計算量
*   O(1)

## prod
```cpp
S prod(int left, int right);
```
`left`番目から`right-1`番目までの要素の範囲積を計算します。

### 制約
*   `0 &lt;= left &lt;= right &lt;= siz`

### 計算量
*   O(log siz)

## all_prod
```cpp
S all_prod();
```
全ての要素の積を計算します。

### 計算量
*   O(1)</article>

<button id="button_copy" data-copy="template&lt;typename S, auto op, auto e&gt;
struct segtree{
    int siz;
    vector&lt;S&gt; node;
    
    segtree() = default;
    segtree(unsigned n) : siz(std::bit_ceil(n)), node(siz*2, e()){}
    segtree(const vector&lt;S&gt;&amp; v){init(v);}
    void init(const vector&lt;S&gt;&amp; v){
        siz = bit_ceil(v.size()); node.resize(siz*2, e());
        for(int i = 0; i &lt; (int)v.size(); i++) node[i+siz] = v[i];
        for(int i = siz-1; i &gt;= 1; i--) node[i] = op(node[i*2], node[i*2+1]);
    }
    
    const S &amp;operator[](int pos) const {return node[pos+siz];}
    
    const S &amp;get(int pos) const {return node[pos+siz];}
    
    void set(int pos, const S &amp;x){
        assert(0 &lt;= pos &amp;&amp; pos &lt; siz);
        pos += siz;
        node[pos] = x;
        while(pos&gt;&gt;=1) node[pos] = op(node[pos&lt;&lt;1], node[(pos&lt;&lt;1)+1]);
    }
    
    void add(int pos, const S &amp;x){
        assert(0 &lt;= pos &amp;&amp; pos &lt; siz);
        pos += siz;
        node[pos] = op(node[pos], x);
        while(pos&gt;&gt;=1) node[pos] = op(node[pos], x);
    }
    
    S prod(int left, int right){
        left = max(0, left); right = min(right, siz);
        S l_ans = e(), r_ans = e();
        for(left+=siz, right+=siz; left &lt; right; left&gt;&gt;=1, right&gt;&gt;=1){
            if(left&amp;1) l_ans = op(l_ans, node[left++]);
            if(right&amp;1) r_ans = op(node[--right], r_ans);
        }
        return op(l_ans, r_ans);
    }
    
    S all_prod(){
        return node[1];
    }
};">copy</button>
<button id="button_copy_oneline" data-copy="template&lt;typename S, auto op, auto e&gt; struct segtree{ int siz; vector&lt;S&gt; node; segtree() = default; segtree(unsigned n) : siz(std::bit_ceil(n)), node(siz*2, e()){} segtree(const vector&lt;S&gt;&amp; v){init(v);} void init(const vector&lt;S&gt;&amp; v){ siz = bit_ceil(v.size()); node.resize(siz*2, e()); for(int i = 0; i &lt; (int)v.size(); i++) node[i+siz] = v[i]; for(int i = siz-1; i &gt;= 1; i--) node[i] = op(node[i*2], node[i*2+1]); } const S &amp;operator[](int pos) const {return node[pos+siz];} const S &amp;get(int pos) const {return node[pos+siz];} void set(int pos, const S &amp;x){ assert(0 &lt;= pos &amp;&amp; pos &lt; siz); pos += siz; node[pos] = x; while(pos&gt;&gt;=1) node[pos] = op(node[pos&lt;&lt;1], node[(pos&lt;&lt;1)+1]); } void add(int pos, const S &amp;x){ assert(0 &lt;= pos &amp;&amp; pos &lt; siz); pos += siz; node[pos] = op(node[pos], x); while(pos&gt;&gt;=1) node[pos] = op(node[pos], x); } S prod(int left, int right){ left = max(0, left); right = min(right, siz); S l_ans = e(), r_ans = e(); for(left+=siz, right+=siz; left &lt; right; left&gt;&gt;=1, right&gt;&gt;=1){ if(left&amp;1) l_ans = op(l_ans, node[left++]); if(right&amp;1) r_ans = op(node[--right], r_ans); } return op(l_ans, r_ans); } S all_prod(){ return node[1]; } };">copy_oneline</button>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js" defer></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" defer></script>
<script defer>
    marked.setOptions({ gfm: true, breaks: true, headerIds: true, mangle: false, highlight: (code, lang) => { if (lang && hljs.getLanguage(lang)) { return hljs.highlight(code, { language: lang }).value; } return hljs.highlightAuto(code).value; } });
    const mdContent = document.getElementById("md_content");
    if(mdContent) mdContent.innerHTML = marked.parse(mdContent.textContent);
    
    const copyButton = document.getElementById("button_copy")
    if(copyButton){
        copyButton.addEventListener("click", () => {
            const text = copyButton.dataset.copy;
            navigator.clipboard.writeText(text);
        })
    }
    const copyButtonOneline = document.getElementById("button_copy_oneline")
    if(copyButtonOneline){
        copyButtonOneline.addEventListener("click", () => {
            const text = copyButtonOneline.dataset.copy;
            navigator.clipboard.writeText(text);
        })
    }
    
</script>
</body>
</html>