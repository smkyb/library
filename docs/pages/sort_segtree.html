<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="google-site-verification" content="81kYLtl-Z1udi-AqoyIz8Pl38ya4DdHB4epvzWAECkI" />
<title>smkyb's library</title>
<link rel="preload" href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&display=swap" as="style" onload="this.rel='stylesheet'">
<link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.5.1/github-markdown.min.css" as="style" onload="this.rel='stylesheet'">
<link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" as="style" onload="this.rel='stylesheet'">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/marked/marked.min.js" as="script">
<link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" as="script">
<link rel="preload" href="/library/docs/k-font/keifont.ttf" as="font" type="font/ttf" crossorigin>
<link rel="prefetch" href="/library/index.html">
<link rel="prefetch" href="/library/docs/library-checker.html">
<style>
    @font-face { font-family: "keifont"; src: url("/library/docs/k-font/keifont.ttf") format("truetype"); font-display: swap; }
    html { background: repeating-linear-gradient(-45deg, rgb(245, 245, 245), 40px, rgb(255, 255, 255) 40px, rgb(255, 255, 255) 70px); }
    h1 { font-size: 34px; }
    body { margin: 60px; margin-top: 60px; min-height: 100vh; font-family:'Noto Sans JP', Arial, sans-serif; font-size:17px; visibility: hidden; }
    .title { padding-top: 20px; font-family: keifont; font-weight: lighter; }
    .markdown-body { box-sizing: border-box; max-width: 900px; margin: 0 auto; background: #ffffff56; backdrop-filter: blur(3px); color: black; padding: 40px; }
    .markdown-body pre { padding: 16px; overflow: auto; }
    .button_sq button       { display: flex; font-size: 22px; flex-direction: column; gap: 20px; margin-bottom: 10px; padding: 10px; padding-left: 30px; padding-right: 30px; background-color: rgb(89, 158, 157); color: white; border: none; cursor: pointer; text-align: center; transition: 0.5s; }
    .button_sq button:hover { display: flex; font-size: 22px; flex-direction: column; gap: 20px; margin-bottom: 10px; padding: 10px; padding-left: 90px; padding-right: 90px; background-color: rgb(0, 67, 67);    color: white; border: none; cursor: pointer; text-align: center; transition: 0.5s; }
    .links { text-decoration: none; color: rgb(10, 56, 117); font-weight: bold; }
    #button_copy { display: flex; font-size: 14px; }
    #button_copy_oneline { display: flex; font-size: 14px; }
    #status_bar { display: flex; justify-content: center; position: fixed; height: 70px; width:100%; top: 0px; left: 0px; background-color: rgba(255, 255, 255, 0.258);  backdrop-filter: blur(15px); font-family: sans-serif; font-size: 20px; font-weight: bolder; align-content: center; color: white; z-index: 998244353; }
    #status_bar a { margin: 20px; text-decoration: none; color: rgb(63, 97, 144); }
</style>
</head>
<body>
<div id="status_bar">
    <a href="/library/index.html">home</a>
    <a href="/library/docs/about.html">about</a>
    <a href="/library/docs/link.html">link</a>
    <a href="/library/docs/library-checker.html">library-checker</a>
</div>
<article id="md_content" class="markdown-body">
# sort_segtree
通常のセグメント木に加え，非負整数のキーによる区間ソートを行えるデータ構造です．  
可換性は要求しません．  
<br>
## コンストラクタ
```cpp
/*1*/ sort_segtree&lt;T, S, op, e&gt; seg(int _n);
/*2*/ sort_segtree&lt;T, S, op, e&gt; seg(vector&lt;pair&lt;T, S&gt;&gt; v);
```
* キーの型（非負整数）`T`  
* ACLと同様に`S`, `op`, `e`  
を定義する必要があります．  
<br>
* * 1 : 初期値`e()`，長さ`_n`の数列`a`を作ります．  
* * 2 : 初期値が`v`，長さ`v.size()`の数列`a`を作ります．  
### 制約
* `a`の長さが正，かつ大きすぎない  
### 計算量
* O(n log n)
<br>
## set
```cpp
void set(int i, T k, S x)
```
a[i]の，キーを`k`，値を`x`に変更します．
### 制約
* `0 &lt;= i &lt; _n`  
* `0 &lt;= k`  
### 計算量
`T`の最大値を`m`とすると，  
* O(log(m))
<br>
## prod
```cpp
S prod(int l, int r)
```
仕様はACLのセグメント木と同様です．
### 制約
* `0 &lt;= l &lt;= r &lt;= _n`
### 計算量
`T`の最大値を`m`とすると，  
* O(log(m))
<br>
## sort
```cpp
void sort(int l, int r)
```
`a[l], a[l+1], ..., a[r-1]`をキーの昇順でソートします．
### 制約
* `0 &lt;= l &lt;= r &lt;= _n`
### 計算量
`T`の最大値を`m`とすると，  
* 償却O(log(m))
<br>
## sort_rev
```cpp
void sort_rev(int l, int r)
```
`a[l], a[l+1], ..., a[r-1]`をキーの降順でソートします．
### 制約
* `0 &lt;= l &lt;= r &lt;= _n`
### 計算量
`T`の最大値を`m`とすると，  
* 償却O(log(m))  
</article>

<button id="button_copy" data-copy="namespace smkyb {

template&lt;typename T, typename S, auto op, auto e&gt;
struct meldable_binary_trie{
    static_assert(is_unsigned_v&lt;T&gt;);
    
    static constexpr T one = 1;
    static constexpr int bit_width = sizeof(T) * 8;
    
    struct node_t{
        T value;
        S sum;
        int width;
        int count;
        array&lt;node_t*, 4&gt; child;
        node_t() = default;
        node_t(T v, S s, int w, int c) : value(v), sum(s), width(w), count(c), child{&amp;nil, &amp;nil, &amp;nil, &amp;nil} {}
        node_t(T v, S s, int w, int c, node_t* c0, node_t* c1, node_t* c2, node_t* c3) : value(v), sum(s), width(w), count(c), child{c0, c1, c2, c3} {}
        static node_t nil;
    };
    
    struct ref_node_t{
        T val;
        bool exist;
        ref_node_t(T x, bool _e) : val{x}, exist{_e} {}
    };
    
    struct Pool {
        int cnt = 0;
        constexpr static int SIZ = 1&lt;&lt;17;
        node_t *ptr = nullptr, *en = nullptr;
        vector&lt;node_t*&gt; reuse;
        Pool() {
            ptr = new node_t[SIZ];
            en = ptr + SIZ;
        }
        node_t *get() {
            if(ptr == en) {
                if(!reuse.empty()) {
                    auto ptr = reuse.back();
                    reuse.pop_back();
                    return ptr;
                }
                ptr = new node_t[SIZ];
                en = ptr + SIZ;
            }
            return ptr++;
        }
        void push(node_t *p) {reuse.push_back(p);}
    };
    
    static Pool pool;
    node_t* root;
    bool rev = false;
    
    template&lt;typename _Tp&gt;
    inline static int clz(_Tp x) {
        if constexpr(sizeof(_Tp) == 8ull) return __builtin_clzll(x);
        else return __builtin_clz(x);
    }
    
    inline static T mask(int l, int r) {
        if(r &gt;= bit_width){
            if(l &gt;= bit_width) return 0;
            else return -(one&lt;&lt;l);
        }
        return (one&lt;&lt;r) - (one&lt;&lt;l);
    }
    
    inline static T masked(T v, int l, int r) {
        return mask(l, r) &amp; v;
    }
    
    inline static int diff_bit(T x, T y) {
        return ((bit_width-1 - clz(x^y))|1) + 1;
    }
    
    //value, sum, width, count, child
    template&lt;typename... Args&gt;
    static inline node_t* make_node(Args ...args) {
        return &amp;((*pool.get()) = node_t(forward&lt;Args&gt;(args)...));
    }
    
    public:
    
    meldable_binary_trie(){
        root = make_node(0, e(), bit_width, 0);
    }
    meldable_binary_trie(T p, const S &amp;x){
        root = make_node(p, x, bit_width, 1);
    }
    meldable_binary_trie(node_t *x){
        root = x;
    }
    
    meldable_binary_trie&amp; operator=(meldable_binary_trie&amp;&amp; o) noexcept = default;
    
    meldable_binary_trie(meldable_binary_trie&amp;&amp; o) noexcept = default;
    
    void insert(T v, const S &amp;x) {
        node_t* pos = root;
        int bit = bit_width;
        node_t *route[65]; int route_cnt = 0;
        while(true){
            T mv = masked(v, bit-pos-&gt;width, bit);
            T mnv = masked(pos-&gt;value, bit-pos-&gt;width, bit);
            if(mv != mnv){
                route[route_cnt++] = pos;
                int diff = diff_bit(mv, mnv);
                int b = (mv&gt;&gt;(diff-2))&amp;3;
                int nb = (mnv&gt;&gt;(diff-2))&amp;3;
                node_t* inter = make_node(pos-&gt;value, pos-&gt;sum, pos-&gt;width-bit+diff, pos-&gt;count, pos-&gt;child[0], pos-&gt;child[1], pos-&gt;child[2], pos-&gt;child[3]);
                node_t* leaf = make_node(v, x, diff, 1);
                pos-&gt;width = bit-diff;
                pos-&gt;count++;
                pos-&gt;child = {&amp;node_t::nil, &amp;node_t::nil, &amp;node_t::nil, &amp;node_t::nil};
                pos-&gt;child[b] = leaf;
                pos-&gt;child[nb] = inter;
                break;
            } else {
                pos-&gt;count++;
                bit -= pos-&gt;width;
                if(bit == 0) {
                    pos-&gt;sum = x;
                    break;
                }
                route[route_cnt++] = pos;
                int b = (v&gt;&gt;(bit-2))&amp;3;
                if(pos-&gt;child[b] == &amp;node_t::nil){
                    pos-&gt;child[b] = make_node(v, x, bit, 1);
                    break;
                }
                pos = pos-&gt;child[b];
            }
        }
        for(int i = route_cnt-1; i &gt;= 0; i--){
            node_t *ptr = route[i];
            ptr-&gt;sum = op(op(op(ptr-&gt;child[0]-&gt;sum, ptr-&gt;child[1]-&gt;sum), ptr-&gt;child[2]-&gt;sum), ptr-&gt;child[3]-&gt;sum);
        }
    }
    
    int count(T v) const {
        node_t* pos = root;
        int bit = bit_width;
        while(pos != &amp;node_t::nil){
            T mv = masked(v, bit-pos-&gt;width, bit);
            T mnv = masked(pos-&gt;value, bit-pos-&gt;width, bit);
            if(mv != mnv) return 0;
            bit -= pos-&gt;width;
            if(bit == 0) return pos-&gt;count;
            pos = pos-&gt;child[(v&gt;&gt;(bit-2))&amp;3];
        }
        return 0;
    }
    
    int size() const {
        return root-&gt;count;
    }
    
    static node_t *meld(meldable_binary_trie &amp;l, meldable_binary_trie &amp;r){
        return meld(l.root, r.root);
    }
    static node_t *meld(node_t *l, node_t *r){
        node_t *res = meld(l, r, bit_width);
        return res;
    }
    static node_t *meld(node_t *l, node_t *r, int bit){
        if(l-&gt;count == 0){
            return r;
        }
        if(r-&gt;count == 0){
            return l;
        }
        T mlv = masked(l-&gt;value, min(bit-l-&gt;width, bit-r-&gt;width), bit);
        T mrv = masked(r-&gt;value, min(bit-l-&gt;width, bit-r-&gt;width), bit);
        if(mlv == mrv){
            if(l-&gt;width == r-&gt;width){
                l-&gt;count += r-&gt;count;
                if(bit == l-&gt;width){
                    l-&gt;sum = op(l-&gt;sum, r-&gt;sum);
                    return l;
                } else {
                    for(int i = 0; i &lt; 4; i++) l-&gt;child[i] = meld(l-&gt;child[i], r-&gt;child[i], bit - l-&gt;width);
                    pool.push(r);
                }
            } else {
                if(l-&gt;width &gt; r-&gt;width) swap(l, r);
                l-&gt;count += r-&gt;count;
                bit -= l-&gt;width;
                r-&gt;width -= l-&gt;width;
                int b = (r-&gt;value&gt;&gt;(bit-2))&amp;3;
                l-&gt;child[b] = meld(l-&gt;child[b], r, bit);
            }
        } else {
            if(l-&gt;width &gt; r-&gt;width) swap(l, r);
            int diff = diff_bit(mlv, mrv);
            if(l-&gt;width &lt;= bit - diff){
                l-&gt;count += r-&gt;count;
                r-&gt;width -= l-&gt;width;
                bit -= l-&gt;width;
                int b = (r-&gt;value&gt;&gt;(bit-2))&amp;3;
                l-&gt;child[b] = meld(l-&gt;child[b], r, bit);
            } else {
                node_t *ptr = make_node(l-&gt;value, l-&gt;sum, l-&gt;width-bit+diff, l-&gt;count, l-&gt;child[0], l-&gt;child[1], l-&gt;child[2], l-&gt;child[3]);
                memcpy(l-&gt;child.data(), node_t::nil.child.data(), sizeof(node_t*) * 4);
                r-&gt;width -= bit - diff;
                l-&gt;width = bit - diff;
                l-&gt;count += r-&gt;count;
                l-&gt;child[l-&gt;value&gt;&gt;(diff-2)&amp;3] = ptr;
                l-&gt;child[r-&gt;value&gt;&gt;(diff-2)&amp;3] = r;
            }
        }
        l-&gt;sum = op(op(op(l-&gt;child[0]-&gt;sum, l-&gt;child[1]-&gt;sum), l-&gt;child[2]-&gt;sum), l-&gt;child[3]-&gt;sum);
        return l;
    }
    
    pair&lt;meldable_binary_trie, meldable_binary_trie&gt; split(int p){
        if(rev) p = root-&gt;count-p;
        auto res = split(root, p);
        if(rev){
            meldable_binary_trie f(res.second), s(res.first);
            f.rev = true; s.rev = true;
            return make_pair(move(f), move(s));
        } else return {meldable_binary_trie(res.first), meldable_binary_trie(res.second)};
    }
    
    static pair&lt;node_t*, node_t*&gt; split(node_t *l, int p){
        if(p == 0) return {&amp;node_t::nil, l};
        if(p == l-&gt;count) return {l, &amp;node_t::nil};
        int acc = 0;
        
        for (int i = 0; i &lt; 4; i++) {
            int c = l-&gt;child[i]-&gt;count;
            if (p &lt; acc + c) {
                auto sub = split(l-&gt;child[i], p - acc);
                
                node_t *ptr = make_node(l-&gt;value, e(), l-&gt;width, 0);
                
                l-&gt;child[i] = sub.first;
                ptr-&gt;child[i] = sub.second;
                for(int j = i+1; j &lt; 4; j++) ptr-&gt;child[j] = l-&gt;child[j];
                for(int j = i+1; j &lt; 4; j++) l-&gt;child[j] = &amp;node_t::nil;
                
                l-&gt;count = 0;
                for(int j = 0; j &lt;= i; j++) l-&gt;count += l-&gt;child[j]-&gt;count;
                for(int j = i; j &lt; 4; j++) ptr-&gt;count += ptr-&gt;child[j]-&gt;count;
                
                l-&gt;sum = e();
                for(int j = 0; j &lt;= i; j++) l-&gt;sum = op(l-&gt;sum, l-&gt;child[j]-&gt;sum);
                for(int j = i; j &lt; 4; j++) ptr-&gt;sum = op(ptr-&gt;sum, ptr-&gt;child[j]-&gt;sum);
                
                return {l, ptr};
            }
            acc += c;
        }
        assert(false);
    }
    
    meldable_binary_trie split_one(){
        if(rev){
            meldable_binary_trie res(split_one_rev(root));
            res.rev = true;
            return move(res);
        } else {
            return meldable_binary_trie(split_one(root));
        }
    }
    node_t *split_one(node_t *l){
        if(l-&gt;count == 1) return &amp;node_t::nil;
        
        l-&gt;count--;
        for(int i = 0; i &lt; 4; i++){
            int c = l-&gt;child[i]-&gt;count;
            if(c == 0) continue;
            l-&gt;child[i] = split_one(l-&gt;child[i]);
            l-&gt;sum = e();
            for(int j = i; j &lt; 4; j++) l-&gt;sum = op(l-&gt;sum, l-&gt;child[j]-&gt;sum);
            return l;
        }
        assert(false);
    }
    node_t *split_one_rev(node_t *l){
        if(l-&gt;count == 1) return &amp;node_t::nil;
        
        l-&gt;count--;
        for(int i = 3; i &gt;= 0; i--){
            int c = l-&gt;child[i]-&gt;count;
            if(c == 0) continue;
            l-&gt;child[i] = split_one_rev(l-&gt;child[i]);
            l-&gt;sum = e();
            for(int j = 0; j &lt;= i; j++) l-&gt;sum = op(l-&gt;sum, l-&gt;child[j]-&gt;sum);
            return l;
        }
        assert(false);
    }
    
    S prod_l(int n) {
        return _prod_l(n, root);
    }
    
    S _prod_l(int n, node_t *pos) {
        S res = e();
        for(int i = 0; i &lt; 4; i++){
            if(n &gt;= pos-&gt;child[i]-&gt;count){
                n -= pos-&gt;child[i]-&gt;count;
                res = op(res, pos-&gt;child[i]-&gt;sum);
            } else if(n &gt; 0) return op(res, _prod_l(n, pos-&gt;child[i]));
        }
        return res;
    }
    
    S prod_r(int n) {
        return _prod_r(n, root);
    }
    
    S _prod_r(int n, node_t *pos) {
        S res = e();
        for(int i = 3; i &gt;= 0; i--){
            if(n &gt;= pos-&gt;child[i]-&gt;count){
                n -= pos-&gt;child[i]-&gt;count;
                res = op(pos-&gt;child[i]-&gt;sum, res);
            } else if(n &gt; 0) return op(_prod_r(n, pos-&gt;child[i]), res);
        }
        return res;
    }
    
    S prod_lr(int l, int r) {
        return _prod_lr(l, r, root);
    }
    
    S _prod_lr(int l, int r, node_t *pos) {
        int acc[5];
        acc[0] = 0;
        acc[1] = acc[0] + pos-&gt;child[0]-&gt;count;
        acc[2] = acc[1] + pos-&gt;child[1]-&gt;count;
        acc[3] = acc[2] + pos-&gt;child[2]-&gt;count;
        acc[4] = acc[3] + pos-&gt;child[3]-&gt;count;
        S res = e();
        for(int i = 0; i &lt; 4; i++){
            if(r &lt;= acc[i]) break;
            else if(acc[i+1] &lt;= l) continue;
            else if(acc[i] &lt; l){
                if(acc[i+1] &lt;= r) res = op(res, _prod_r(acc[i+1]-l, pos-&gt;child[i]));
                else res = op(res, _prod_lr(l-acc[i], r-acc[i], pos-&gt;child[i]));
            } else {
                if(acc[i+1] &lt;= r) res = op(res, pos-&gt;child[i]-&gt;sum);
                else res = op(res, _prod_l(r-acc[i], pos-&gt;child[i]));
            }
        }
        return res;
    }
    
    S all_prod() const {return root-&gt;sum;}
    
    void init(T p, const S &amp;x){
        root = make_node(p, x, bit_width, 1);
    }
    
    static int get_size(node_t *ptr){
        if(ptr == &amp;node_t::nil) return 0;
        int res = 1;
        for(int i = 0; i &lt; 4; i++) res += get_size(ptr-&gt;child[i]);
        return res;
    }
};
template&lt;typename T, typename S, auto op, auto e&gt; typename meldable_binary_trie&lt;T, S, op, e&gt;::node_t meldable_binary_trie&lt;T, S, op, e&gt;::node_t::nil = meldable_binary_trie&lt;T, S, op, e&gt;::node_t(0, e(), bit_width, 0);
template&lt;typename T, typename S, auto op, auto e&gt; typename meldable_binary_trie&lt;T, S, op, e&gt;::Pool meldable_binary_trie&lt;T, S, op, e&gt;::pool = meldable_binary_trie&lt;T, S, op, e&gt;::Pool();

struct fastset{
    using ull = unsigned long long;
    using uint = unsigned;
    
    int siz;
    vector&lt;ull&gt; node;
    
    fastset(int _n){
        int n = 1;
        while((n&lt;&lt;6) &lt; _n) n &lt;&lt;= 6;
        siz = (n+1)/63;
        node.resize((n+1)/63 + (_n+63)/64);
    }
    
    void insert(int x){
        uint idx = siz + (x/64);
        x &amp;= 63;
        while(true){
            if((node[idx]&gt;&gt;x) &amp; 1ull) return;
            node[idx] |= (1ull&lt;&lt;x);
            if(idx == 0) return;
            idx--;
            x = idx &amp; 63;
            idx /= 64;
        }
    }
    
    void erase(int x){
        int idx = siz + (x/64);
        x &amp;= 63;
        while(true){
            node[idx] &amp;= ~(1ull&lt;&lt;x);
            if(idx == 0 || node[idx]) return;
            idx--;
            x = idx &amp; 63;
            idx /= 64;
        }
    }
    
    bool count(int x) const {
        return (node[siz+x/64]&gt;&gt;(x&amp;63u))&amp;1;
    }
    
    int lower_bound(int x){
        if(count(x)) return x;
        int idx = siz + (x/64);
        x &amp;= 63;
        while(true){
            if(node[idx] &amp; ~(((1ull&lt;&lt;x)&lt;&lt;1) - 1ull)){
                x = __builtin_ctzll(node[idx] &amp; ~(((1ull&lt;&lt;x)&lt;&lt;1) - 1ull));
                if(idx &gt;= siz) return (idx-siz)*64+x;
                break;
            }
            if(idx == 0) return -1;
            idx--;
            x = idx &amp; 63;
            idx /= 64;
        }
        
        idx = idx*64 + x+1;
        while(idx &lt; siz) idx = idx*64 + __builtin_ctzll(node[idx])+1;
        return (idx-siz)*64 + __builtin_ctzll(node[idx]);
    }
    
    int less_bound(int x){
        if(count(x)) return x;
        int idx = siz + (x/64);
        x &amp;= 63;
        while(true){
            if(node[idx] &amp; ((1ull&lt;&lt;x) - 1ull)){
                x = 63 - __builtin_clzll(node[idx] &amp; ((1ull&lt;&lt;x) - 1ull));
                if(idx &gt;= siz) return (idx-siz)*64+x;
                break;
            }
            if(idx == 0) return -1;
            idx--;
            x = idx &amp; 63;
            idx /= 64;
        }
        
        idx = idx*64 + x+1;
        while(idx &lt; siz) idx = idx*64 + 64 - __builtin_clzll(node[idx]);
        return (idx-siz)*64 + 63 - __builtin_clzll(node[idx]);
    }
};
template&lt;typename S, auto op, auto e&gt;
struct segtree{
    int siz;
    vector&lt;S&gt; node;
    
    segtree() = default;
    segtree(unsigned n) : siz(std::bit_ceil(n)), node(siz*2, e()){}
    segtree(const vector&lt;S&gt;&amp; v){init(v);}
    void init(const vector&lt;S&gt;&amp; v){
        siz = bit_ceil(v.size()); node.resize(siz*2, e());
        for(int i = 0; i &lt; (int)v.size(); i++) node[i+siz] = v[i];
        for(int i = siz-1; i &gt;= 1; i--) node[i] = op(node[i*2], node[i*2+1]);
    }
    
    const S &amp;operator[](int pos) const {return node[pos+siz];}
    
    const S &amp;get(int pos) const {return node[pos+siz];}
    
    void set(int pos, const S &amp;x){
        assert(0 &lt;= pos &amp;&amp; pos &lt; siz);
        pos += siz;
        node[pos] = x;
        while(pos&gt;&gt;=1) node[pos] = op(node[pos&lt;&lt;1], node[(pos&lt;&lt;1)+1]);
    }
    
    void add(int pos, const S &amp;x){
        assert(0 &lt;= pos &amp;&amp; pos &lt; siz);
        pos += siz;
        node[pos] = op(node[pos], x);
        while(pos&gt;&gt;=1) node[pos] = op(node[pos], x);
    }
    
    S prod(int left, int right){
        left = max(0, left); right = min(right, siz);
        S l_ans = e(), r_ans = e();
        for(left+=siz, right+=siz; left &lt; right; left&gt;&gt;=1, right&gt;&gt;=1){
            if(left&amp;1) l_ans = op(l_ans, node[left++]);
            if(right&amp;1) r_ans = op(node[--right], r_ans);
        }
        return op(l_ans, r_ans);
    }
    
    S all_prod(){
        return node[1];
    }
};

} //namespace smkyb

template&lt;typename T, typename S, auto op, auto e&gt;
struct sort_segtree {
    struct SS {
        S ltor, rtol;
        SS() = default;
        SS(const S &amp;o) : ltor(o), rtol(o) {}
        SS(const S &amp;l, const S &amp;r) : ltor(l), rtol(r) {}
        static SS SS_op(const SS &amp;l, const SS &amp;r) {return SS{op(l.ltor, r.ltor), op(r.rtol, l.rtol)};}
        static SS SS_e() {return SS{e()};}
    };
    
    int n;
    smkyb::meldable_binary_trie&lt;T, SS, SS::SS_op, SS::SS_e&gt; *trie;
    smkyb::fastset fset;
    smkyb::segtree&lt;S, op, e&gt; seg;
    
    sort_segtree(int _n) : n(_n), fset(n+1), seg(n) {
        trie = new smkyb::meldable_binary_trie&lt;T, SS, SS::SS_op, SS::SS_e&gt;[n]{};
        for(int i = 0; i &lt;= n; i++) fset.insert(i);
    }
    sort_segtree(const vector&lt;pair&lt;T, S&gt;&gt; &amp;v) : n(v.size()), fset(n+1), seg(n) {
        trie = new smkyb::meldable_binary_trie&lt;T, SS, SS::SS_op, SS::SS_e&gt;[n];
        for(int i = 0; i &lt;= n; i++) fset.insert(i);
        for(int i = 0; i &lt; n; i++) trie[i] = smkyb::meldable_binary_trie&lt;T, SS, SS::SS_op, SS::SS_e&gt;(v[i].first, v[i].second);
        for(int i = 0; i &lt; n; i++) seg.set(i, v[i].second);
    }
    sort_segtree(sort_segtree&lt;T, S, op, e&gt; &amp;&amp;o) = default;
    
    void set(int i, T k, S x) {
        int l = fset.less_bound(i);
        int r = fset.lower_bound(i+1);
        if(l &lt; i){
            auto res = trie[l].split(i-l);
            trie[l] = move(res.first); trie[i] = move(res.second);
            fset.insert(i);
            seg.set(l, trie[l].rev ? trie[l].all_prod().rtol : trie[l].all_prod().ltor);
        }
        if(i+1 &lt; r){
            auto res = trie[i].split_one();
            trie[i+1] = move(res);
            fset.insert(i+1);
            seg.set(i+1, trie[i+1].rev ? trie[i+1].all_prod().rtol : trie[i+1].all_prod().ltor);
        }
        trie[i].init(k, x);
        seg.set(i, trie[i].rev ? trie[i].all_prod().rtol : trie[i].all_prod().ltor);
    }
    
    S prod(int l, int r) {
        int lbl = fset.less_bound(l);
        int lbr = lbl + trie[lbl].size();
        int rbl = fset.less_bound(r-1);
        int rbr = rbl + trie[rbl].size();
        if(lbl == l){
            if(rbr == r) return seg.prod(l, r);
            else {
                if(lbl == rbl) return (trie[lbl].rev ? trie[lbl].prod_r(r-l).rtol : trie[lbl].prod_l(r-l).ltor);
                else return op(seg.prod(l, rbl), (trie[rbl].rev ? trie[rbl].prod_r(r-rbl).rtol : trie[rbl].prod_l(r-rbl).ltor));
            }
        } else {
            if(rbr == r){
                if(lbl == rbl) return (trie[lbl].rev ? trie[lbl].prod_l(r-l).rtol : trie[lbl].prod_r(r-l).ltor);
                else return op((trie[lbl].rev ? trie[lbl].prod_l(lbr-l).rtol : trie[lbl].prod_r(lbr-l).ltor), seg.prod(lbr, r));
            } else {
                if(lbl == rbl) return (trie[lbl].rev ? trie[lbl].prod_lr(rbr-r, rbr-l).rtol : trie[lbl].prod_lr(l-lbl, r-lbl).ltor);
                else return op(op((trie[lbl].rev ? trie[lbl].prod_l(lbr-l).rtol : trie[lbl].prod_r(lbr-l).ltor), seg.prod(lbr, rbl)), (trie[rbl].rev ? trie[rbl].prod_r(r-rbl).rtol : trie[rbl].prod_l(r-rbl).ltor));
            }
        }
    }
    
    void sort(int l, int r) {
        int lb = fset.less_bound(l);
        if(lb &lt; l){
            auto res = trie[lb].split(l-lb);
            trie[lb] = move(res.first); trie[l] = move(res.second);
            fset.insert(l);
            seg.set(lb, trie[lb].rev ? trie[lb].all_prod().rtol : trie[lb].all_prod().ltor);
        }
        int rb = fset.less_bound(r);
        if(rb &lt; r){
            auto res = trie[rb].split(r-rb);
            trie[rb] = move(res.first); trie[r] = move(res.second);
            fset.insert(r);
            seg.set(r, trie[r].rev ? trie[r].all_prod().rtol : trie[r].all_prod().ltor);
        }
        lb = fset.lower_bound(l+1);
        while(lb &lt; r){
            auto res = smkyb::meldable_binary_trie&lt;T, SS, SS::SS_op, SS::SS_e&gt;::meld(trie[l], trie[lb]);
            trie[l] = smkyb::meldable_binary_trie&lt;T, SS, SS::SS_op, SS::SS_e&gt;(res);
            fset.erase(lb);
            seg.set(lb, e());
            lb = fset.lower_bound(lb);
        }
        trie[l].rev = false;
        seg.set(l, trie[l].all_prod().ltor);
    }
    
    void sort_rev(int l, int r) {
        int lb = fset.less_bound(l);
        if(lb &lt; l){
            auto res = trie[lb].split(l-lb);
            trie[lb] = move(res.first); trie[l] = move(res.second);
            fset.insert(l);
            seg.set(lb, trie[lb].rev ? trie[lb].all_prod().rtol : trie[lb].all_prod().ltor);
        }
        int rb = fset.less_bound(r);
        if(rb &lt; r){
            auto res = trie[rb].split(r-rb);
            trie[rb] = move(res.first); trie[r] = move(res.second);
            fset.insert(r);
            seg.set(r, trie[r].rev ? trie[r].all_prod().rtol : trie[r].all_prod().ltor);
        }
        lb = fset.lower_bound(l+1);
        while(lb &lt; r){
            auto res = smkyb::meldable_binary_trie&lt;T, SS, SS::SS_op, SS::SS_e&gt;::meld(trie[l], trie[lb]);
            trie[l] = smkyb::meldable_binary_trie&lt;T, SS, SS::SS_op, SS::SS_e&gt;(res);
            fset.erase(lb);
            seg.set(lb, e());
            lb = fset.lower_bound(lb);
        }
        trie[l].rev = true;
        seg.set(l, trie[l].all_prod().rtol);
    }
};
">copy</button>
<button id="button_copy_oneline" data-copy="namespace smkyb { template&lt;typename T, typename S, auto op, auto e&gt; struct meldable_binary_trie{ static_assert(is_unsigned_v&lt;T&gt;); static constexpr T one = 1; static constexpr int bit_width = sizeof(T) * 8; struct node_t{ T value; S sum; int width; int count; array&lt;node_t*, 4&gt; child; node_t() = default; node_t(T v, S s, int w, int c) : value(v), sum(s), width(w), count(c), child{&amp;nil, &amp;nil, &amp;nil, &amp;nil} {} node_t(T v, S s, int w, int c, node_t* c0, node_t* c1, node_t* c2, node_t* c3) : value(v), sum(s), width(w), count(c), child{c0, c1, c2, c3} {} static node_t nil; }; struct ref_node_t{ T val; bool exist; ref_node_t(T x, bool _e) : val{x}, exist{_e} {} }; struct Pool { int cnt = 0; constexpr static int SIZ = 1&lt;&lt;17; node_t *ptr = nullptr, *en = nullptr; vector&lt;node_t*&gt; reuse; Pool() { ptr = new node_t[SIZ]; en = ptr + SIZ; } node_t *get() { if(ptr == en) { if(!reuse.empty()) { auto ptr = reuse.back(); reuse.pop_back(); return ptr; } ptr = new node_t[SIZ]; en = ptr + SIZ; } return ptr++; } void push(node_t *p) {reuse.push_back(p);} }; static Pool pool; node_t* root; bool rev = false; template&lt;typename _Tp&gt; inline static int clz(_Tp x) { if constexpr(sizeof(_Tp) == 8ull) return __builtin_clzll(x); else return __builtin_clz(x); } inline static T mask(int l, int r) { if(r &gt;= bit_width){ if(l &gt;= bit_width) return 0; else return -(one&lt;&lt;l); } return (one&lt;&lt;r) - (one&lt;&lt;l); } inline static T masked(T v, int l, int r) { return mask(l, r) &amp; v; } inline static int diff_bit(T x, T y) { return ((bit_width-1 - clz(x^y))|1) + 1; } template&lt;typename... Args&gt; static inline node_t* make_node(Args ...args) { return &amp;((*pool.get()) = node_t(forward&lt;Args&gt;(args)...)); } public: meldable_binary_trie(){ root = make_node(0, e(), bit_width, 0); } meldable_binary_trie(T p, const S &amp;x){ root = make_node(p, x, bit_width, 1); } meldable_binary_trie(node_t *x){ root = x; } meldable_binary_trie&amp; operator=(meldable_binary_trie&amp;&amp; o) noexcept = default; meldable_binary_trie(meldable_binary_trie&amp;&amp; o) noexcept = default; void insert(T v, const S &amp;x) { node_t* pos = root; int bit = bit_width; node_t *route[65]; int route_cnt = 0; while(true){ T mv = masked(v, bit-pos-&gt;width, bit); T mnv = masked(pos-&gt;value, bit-pos-&gt;width, bit); if(mv != mnv){ route[route_cnt++] = pos; int diff = diff_bit(mv, mnv); int b = (mv&gt;&gt;(diff-2))&amp;3; int nb = (mnv&gt;&gt;(diff-2))&amp;3; node_t* inter = make_node(pos-&gt;value, pos-&gt;sum, pos-&gt;width-bit+diff, pos-&gt;count, pos-&gt;child[0], pos-&gt;child[1], pos-&gt;child[2], pos-&gt;child[3]); node_t* leaf = make_node(v, x, diff, 1); pos-&gt;width = bit-diff; pos-&gt;count++; pos-&gt;child = {&amp;node_t::nil, &amp;node_t::nil, &amp;node_t::nil, &amp;node_t::nil}; pos-&gt;child[b] = leaf; pos-&gt;child[nb] = inter; break; } else { pos-&gt;count++; bit -= pos-&gt;width; if(bit == 0) { pos-&gt;sum = x; break; } route[route_cnt++] = pos; int b = (v&gt;&gt;(bit-2))&amp;3; if(pos-&gt;child[b] == &amp;node_t::nil){ pos-&gt;child[b] = make_node(v, x, bit, 1); break; } pos = pos-&gt;child[b]; } } for(int i = route_cnt-1; i &gt;= 0; i--){ node_t *ptr = route[i]; ptr-&gt;sum = op(op(op(ptr-&gt;child[0]-&gt;sum, ptr-&gt;child[1]-&gt;sum), ptr-&gt;child[2]-&gt;sum), ptr-&gt;child[3]-&gt;sum); } } int count(T v) const { node_t* pos = root; int bit = bit_width; while(pos != &amp;node_t::nil){ T mv = masked(v, bit-pos-&gt;width, bit); T mnv = masked(pos-&gt;value, bit-pos-&gt;width, bit); if(mv != mnv) return 0; bit -= pos-&gt;width; if(bit == 0) return pos-&gt;count; pos = pos-&gt;child[(v&gt;&gt;(bit-2))&amp;3]; } return 0; } int size() const { return root-&gt;count; } static node_t *meld(meldable_binary_trie &amp;l, meldable_binary_trie &amp;r){ return meld(l.root, r.root); } static node_t *meld(node_t *l, node_t *r){ node_t *res = meld(l, r, bit_width); return res; } static node_t *meld(node_t *l, node_t *r, int bit){ if(l-&gt;count == 0){ return r; } if(r-&gt;count == 0){ return l; } T mlv = masked(l-&gt;value, min(bit-l-&gt;width, bit-r-&gt;width), bit); T mrv = masked(r-&gt;value, min(bit-l-&gt;width, bit-r-&gt;width), bit); if(mlv == mrv){ if(l-&gt;width == r-&gt;width){ l-&gt;count += r-&gt;count; if(bit == l-&gt;width){ l-&gt;sum = op(l-&gt;sum, r-&gt;sum); return l; } else { for(int i = 0; i &lt; 4; i++) l-&gt;child[i] = meld(l-&gt;child[i], r-&gt;child[i], bit - l-&gt;width); pool.push(r); } } else { if(l-&gt;width &gt; r-&gt;width) swap(l, r); l-&gt;count += r-&gt;count; bit -= l-&gt;width; r-&gt;width -= l-&gt;width; int b = (r-&gt;value&gt;&gt;(bit-2))&amp;3; l-&gt;child[b] = meld(l-&gt;child[b], r, bit); } } else { if(l-&gt;width &gt; r-&gt;width) swap(l, r); int diff = diff_bit(mlv, mrv); if(l-&gt;width &lt;= bit - diff){ l-&gt;count += r-&gt;count; r-&gt;width -= l-&gt;width; bit -= l-&gt;width; int b = (r-&gt;value&gt;&gt;(bit-2))&amp;3; l-&gt;child[b] = meld(l-&gt;child[b], r, bit); } else { node_t *ptr = make_node(l-&gt;value, l-&gt;sum, l-&gt;width-bit+diff, l-&gt;count, l-&gt;child[0], l-&gt;child[1], l-&gt;child[2], l-&gt;child[3]); memcpy(l-&gt;child.data(), node_t::nil.child.data(), sizeof(node_t*) * 4); r-&gt;width -= bit - diff; l-&gt;width = bit - diff; l-&gt;count += r-&gt;count; l-&gt;child[l-&gt;value&gt;&gt;(diff-2)&amp;3] = ptr; l-&gt;child[r-&gt;value&gt;&gt;(diff-2)&amp;3] = r; } } l-&gt;sum = op(op(op(l-&gt;child[0]-&gt;sum, l-&gt;child[1]-&gt;sum), l-&gt;child[2]-&gt;sum), l-&gt;child[3]-&gt;sum); return l; } pair&lt;meldable_binary_trie, meldable_binary_trie&gt; split(int p){ if(rev) p = root-&gt;count-p; auto res = split(root, p); if(rev){ meldable_binary_trie f(res.second), s(res.first); f.rev = true; s.rev = true; return make_pair(move(f), move(s)); } else return {meldable_binary_trie(res.first), meldable_binary_trie(res.second)}; } static pair&lt;node_t*, node_t*&gt; split(node_t *l, int p){ if(p == 0) return {&amp;node_t::nil, l}; if(p == l-&gt;count) return {l, &amp;node_t::nil}; int acc = 0; for (int i = 0; i &lt; 4; i++) { int c = l-&gt;child[i]-&gt;count; if (p &lt; acc + c) { auto sub = split(l-&gt;child[i], p - acc); node_t *ptr = make_node(l-&gt;value, e(), l-&gt;width, 0); l-&gt;child[i] = sub.first; ptr-&gt;child[i] = sub.second; for(int j = i+1; j &lt; 4; j++) ptr-&gt;child[j] = l-&gt;child[j]; for(int j = i+1; j &lt; 4; j++) l-&gt;child[j] = &amp;node_t::nil; l-&gt;count = 0; for(int j = 0; j &lt;= i; j++) l-&gt;count += l-&gt;child[j]-&gt;count; for(int j = i; j &lt; 4; j++) ptr-&gt;count += ptr-&gt;child[j]-&gt;count; l-&gt;sum = e(); for(int j = 0; j &lt;= i; j++) l-&gt;sum = op(l-&gt;sum, l-&gt;child[j]-&gt;sum); for(int j = i; j &lt; 4; j++) ptr-&gt;sum = op(ptr-&gt;sum, ptr-&gt;child[j]-&gt;sum); return {l, ptr}; } acc += c; } assert(false); } meldable_binary_trie split_one(){ if(rev){ meldable_binary_trie res(split_one_rev(root)); res.rev = true; return move(res); } else { return meldable_binary_trie(split_one(root)); } } node_t *split_one(node_t *l){ if(l-&gt;count == 1) return &amp;node_t::nil; l-&gt;count--; for(int i = 0; i &lt; 4; i++){ int c = l-&gt;child[i]-&gt;count; if(c == 0) continue; l-&gt;child[i] = split_one(l-&gt;child[i]); l-&gt;sum = e(); for(int j = i; j &lt; 4; j++) l-&gt;sum = op(l-&gt;sum, l-&gt;child[j]-&gt;sum); return l; } assert(false); } node_t *split_one_rev(node_t *l){ if(l-&gt;count == 1) return &amp;node_t::nil; l-&gt;count--; for(int i = 3; i &gt;= 0; i--){ int c = l-&gt;child[i]-&gt;count; if(c == 0) continue; l-&gt;child[i] = split_one_rev(l-&gt;child[i]); l-&gt;sum = e(); for(int j = 0; j &lt;= i; j++) l-&gt;sum = op(l-&gt;sum, l-&gt;child[j]-&gt;sum); return l; } assert(false); } S prod_l(int n) { return _prod_l(n, root); } S _prod_l(int n, node_t *pos) { S res = e(); for(int i = 0; i &lt; 4; i++){ if(n &gt;= pos-&gt;child[i]-&gt;count){ n -= pos-&gt;child[i]-&gt;count; res = op(res, pos-&gt;child[i]-&gt;sum); } else if(n &gt; 0) return op(res, _prod_l(n, pos-&gt;child[i])); } return res; } S prod_r(int n) { return _prod_r(n, root); } S _prod_r(int n, node_t *pos) { S res = e(); for(int i = 3; i &gt;= 0; i--){ if(n &gt;= pos-&gt;child[i]-&gt;count){ n -= pos-&gt;child[i]-&gt;count; res = op(pos-&gt;child[i]-&gt;sum, res); } else if(n &gt; 0) return op(_prod_r(n, pos-&gt;child[i]), res); } return res; } S prod_lr(int l, int r) { return _prod_lr(l, r, root); } S _prod_lr(int l, int r, node_t *pos) { int acc[5]; acc[0] = 0; acc[1] = acc[0] + pos-&gt;child[0]-&gt;count; acc[2] = acc[1] + pos-&gt;child[1]-&gt;count; acc[3] = acc[2] + pos-&gt;child[2]-&gt;count; acc[4] = acc[3] + pos-&gt;child[3]-&gt;count; S res = e(); for(int i = 0; i &lt; 4; i++){ if(r &lt;= acc[i]) break; else if(acc[i+1] &lt;= l) continue; else if(acc[i] &lt; l){ if(acc[i+1] &lt;= r) res = op(res, _prod_r(acc[i+1]-l, pos-&gt;child[i])); else res = op(res, _prod_lr(l-acc[i], r-acc[i], pos-&gt;child[i])); } else { if(acc[i+1] &lt;= r) res = op(res, pos-&gt;child[i]-&gt;sum); else res = op(res, _prod_l(r-acc[i], pos-&gt;child[i])); } } return res; } S all_prod() const {return root-&gt;sum;} void init(T p, const S &amp;x){ root = make_node(p, x, bit_width, 1); } static int get_size(node_t *ptr){ if(ptr == &amp;node_t::nil) return 0; int res = 1; for(int i = 0; i &lt; 4; i++) res += get_size(ptr-&gt;child[i]); return res; } }; template&lt;typename T, typename S, auto op, auto e&gt; typename meldable_binary_trie&lt;T, S, op, e&gt;::node_t meldable_binary_trie&lt;T, S, op, e&gt;::node_t::nil = meldable_binary_trie&lt;T, S, op, e&gt;::node_t(0, e(), bit_width, 0); template&lt;typename T, typename S, auto op, auto e&gt; typename meldable_binary_trie&lt;T, S, op, e&gt;::Pool meldable_binary_trie&lt;T, S, op, e&gt;::pool = meldable_binary_trie&lt;T, S, op, e&gt;::Pool(); struct fastset{ using ull = unsigned long long; using uint = unsigned; int siz; vector&lt;ull&gt; node; fastset(int _n){ int n = 1; while((n&lt;&lt;6) &lt; _n) n &lt;&lt;= 6; siz = (n+1)/63; node.resize((n+1)/63 + (_n+63)/64); } void insert(int x){ uint idx = siz + (x/64); x &amp;= 63; while(true){ if((node[idx]&gt;&gt;x) &amp; 1ull) return; node[idx] |= (1ull&lt;&lt;x); if(idx == 0) return; idx--; x = idx &amp; 63; idx /= 64; } } void erase(int x){ int idx = siz + (x/64); x &amp;= 63; while(true){ node[idx] &amp;= ~(1ull&lt;&lt;x); if(idx == 0 || node[idx]) return; idx--; x = idx &amp; 63; idx /= 64; } } bool count(int x) const { return (node[siz+x/64]&gt;&gt;(x&amp;63u))&amp;1; } int lower_bound(int x){ if(count(x)) return x; int idx = siz + (x/64); x &amp;= 63; while(true){ if(node[idx] &amp; ~(((1ull&lt;&lt;x)&lt;&lt;1) - 1ull)){ x = __builtin_ctzll(node[idx] &amp; ~(((1ull&lt;&lt;x)&lt;&lt;1) - 1ull)); if(idx &gt;= siz) return (idx-siz)*64+x; break; } if(idx == 0) return -1; idx--; x = idx &amp; 63; idx /= 64; } idx = idx*64 + x+1; while(idx &lt; siz) idx = idx*64 + __builtin_ctzll(node[idx])+1; return (idx-siz)*64 + __builtin_ctzll(node[idx]); } int less_bound(int x){ if(count(x)) return x; int idx = siz + (x/64); x &amp;= 63; while(true){ if(node[idx] &amp; ((1ull&lt;&lt;x) - 1ull)){ x = 63 - __builtin_clzll(node[idx] &amp; ((1ull&lt;&lt;x) - 1ull)); if(idx &gt;= siz) return (idx-siz)*64+x; break; } if(idx == 0) return -1; idx--; x = idx &amp; 63; idx /= 64; } idx = idx*64 + x+1; while(idx &lt; siz) idx = idx*64 + 64 - __builtin_clzll(node[idx]); return (idx-siz)*64 + 63 - __builtin_clzll(node[idx]); } }; template&lt;typename S, auto op, auto e&gt; struct segtree{ int siz; vector&lt;S&gt; node; segtree() = default; segtree(unsigned n) : siz(std::bit_ceil(n)), node(siz*2, e()){} segtree(const vector&lt;S&gt;&amp; v){init(v);} void init(const vector&lt;S&gt;&amp; v){ siz = bit_ceil(v.size()); node.resize(siz*2, e()); for(int i = 0; i &lt; (int)v.size(); i++) node[i+siz] = v[i]; for(int i = siz-1; i &gt;= 1; i--) node[i] = op(node[i*2], node[i*2+1]); } const S &amp;operator[](int pos) const {return node[pos+siz];} const S &amp;get(int pos) const {return node[pos+siz];} void set(int pos, const S &amp;x){ assert(0 &lt;= pos &amp;&amp; pos &lt; siz); pos += siz; node[pos] = x; while(pos&gt;&gt;=1) node[pos] = op(node[pos&lt;&lt;1], node[(pos&lt;&lt;1)+1]); } void add(int pos, const S &amp;x){ assert(0 &lt;= pos &amp;&amp; pos &lt; siz); pos += siz; node[pos] = op(node[pos], x); while(pos&gt;&gt;=1) node[pos] = op(node[pos], x); } S prod(int left, int right){ left = max(0, left); right = min(right, siz); S l_ans = e(), r_ans = e(); for(left+=siz, right+=siz; left &lt; right; left&gt;&gt;=1, right&gt;&gt;=1){ if(left&amp;1) l_ans = op(l_ans, node[left++]); if(right&amp;1) r_ans = op(node[--right], r_ans); } return op(l_ans, r_ans); } S all_prod(){ return node[1]; } }; }  template&lt;typename T, typename S, auto op, auto e&gt; struct sort_segtree { struct SS { S ltor, rtol; SS() = default; SS(const S &amp;o) : ltor(o), rtol(o) {} SS(const S &amp;l, const S &amp;r) : ltor(l), rtol(r) {} static SS SS_op(const SS &amp;l, const SS &amp;r) {return SS{op(l.ltor, r.ltor), op(r.rtol, l.rtol)};} static SS SS_e() {return SS{e()};} }; int n; smkyb::meldable_binary_trie&lt;T, SS, SS::SS_op, SS::SS_e&gt; *trie; smkyb::fastset fset; smkyb::segtree&lt;S, op, e&gt; seg; sort_segtree(int _n) : n(_n), fset(n+1), seg(n) { trie = new smkyb::meldable_binary_trie&lt;T, SS, SS::SS_op, SS::SS_e&gt;[n]{}; for(int i = 0; i &lt;= n; i++) fset.insert(i); } sort_segtree(const vector&lt;pair&lt;T, S&gt;&gt; &amp;v) : n(v.size()), fset(n+1), seg(n) { trie = new smkyb::meldable_binary_trie&lt;T, SS, SS::SS_op, SS::SS_e&gt;[n]; for(int i = 0; i &lt;= n; i++) fset.insert(i); for(int i = 0; i &lt; n; i++) trie[i] = smkyb::meldable_binary_trie&lt;T, SS, SS::SS_op, SS::SS_e&gt;(v[i].first, v[i].second); for(int i = 0; i &lt; n; i++) seg.set(i, v[i].second); } sort_segtree(sort_segtree&lt;T, S, op, e&gt; &amp;&amp;o) = default; void set(int i, T k, S x) { int l = fset.less_bound(i); int r = fset.lower_bound(i+1); if(l &lt; i){ auto res = trie[l].split(i-l); trie[l] = move(res.first); trie[i] = move(res.second); fset.insert(i); seg.set(l, trie[l].rev ? trie[l].all_prod().rtol : trie[l].all_prod().ltor); } if(i+1 &lt; r){ auto res = trie[i].split_one(); trie[i+1] = move(res); fset.insert(i+1); seg.set(i+1, trie[i+1].rev ? trie[i+1].all_prod().rtol : trie[i+1].all_prod().ltor); } trie[i].init(k, x); seg.set(i, trie[i].rev ? trie[i].all_prod().rtol : trie[i].all_prod().ltor); } S prod(int l, int r) { int lbl = fset.less_bound(l); int lbr = lbl + trie[lbl].size(); int rbl = fset.less_bound(r-1); int rbr = rbl + trie[rbl].size(); if(lbl == l){ if(rbr == r) return seg.prod(l, r); else { if(lbl == rbl) return (trie[lbl].rev ? trie[lbl].prod_r(r-l).rtol : trie[lbl].prod_l(r-l).ltor); else return op(seg.prod(l, rbl), (trie[rbl].rev ? trie[rbl].prod_r(r-rbl).rtol : trie[rbl].prod_l(r-rbl).ltor)); } } else { if(rbr == r){ if(lbl == rbl) return (trie[lbl].rev ? trie[lbl].prod_l(r-l).rtol : trie[lbl].prod_r(r-l).ltor); else return op((trie[lbl].rev ? trie[lbl].prod_l(lbr-l).rtol : trie[lbl].prod_r(lbr-l).ltor), seg.prod(lbr, r)); } else { if(lbl == rbl) return (trie[lbl].rev ? trie[lbl].prod_lr(rbr-r, rbr-l).rtol : trie[lbl].prod_lr(l-lbl, r-lbl).ltor); else return op(op((trie[lbl].rev ? trie[lbl].prod_l(lbr-l).rtol : trie[lbl].prod_r(lbr-l).ltor), seg.prod(lbr, rbl)), (trie[rbl].rev ? trie[rbl].prod_r(r-rbl).rtol : trie[rbl].prod_l(r-rbl).ltor)); } } } void sort(int l, int r) { int lb = fset.less_bound(l); if(lb &lt; l){ auto res = trie[lb].split(l-lb); trie[lb] = move(res.first); trie[l] = move(res.second); fset.insert(l); seg.set(lb, trie[lb].rev ? trie[lb].all_prod().rtol : trie[lb].all_prod().ltor); } int rb = fset.less_bound(r); if(rb &lt; r){ auto res = trie[rb].split(r-rb); trie[rb] = move(res.first); trie[r] = move(res.second); fset.insert(r); seg.set(r, trie[r].rev ? trie[r].all_prod().rtol : trie[r].all_prod().ltor); } lb = fset.lower_bound(l+1); while(lb &lt; r){ auto res = smkyb::meldable_binary_trie&lt;T, SS, SS::SS_op, SS::SS_e&gt;::meld(trie[l], trie[lb]); trie[l] = smkyb::meldable_binary_trie&lt;T, SS, SS::SS_op, SS::SS_e&gt;(res); fset.erase(lb); seg.set(lb, e()); lb = fset.lower_bound(lb); } trie[l].rev = false; seg.set(l, trie[l].all_prod().ltor); } void sort_rev(int l, int r) { int lb = fset.less_bound(l); if(lb &lt; l){ auto res = trie[lb].split(l-lb); trie[lb] = move(res.first); trie[l] = move(res.second); fset.insert(l); seg.set(lb, trie[lb].rev ? trie[lb].all_prod().rtol : trie[lb].all_prod().ltor); } int rb = fset.less_bound(r); if(rb &lt; r){ auto res = trie[rb].split(r-rb); trie[rb] = move(res.first); trie[r] = move(res.second); fset.insert(r); seg.set(r, trie[r].rev ? trie[r].all_prod().rtol : trie[r].all_prod().ltor); } lb = fset.lower_bound(l+1); while(lb &lt; r){ auto res = smkyb::meldable_binary_trie&lt;T, SS, SS::SS_op, SS::SS_e&gt;::meld(trie[l], trie[lb]); trie[l] = smkyb::meldable_binary_trie&lt;T, SS, SS::SS_op, SS::SS_e&gt;(res); fset.erase(lb); seg.set(lb, e()); lb = fset.lower_bound(lb); } trie[l].rev = true; seg.set(l, trie[l].all_prod().rtol); } };">copy_oneline</button>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script>
    marked.setOptions({ gfm: true, breaks: true, headerIds: true, mangle: false, highlight: (code, lang) => { if (lang && hljs.getLanguage(lang)) { return hljs.highlight(code, { language: lang }).value; } return hljs.highlightAuto(code).value; } });
    const mdContent = document.getElementById("md_content");
    if(mdContent){
        mdContent.innerHTML = marked.parse(mdContent.textContent);
        document.body.style.visibility = "visible";
    } else document.body.style.visibility = "visible";
    
    const copyButton = document.getElementById("button_copy")
    if(copyButton){
        copyButton.addEventListener("click", () => {
            const text = copyButton.dataset.copy;
            navigator.clipboard.writeText(text);
        })
    }
    const copyButtonOneline = document.getElementById("button_copy_oneline")
    if(copyButtonOneline){
        copyButtonOneline.addEventListener("click", () => {
            const text = copyButtonOneline.dataset.copy;
            navigator.clipboard.writeText(text);
        })
    }
    
</script>
</body>
</html>
