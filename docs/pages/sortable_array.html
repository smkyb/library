<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="google-site-verification" content="81kYLtl-Z1udi-AqoyIz8Pl38ya4DdHB4epvzWAECkI" />
<title>smkyb's library</title>
<link rel="preload" href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&display=swap" as="style" onload="this.rel='stylesheet'">
<link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.5.1/github-markdown.min.css" as="style" onload="this.rel='stylesheet'">
<link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css" as="style" onload="this.rel='stylesheet'">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/marked/marked.min.js" as="script">
<link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" as="script">
<link rel="preload" href="/library/docs/k-font/keifont.ttf" as="font" type="font/ttf" crossorigin>
<link rel="prefetch" href="/library/index.html">
<link rel="prefetch" href="/library/docs/library-checker.html">
<style>
    @font-face { font-family: "keifont"; src: url("/library/docs/k-font/keifont.ttf") format("truetype"); font-display: swap; }
    html { background: repeating-linear-gradient(-45deg, rgb(245, 245, 245), 40px, rgb(255, 255, 255) 40px, rgb(255, 255, 255) 70px); }
    h1 { font-size: 34px; }
    body { margin: 60px; margin-top: 60px; min-height: 100vh; font-family:'Noto Sans JP', Arial, sans-serif; font-size:17px; visibility: hidden; }
    .title { padding-top: 20px; font-family: keifont; font-weight: lighter; }
    .markdown-body { box-sizing: border-box; max-width: 900px; margin: 0 auto; background: #ffffff56; backdrop-filter: blur(3px); color: black; padding: 40px; }
    .markdown-body pre { padding: 16px; overflow: auto; }
    .button_sq button       { display: flex; font-size: 22px; flex-direction: column; gap: 20px; margin-bottom: 10px; padding: 10px; padding-left: 30px; padding-right: 30px; background-color: rgb(89, 158, 157); color: white; border: none; cursor: pointer; text-align: center; transition: 0.5s; }
    .button_sq button:hover { display: flex; font-size: 22px; flex-direction: column; gap: 20px; margin-bottom: 10px; padding: 10px; padding-left: 90px; padding-right: 90px; background-color: rgb(0, 67, 67);    color: white; border: none; cursor: pointer; text-align: center; transition: 0.5s; }
    .links { text-decoration: none; color: rgb(10, 56, 117); font-weight: bold; }
    #button_copy { display: flex; font-size: 14px; }
    #button_copy_oneline { display: flex; font-size: 14px; }
    #status_bar { display: flex; justify-content: center; position: fixed; height: 70px; width:100%; top: 0px; left: 0px; background-color: rgba(255, 255, 255, 0.258);  backdrop-filter: blur(15px); font-family: sans-serif; font-size: 20px; font-weight: bolder; align-content: center; color: white; z-index: 998244353; }
    #status_bar a { margin: 20px; text-decoration: none; color: rgb(63, 97, 144); }
</style>
</head>
<body>
<div id="status_bar">
    <a href="/library/index.html">home</a>
    <a href="/library/docs/about.html">about</a>
    <a href="/library/docs/link.html">link</a>
    <a href="/library/docs/library-checker.html">library-checker</a>
</div>
<article id="md_content" class="markdown-body">
# sortable_array
通常のセグメント木に加え，非負整数のキーによる区間ソートを行えるデータ構造です．  
可換性は要求しません．  
<br>
## コンストラクタ
```cpp
/*1*/ sortable_array&lt;T&gt; arr(int _n);
/*2*/ sortable_array&lt;T&gt; arr(vector&lt;T&gt; v);
```
* キーの型（非負整数）`T`   
を定義する必要があります．  
<br>
* * 1 : 初期値`e()`，長さ`_n`の数列`a`を作ります．  
* * 2 : 初期値が`v`，長さ`v.size()`の数列`a`を作ります．  
### 制約
* `a`の長さが正，かつ大きすぎない  
### 計算量
* O(n log n)
<br>
## set
```cpp
void set(int i, T k)
```
a[i]の，キーを`k`に変更します．
### 制約
* `0 &lt;= i &lt; _n`  
* `0 &lt;= k`  
### 計算量
`T`の最大値を`m`とすると，  
* O(log(m))
<br>
## sort
```cpp
void sort(int l, int r)
```
`a[l], a[l+1], ..., a[r-1]`をキーの昇順でソートします．
### 制約
* `0 &lt;= l &lt;= r &lt;= _n`
### 計算量
`T`の最大値を`m`とすると，  
* 償却O(log(m))
<br>
## sort_rev
```cpp
void sort_rev(int l, int r)
```
`a[l], a[l+1], ..., a[r-1]`をキーの降順でソートします．
### 制約
* `0 &lt;= l &lt;= r &lt;= _n`
### 計算量
`T`の最大値を`m`とすると，  
* 償却O(log(m))  
</article>

<button id="button_copy" data-copy="template&lt;typename T&gt;
struct sortable_array {
    struct fastset{
        using ull = unsigned long long;
        using uint = unsigned;
        
        int siz;
        vector&lt;ull&gt; node;
        
        fastset(int _n){
            int n = 1;
            while((n&lt;&lt;6) &lt; _n) n &lt;&lt;= 6;
            siz = (n+1)/63;
            node.resize((n+1)/63 + (_n+63)/64);
        }
        
        void insert(int x){
            uint idx = siz + (x/64);
            x &amp;= 63;
            while(true){
                if((node[idx]&gt;&gt;x) &amp; 1ull) return;
                node[idx] |= (1ull&lt;&lt;x);
                if(idx == 0) return;
                idx--;
                x = idx &amp; 63;
                idx /= 64;
            }
        }
        
        void erase(int x){
            int idx = siz + (x/64);
            x &amp;= 63;
            while(true){
                node[idx] &amp;= ~(1ull&lt;&lt;x);
                if(idx == 0 || node[idx]) return;
                idx--;
                x = idx &amp; 63;
                idx /= 64;
            }
        }
        
        bool count(int x) const {
            return (node[siz+x/64]&gt;&gt;(x&amp;63u))&amp;1;
        }
        
        int lower_bound(int x){
            if(count(x)) return x;
            int idx = siz + (x/64);
            x &amp;= 63;
            while(true){
                if(node[idx] &amp; ~(((1ull&lt;&lt;x)&lt;&lt;1) - 1ull)){
                    x = __builtin_ctzll(node[idx] &amp; ~(((1ull&lt;&lt;x)&lt;&lt;1) - 1ull));
                    if(idx &gt;= siz) return (idx-siz)*64+x;
                    break;
                }
                if(idx == 0) return -1;
                idx--;
                x = idx &amp; 63;
                idx /= 64;
            }
            
            idx = idx*64 + x+1;
            while(idx &lt; siz) idx = idx*64 + __builtin_ctzll(node[idx])+1;
            return (idx-siz)*64 + __builtin_ctzll(node[idx]);
        }
        
        int less_bound(int x){
            if(count(x)) return x;
            int idx = siz + (x/64);
            x &amp;= 63;
            while(true){
                if(node[idx] &amp; ((1ull&lt;&lt;x) - 1ull)){
                    x = 63 - __builtin_clzll(node[idx] &amp; ((1ull&lt;&lt;x) - 1ull));
                    if(idx &gt;= siz) return (idx-siz)*64+x;
                    break;
                }
                if(idx == 0) return -1;
                idx--;
                x = idx &amp; 63;
                idx /= 64;
            }
            
            idx = idx*64 + x+1;
            while(idx &lt; siz) idx = idx*64 + 64 - __builtin_clzll(node[idx]);
            return (idx-siz)*64 + 63 - __builtin_clzll(node[idx]);
        }
    };
    
    struct binary_trie{
        static_assert(is_unsigned_v&lt;T&gt;);
        
        static constexpr T one = 1;
        static constexpr int bit_width = sizeof(T) * 8;
        
        struct node_t{
            T value;
            int width;
            int count;
            array&lt;node_t*, 4&gt; child;
            node_t() = default;
            node_t(T v, int w, int c) : value(v), width(w), count(c), child{&amp;nil, &amp;nil, &amp;nil, &amp;nil} {}
            node_t(T v, int w, int c, node_t* c0, node_t* c1, node_t* c2, node_t* c3) : value(v), width(w), count(c), child{c0, c1, c2, c3} {}
            static node_t nil;
        };
        
        struct ref_node_t{
            T val;
            bool exist;
            ref_node_t(T x, bool _e) : val{x}, exist{_e} {}
        };
        
        struct Pool {
            int cnt = 0;
            constexpr static int SIZ = 1&lt;&lt;17;
            node_t *ptr = nullptr, *en = nullptr;
            vector&lt;node_t*&gt; reuse;
            Pool() {
                ptr = new node_t[SIZ];
                en = ptr + SIZ;
            }
            node_t *get() {
                if(ptr == en) {
                    if(!reuse.empty()) {
                        auto ptr = reuse.back();
                        reuse.pop_back();
                        return ptr;
                    }
                    ptr = new node_t[SIZ];
                    en = ptr + SIZ;
                }
                return ptr++;
            }
            void push(node_t *p) {reuse.push_back(p);}
        };
        
        static Pool pool;
        node_t* root;
        bool rev = false;
        
        template&lt;typename _Tp&gt;
        inline static int clz(_Tp x) {
            if constexpr(sizeof(_Tp) == 8ull) return __builtin_clzll(x);
            else return __builtin_clz(x);
        }
        
        inline static T mask(int l, int r) {
            if(r &gt;= bit_width) return -(one&lt;&lt;l);
            return (one&lt;&lt;r) - (one&lt;&lt;l);
        }
        
        inline static T masked(T v, int l, int r) {
            return mask(l, r) &amp; v;
        }
        
        inline static int diff_bit(T x, T y) {
            return ((bit_width-1 - clz(x^y))|1) + 1;
        }
        
        //value, sum, width, count, child
        template&lt;typename... Args&gt;
        static inline node_t* make_node(Args ...args) {
            return &amp;((*pool.get()) = node_t(forward&lt;Args&gt;(args)...));
        }
        
        public:
        
        binary_trie(){
            root = make_node(0, bit_width, 0);
        }
        binary_trie(T p){
            root = make_node(p, bit_width, 1);
        }
        binary_trie(node_t *x){
            root = x;
        }
        
        binary_trie&amp; operator=(binary_trie&amp;&amp; o) noexcept = default;
        
        binary_trie(binary_trie&amp;&amp; o) noexcept = default;
        
        const T operator[](int k) const {
            k++;
            node_t* pos = root;
            int bit = bit_width;
            while(true){
                bit -= pos-&gt;width;
                if(bit == 0) return pos-&gt;value;
                auto &amp;child = pos-&gt;child;
                if(k &lt;= child[0]-&gt;count){
                    pos = child[0];
                } else {
                    k -= child[0]-&gt;count;
                    if(k &lt;= child[1]-&gt;count){
                        pos = child[1];
                    } else {
                        k -= child[1]-&gt;count;
                        if(k &lt;= child[2]-&gt;count){
                            pos = child[2];
                        } else {
                            k -= child[2]-&gt;count;
                            pos = child[3];
                        }
                    }
                }
            }
        }
        
        int size() const {
            return root-&gt;count;
        }
        
        static node_t *meld(binary_trie &amp;l, binary_trie &amp;r){
            return meld(l.root, r.root);
        }
        static node_t *meld(node_t *l, node_t *r){
            node_t *res = meld(l, r, bit_width);
            return res;
        }
        static node_t *meld(node_t *l, node_t *r, int bit){
            if(l-&gt;count == 0){
                return r;
            }
            if(r-&gt;count == 0){
                return l;
            }
            T mlv = masked(l-&gt;value, min(bit-l-&gt;width, bit-r-&gt;width), bit);
            T mrv = masked(r-&gt;value, min(bit-l-&gt;width, bit-r-&gt;width), bit);
            if(mlv == mrv){
                if(l-&gt;width == r-&gt;width){
                    l-&gt;count += r-&gt;count;
                    if(bit == l-&gt;width){
                        return l;
                    } else {
                        for(int i = 0; i &lt; 4; i++) l-&gt;child[i] = meld(l-&gt;child[i], r-&gt;child[i], bit - l-&gt;width);
                        pool.push(r);
                    }
                } else {
                    if(l-&gt;width &gt; r-&gt;width) swap(l, r);
                    l-&gt;count += r-&gt;count;
                    bit -= l-&gt;width;
                    r-&gt;width -= l-&gt;width;
                    int b = (r-&gt;value&gt;&gt;(bit-2))&amp;3;
                    l-&gt;child[b] = meld(l-&gt;child[b], r, bit);
                }
            } else {
                if(l-&gt;width &gt; r-&gt;width) swap(l, r);
                int diff = diff_bit(mlv, mrv);
                if(l-&gt;width &lt;= bit - diff){
                    l-&gt;count += r-&gt;count;
                    r-&gt;width -= l-&gt;width;
                    bit -= l-&gt;width;
                    int b = (r-&gt;value&gt;&gt;(bit-2))&amp;3;
                    l-&gt;child[b] = meld(l-&gt;child[b], r, bit);
                } else {
                    node_t *ptr = make_node(l-&gt;value, l-&gt;width-bit+diff, l-&gt;count, l-&gt;child[0], l-&gt;child[1], l-&gt;child[2], l-&gt;child[3]);
                    memcpy(l-&gt;child.data(), node_t::nil.child.data(), sizeof(node_t*) * 4);
                    r-&gt;width -= bit - diff;
                    l-&gt;width = bit - diff;
                    l-&gt;count += r-&gt;count;
                    l-&gt;child[l-&gt;value&gt;&gt;(diff-2)&amp;3] = ptr;
                    l-&gt;child[r-&gt;value&gt;&gt;(diff-2)&amp;3] = r;
                }
            }
            return l;
        }
        
        pair&lt;binary_trie, binary_trie&gt; split(int p){
            if(rev) p = root-&gt;count-p;
            auto res = split(root, p);
            if(rev){
                binary_trie f(res.second), s(res.first);
                f.rev = true; s.rev = true;
                return make_pair(move(f), move(s));
            } else return {binary_trie(res.first), binary_trie(res.second)};
        }
        
        static pair&lt;node_t*, node_t*&gt; split(node_t *l, int p){
            if(p == 0) return {&amp;node_t::nil, l};
            if(p == l-&gt;count) return {l, &amp;node_t::nil};
            int acc = 0;
            
            for (int i = 0; i &lt; 4; i++) {
                int c = l-&gt;child[i]-&gt;count;
                if (p &lt; acc + c) {
                    auto sub = split(l-&gt;child[i], p - acc);
                    
                    node_t *ptr = make_node(l-&gt;value, l-&gt;width, 0);
                    
                    l-&gt;child[i] = sub.first;
                    ptr-&gt;child[i] = sub.second;
                    for(int j = i+1; j &lt; 4; j++) ptr-&gt;child[j] = l-&gt;child[j];
                    for(int j = i+1; j &lt; 4; j++) l-&gt;child[j] = &amp;node_t::nil;
                    
                    l-&gt;count = 0;
                    for(int j = 0; j &lt;= i; j++) l-&gt;count += l-&gt;child[j]-&gt;count;
                    for(int j = i; j &lt; 4; j++) ptr-&gt;count += ptr-&gt;child[j]-&gt;count;
                    
                    return {l, ptr};
                }
                acc += c;
            }
            assert(false);
        }
        
        binary_trie split_one(){
            if(rev){
                binary_trie res(split_one_rev(root));
                res.rev = true;
                return move(res);
            } else {
                return binary_trie(split_one(root));
            }
        }
        node_t *split_one(node_t *l){
            if(l-&gt;count == 1) return &amp;node_t::nil;
            
            l-&gt;count--;
            for(int i = 0; i &lt; 4; i++){
                int c = l-&gt;child[i]-&gt;count;
                if(c == 0) continue;
                l-&gt;child[i] = split_one(l-&gt;child[i]);
                return l;
            }
            assert(false);
        }
        node_t *split_one_rev(node_t *l){
            if(l-&gt;count == 1) return &amp;node_t::nil;
            
            l-&gt;count--;
            for(int i = 3; i &gt;= 0; i--){
                int c = l-&gt;child[i]-&gt;count;
                if(c == 0) continue;
                l-&gt;child[i] = split_one_rev(l-&gt;child[i]);
                return l;
            }
            assert(false);
        }
        
        void init(T p){
            root = make_node(p, bit_width, 1);
        }
        
        static int get_size(node_t *ptr){
            if(ptr == &amp;node_t::nil) return 0;
            int res = 1;
            for(int i = 0; i &lt; 4; i++) res += get_size(ptr-&gt;child[i]);
            return res;
        }
    };
    
    private:
    int n;
    binary_trie *trie;
    fastset fset;
    
    public:
    sortable_array(int _n) : n(_n), fset(n+1) {
        trie = new binary_trie[n]{};
        for(int i = 0; i &lt;= n; i++) fset.insert(i);
    }
    sortable_array(const vector&lt;T&gt; &amp;v) : n(v.size()), fset(n+1) {
        trie = new binary_trie[n];
        for(int i = 0; i &lt;= n; i++) fset.insert(i);
        for(int i = 0; i &lt; n; i++) trie[i] = binary_trie(v[i]);
    }
    sortable_array(sortable_array&lt;T&gt; &amp;&amp;o) = default;
    
    void set(int i, T k){
        int l = fset.less_bound(i);
        int r = fset.lower_bound(i+1);
        if(l &lt; i){
            auto res = trie[l].split(i-l);
            trie[l] = move(res.first); trie[i] = move(res.second);
            fset.insert(i);
        }
        if(i+1 &lt; r){
            auto res = trie[i].split_one();
            trie[i+1] = move(res);
            fset.insert(i+1);
        }
        trie[i].init(k);
    }
    
    T get(int i){
        int p = fset.less_bound(i);
        i -= p;
        return trie[p].rev ? trie[p][trie[p].size()-i-1] : trie[p][i];
    }
    
    void sort(int l, int r) {
        int lb = fset.less_bound(l);
        if(lb &lt; l){
            auto res = trie[lb].split(l-lb);
            trie[lb] = move(res.first); trie[l] = move(res.second);
            fset.insert(l);
        }
        int rb = fset.less_bound(r);
        if(rb &lt; r){
            auto res = trie[rb].split(r-rb);
            trie[rb] = move(res.first); trie[r] = move(res.second);
            fset.insert(r);
        }
        lb = fset.lower_bound(l+1);
        while(lb &lt; r){
            auto res = binary_trie::meld(trie[l], trie[lb]);
            trie[l] = binary_trie(res);
            fset.erase(lb);
            lb = fset.lower_bound(lb);
        }
        trie[l].rev = false;
    }
    
    void sort_rev(int l, int r) {
        int lb = fset.less_bound(l);
        if(lb &lt; l){
            auto res = trie[lb].split(l-lb);
            trie[lb] = move(res.first); trie[l] = move(res.second);
            fset.insert(l);
        }
        int rb = fset.less_bound(r);
        if(rb &lt; r){
            auto res = trie[rb].split(r-rb);
            trie[rb] = move(res.first); trie[r] = move(res.second);
            fset.insert(r);
        }
        lb = fset.lower_bound(l+1);
        while(lb &lt; r){
            auto res = binary_trie::meld(trie[l], trie[lb]);
            trie[l] = binary_trie(res);
            fset.erase(lb);
            lb = fset.lower_bound(lb);
        }
        trie[l].rev = true;
    }
};
template&lt;typename T&gt; typename sortable_array&lt;T&gt;::binary_trie::node_t sortable_array&lt;T&gt;::binary_trie::node_t::nil = node_t(0, bit_width, 0, &amp;node_t::nil, &amp;node_t::nil, &amp;node_t::nil, &amp;node_t::nil);
template&lt;typename T&gt; typename sortable_array&lt;T&gt;::binary_trie::Pool sortable_array&lt;T&gt;::binary_trie::pool = Pool();
">copy</button>
<button id="button_copy_oneline" data-copy="template&lt;typename T&gt; struct sortable_array { struct fastset{ using ull = unsigned long long; using uint = unsigned; int siz; vector&lt;ull&gt; node; fastset(int _n){ int n = 1; while((n&lt;&lt;6) &lt; _n) n &lt;&lt;= 6; siz = (n+1)/63; node.resize((n+1)/63 + (_n+63)/64); } void insert(int x){ uint idx = siz + (x/64); x &amp;= 63; while(true){ if((node[idx]&gt;&gt;x) &amp; 1ull) return; node[idx] |= (1ull&lt;&lt;x); if(idx == 0) return; idx--; x = idx &amp; 63; idx /= 64; } } void erase(int x){ int idx = siz + (x/64); x &amp;= 63; while(true){ node[idx] &amp;= ~(1ull&lt;&lt;x); if(idx == 0 || node[idx]) return; idx--; x = idx &amp; 63; idx /= 64; } } bool count(int x) const { return (node[siz+x/64]&gt;&gt;(x&amp;63u))&amp;1; } int lower_bound(int x){ if(count(x)) return x; int idx = siz + (x/64); x &amp;= 63; while(true){ if(node[idx] &amp; ~(((1ull&lt;&lt;x)&lt;&lt;1) - 1ull)){ x = __builtin_ctzll(node[idx] &amp; ~(((1ull&lt;&lt;x)&lt;&lt;1) - 1ull)); if(idx &gt;= siz) return (idx-siz)*64+x; break; } if(idx == 0) return -1; idx--; x = idx &amp; 63; idx /= 64; } idx = idx*64 + x+1; while(idx &lt; siz) idx = idx*64 + __builtin_ctzll(node[idx])+1; return (idx-siz)*64 + __builtin_ctzll(node[idx]); } int less_bound(int x){ if(count(x)) return x; int idx = siz + (x/64); x &amp;= 63; while(true){ if(node[idx] &amp; ((1ull&lt;&lt;x) - 1ull)){ x = 63 - __builtin_clzll(node[idx] &amp; ((1ull&lt;&lt;x) - 1ull)); if(idx &gt;= siz) return (idx-siz)*64+x; break; } if(idx == 0) return -1; idx--; x = idx &amp; 63; idx /= 64; } idx = idx*64 + x+1; while(idx &lt; siz) idx = idx*64 + 64 - __builtin_clzll(node[idx]); return (idx-siz)*64 + 63 - __builtin_clzll(node[idx]); } }; struct binary_trie{ static_assert(is_unsigned_v&lt;T&gt;); static constexpr T one = 1; static constexpr int bit_width = sizeof(T) * 8; struct node_t{ T value; int width; int count; array&lt;node_t*, 4&gt; child; node_t() = default; node_t(T v, int w, int c) : value(v), width(w), count(c), child{&amp;nil, &amp;nil, &amp;nil, &amp;nil} {} node_t(T v, int w, int c, node_t* c0, node_t* c1, node_t* c2, node_t* c3) : value(v), width(w), count(c), child{c0, c1, c2, c3} {} static node_t nil; }; struct ref_node_t{ T val; bool exist; ref_node_t(T x, bool _e) : val{x}, exist{_e} {} }; struct Pool { int cnt = 0; constexpr static int SIZ = 1&lt;&lt;17; node_t *ptr = nullptr, *en = nullptr; vector&lt;node_t*&gt; reuse; Pool() { ptr = new node_t[SIZ]; en = ptr + SIZ; } node_t *get() { if(ptr == en) { if(!reuse.empty()) { auto ptr = reuse.back(); reuse.pop_back(); return ptr; } ptr = new node_t[SIZ]; en = ptr + SIZ; } return ptr++; } void push(node_t *p) {reuse.push_back(p);} }; static Pool pool; node_t* root; bool rev = false; template&lt;typename _Tp&gt; inline static int clz(_Tp x) { if constexpr(sizeof(_Tp) == 8ull) return __builtin_clzll(x); else return __builtin_clz(x); } inline static T mask(int l, int r) { if(r &gt;= bit_width) return -(one&lt;&lt;l); return (one&lt;&lt;r) - (one&lt;&lt;l); } inline static T masked(T v, int l, int r) { return mask(l, r) &amp; v; } inline static int diff_bit(T x, T y) { return ((bit_width-1 - clz(x^y))|1) + 1; } template&lt;typename... Args&gt; static inline node_t* make_node(Args ...args) { return &amp;((*pool.get()) = node_t(forward&lt;Args&gt;(args)...)); } public: binary_trie(){ root = make_node(0, bit_width, 0); } binary_trie(T p){ root = make_node(p, bit_width, 1); } binary_trie(node_t *x){ root = x; } binary_trie&amp; operator=(binary_trie&amp;&amp; o) noexcept = default; binary_trie(binary_trie&amp;&amp; o) noexcept = default; const T operator[](int k) const { k++; node_t* pos = root; int bit = bit_width; while(true){ bit -= pos-&gt;width; if(bit == 0) return pos-&gt;value; auto &amp;child = pos-&gt;child; if(k &lt;= child[0]-&gt;count){ pos = child[0]; } else { k -= child[0]-&gt;count; if(k &lt;= child[1]-&gt;count){ pos = child[1]; } else { k -= child[1]-&gt;count; if(k &lt;= child[2]-&gt;count){ pos = child[2]; } else { k -= child[2]-&gt;count; pos = child[3]; } } } } } int size() const { return root-&gt;count; } static node_t *meld(binary_trie &amp;l, binary_trie &amp;r){ return meld(l.root, r.root); } static node_t *meld(node_t *l, node_t *r){ node_t *res = meld(l, r, bit_width); return res; } static node_t *meld(node_t *l, node_t *r, int bit){ if(l-&gt;count == 0){ return r; } if(r-&gt;count == 0){ return l; } T mlv = masked(l-&gt;value, min(bit-l-&gt;width, bit-r-&gt;width), bit); T mrv = masked(r-&gt;value, min(bit-l-&gt;width, bit-r-&gt;width), bit); if(mlv == mrv){ if(l-&gt;width == r-&gt;width){ l-&gt;count += r-&gt;count; if(bit == l-&gt;width){ return l; } else { for(int i = 0; i &lt; 4; i++) l-&gt;child[i] = meld(l-&gt;child[i], r-&gt;child[i], bit - l-&gt;width); pool.push(r); } } else { if(l-&gt;width &gt; r-&gt;width) swap(l, r); l-&gt;count += r-&gt;count; bit -= l-&gt;width; r-&gt;width -= l-&gt;width; int b = (r-&gt;value&gt;&gt;(bit-2))&amp;3; l-&gt;child[b] = meld(l-&gt;child[b], r, bit); } } else { if(l-&gt;width &gt; r-&gt;width) swap(l, r); int diff = diff_bit(mlv, mrv); if(l-&gt;width &lt;= bit - diff){ l-&gt;count += r-&gt;count; r-&gt;width -= l-&gt;width; bit -= l-&gt;width; int b = (r-&gt;value&gt;&gt;(bit-2))&amp;3; l-&gt;child[b] = meld(l-&gt;child[b], r, bit); } else { node_t *ptr = make_node(l-&gt;value, l-&gt;width-bit+diff, l-&gt;count, l-&gt;child[0], l-&gt;child[1], l-&gt;child[2], l-&gt;child[3]); memcpy(l-&gt;child.data(), node_t::nil.child.data(), sizeof(node_t*) * 4); r-&gt;width -= bit - diff; l-&gt;width = bit - diff; l-&gt;count += r-&gt;count; l-&gt;child[l-&gt;value&gt;&gt;(diff-2)&amp;3] = ptr; l-&gt;child[r-&gt;value&gt;&gt;(diff-2)&amp;3] = r; } } return l; } pair&lt;binary_trie, binary_trie&gt; split(int p){ if(rev) p = root-&gt;count-p; auto res = split(root, p); if(rev){ binary_trie f(res.second), s(res.first); f.rev = true; s.rev = true; return make_pair(move(f), move(s)); } else return {binary_trie(res.first), binary_trie(res.second)}; } static pair&lt;node_t*, node_t*&gt; split(node_t *l, int p){ if(p == 0) return {&amp;node_t::nil, l}; if(p == l-&gt;count) return {l, &amp;node_t::nil}; int acc = 0; for (int i = 0; i &lt; 4; i++) { int c = l-&gt;child[i]-&gt;count; if (p &lt; acc + c) { auto sub = split(l-&gt;child[i], p - acc); node_t *ptr = make_node(l-&gt;value, l-&gt;width, 0); l-&gt;child[i] = sub.first; ptr-&gt;child[i] = sub.second; for(int j = i+1; j &lt; 4; j++) ptr-&gt;child[j] = l-&gt;child[j]; for(int j = i+1; j &lt; 4; j++) l-&gt;child[j] = &amp;node_t::nil; l-&gt;count = 0; for(int j = 0; j &lt;= i; j++) l-&gt;count += l-&gt;child[j]-&gt;count; for(int j = i; j &lt; 4; j++) ptr-&gt;count += ptr-&gt;child[j]-&gt;count; return {l, ptr}; } acc += c; } assert(false); } binary_trie split_one(){ if(rev){ binary_trie res(split_one_rev(root)); res.rev = true; return move(res); } else { return binary_trie(split_one(root)); } } node_t *split_one(node_t *l){ if(l-&gt;count == 1) return &amp;node_t::nil; l-&gt;count--; for(int i = 0; i &lt; 4; i++){ int c = l-&gt;child[i]-&gt;count; if(c == 0) continue; l-&gt;child[i] = split_one(l-&gt;child[i]); return l; } assert(false); } node_t *split_one_rev(node_t *l){ if(l-&gt;count == 1) return &amp;node_t::nil; l-&gt;count--; for(int i = 3; i &gt;= 0; i--){ int c = l-&gt;child[i]-&gt;count; if(c == 0) continue; l-&gt;child[i] = split_one_rev(l-&gt;child[i]); return l; } assert(false); } void init(T p){ root = make_node(p, bit_width, 1); } static int get_size(node_t *ptr){ if(ptr == &amp;node_t::nil) return 0; int res = 1; for(int i = 0; i &lt; 4; i++) res += get_size(ptr-&gt;child[i]); return res; } }; private: int n; binary_trie *trie; fastset fset; public: sortable_array(int _n) : n(_n), fset(n+1) { trie = new binary_trie[n]{}; for(int i = 0; i &lt;= n; i++) fset.insert(i); } sortable_array(const vector&lt;T&gt; &amp;v) : n(v.size()), fset(n+1) { trie = new binary_trie[n]; for(int i = 0; i &lt;= n; i++) fset.insert(i); for(int i = 0; i &lt; n; i++) trie[i] = binary_trie(v[i]); } sortable_array(sortable_array&lt;T&gt; &amp;&amp;o) = default; void set(int i, T k){ int l = fset.less_bound(i); int r = fset.lower_bound(i+1); if(l &lt; i){ auto res = trie[l].split(i-l); trie[l] = move(res.first); trie[i] = move(res.second); fset.insert(i); } if(i+1 &lt; r){ auto res = trie[i].split_one(); trie[i+1] = move(res); fset.insert(i+1); } trie[i].init(k); } T get(int i){ int p = fset.less_bound(i); i -= p; return trie[p].rev ? trie[p][trie[p].size()-i-1] : trie[p][i]; } void sort(int l, int r) { int lb = fset.less_bound(l); if(lb &lt; l){ auto res = trie[lb].split(l-lb); trie[lb] = move(res.first); trie[l] = move(res.second); fset.insert(l); } int rb = fset.less_bound(r); if(rb &lt; r){ auto res = trie[rb].split(r-rb); trie[rb] = move(res.first); trie[r] = move(res.second); fset.insert(r); } lb = fset.lower_bound(l+1); while(lb &lt; r){ auto res = binary_trie::meld(trie[l], trie[lb]); trie[l] = binary_trie(res); fset.erase(lb); lb = fset.lower_bound(lb); } trie[l].rev = false; } void sort_rev(int l, int r) { int lb = fset.less_bound(l); if(lb &lt; l){ auto res = trie[lb].split(l-lb); trie[lb] = move(res.first); trie[l] = move(res.second); fset.insert(l); } int rb = fset.less_bound(r); if(rb &lt; r){ auto res = trie[rb].split(r-rb); trie[rb] = move(res.first); trie[r] = move(res.second); fset.insert(r); } lb = fset.lower_bound(l+1); while(lb &lt; r){ auto res = binary_trie::meld(trie[l], trie[lb]); trie[l] = binary_trie(res); fset.erase(lb); lb = fset.lower_bound(lb); } trie[l].rev = true; } }; template&lt;typename T&gt; typename sortable_array&lt;T&gt;::binary_trie::node_t sortable_array&lt;T&gt;::binary_trie::node_t::nil = node_t(0, bit_width, 0, &amp;node_t::nil, &amp;node_t::nil, &amp;node_t::nil, &amp;node_t::nil); template&lt;typename T&gt; typename sortable_array&lt;T&gt;::binary_trie::Pool sortable_array&lt;T&gt;::binary_trie::pool = Pool();">copy_oneline</button>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script>
    marked.setOptions({ gfm: true, breaks: true, headerIds: true, mangle: false, highlight: (code, lang) => { if (lang && hljs.getLanguage(lang)) { return hljs.highlight(code, { language: lang }).value; } return hljs.highlightAuto(code).value; } });
    const mdContent = document.getElementById("md_content");
    if(mdContent){
        mdContent.innerHTML = marked.parse(mdContent.textContent);
        document.body.style.visibility = "visible";
    } else document.body.style.visibility = "visible";
    
    const copyButton = document.getElementById("button_copy")
    if(copyButton){
        copyButton.addEventListener("click", () => {
            const text = copyButton.dataset.copy;
            navigator.clipboard.writeText(text);
        })
    }
    const copyButtonOneline = document.getElementById("button_copy_oneline")
    if(copyButtonOneline){
        copyButtonOneline.addEventListener("click", () => {
            const text = copyButtonOneline.dataset.copy;
            navigator.clipboard.writeText(text);
        })
    }
    
</script>
</body>
</html>
