<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>smkyb's library</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&display=swap">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.5.1/github-markdown.min.css"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
<style>
    body { margin: 60px; font-family:'Noto Sans JP', Arial, sans-serif; font-size:large; }
    .markdown-body { box-sizing: border-box; max-width: 900px; margin: 0 auto; }
    .markdown-body pre { padding: 16px; overflow: auto; }
    .button_sq button       { display: flex; font-size: 22px; flex-direction: column; gap: 20px; margin-bottom: 10px; padding: 10px; padding-left: 30px; padding-right: 30px; background-color: rgb(89, 158, 157); color: white; border: none; cursor: pointer; text-align: center; transition: 0.5s; }
    .button_sq button:hover { display: flex; font-size: 22px; flex-direction: column; gap: 20px; margin-bottom: 10px; padding: 10px; padding-left: 90px; padding-right: 90px; background-color: rgb(0, 67, 67);    color: white; border: none; cursor: pointer; text-align: center; transition: 0.5s; }
    #button_copy { display: flex; font-size: 14px; }
    #button_copy_oneline { display: flex; font-size: 14px; }
</style>
</head>
<body>
<article id="md_content" class="markdown-body">
***頂点クエリのみに対応しています***  
また、非常に使いにくい形式になっていると思われます  
# HLD
木に対するパスクエリ、部分木クエリなどを解きます。（セグ木とかを使えるもののみ）  
<br>
## 下準備  
・node_typeをいじる  
<br>
## コンストラクタ
```cpp
//デフォルトで、
hld&lt;typename S, auto op /*以下省略可能*/ , auto e = []{return S();}, typename F = int, auto mapping = []{}, auto composition = []{}, auto id = []{}&gt; AAA(int _n, int _r = random)
```
**・ 概要 :** S, op, eはACLのsegtreeのようなもの  
_nは頂点数  
_rは根（部分木クエリを使うときは指定する）
<br>
## 構築
```cpp
void add_edge(int u, int v)
```
add_edgeで無向グラフを追加し、  
```cpp
void build(vector&lt;S&gt; v)
```
その後、引数に「頂点に書かれている値」を渡し、buildする  
<br>
## 機能
```cpp
//セグ木を用いた場合、Θ(log^2 N)
S prod(int l, int r);
//同様で、Θ(log N)
S prod(int r);
S get(int p);
void set(int p, S x);
//Θ(log N)
int lca(int l, int r);
int dist(int l, int r);

//- 以下あれば -
//セグ木で、Θ(log^2 N)
void apply(int l, int r, F x);
//同様で、Θ(log N)
void apply(int r, F x);
void add(int p, S x);
```
</article>
<button id="button_copy" data-copy="template&lt;typename S, auto op, auto e = []{return S();}, typename F = int, auto mapping = []{}, auto composition = []{}, auto id = []{}&gt;
struct hld{
    using node_type = segtree&lt;S, op, e&gt;;
    //using node_type = lazy_segtree&lt;S, op, e, F, mapping, composition, id&gt;
    
    int *dum0, *dum1;
    int n, r, edge_idx;
    int *dep, *in, *out, *head, *par;
    int *E;
    
    node_type node[2];
    
    hld(int _n, int _r = -1):
        n(_n), r(_r), edge_idx(0){
            if(r == -1) r = random_device()()%n;
            dum0 = new int[n*7-2];
            dep = dum0;
            in = dum0+n;
            out = dum0+n*2;
            head = dum0+n*3;
            par = dum0+n*4;
            E = dum0+n*5;
        }
    
    void add_edge(int u, int v){
        E[edge_idx++] = u;
        E[edge_idx++] = v;
    }
    
    void build(const vector&lt;S&gt;&amp; v){
        dum1 = new int[n*8+1];
        int *g = dum1;
        int *start = dum1+n*2-2;
        int *C = dum1+n*3-1;
        memset(start, 0, sizeof(int)*(n+1));
        
        for(int i = 0; i &lt; 2*n-2; i+=2){
            start[E[i]+1]++;
            start[E[i+1]+1]++;
        }
        for(int i = 1; i &lt;= n; i++) start[i] += start[i-1];
        memcpy(C, start, sizeof(int)*(n+1));
        
        for(int i = 0; i &lt; 2*n-2; i+=2){
            g[C[E[i]]++] = E[i+1];
            g[C[E[i+1]]++] = E[i];
        }
        
        int *sub_siz = dum1+n*4;
        int *idx = dum1+n*5;
        fill(sub_siz, sub_siz+n, 1);
        memcpy(idx, start, sizeof(int)*(n+1));
        
        int cur = r;
        par[r] = -1;
        while(true){
            if(idx[cur] &lt; start[cur+1]-(cur!=r)){
                int nex = g[idx[cur]++];
                if(nex == par[cur]){
                    g[--idx[cur]] = g[start[cur+1]-1];
                    continue;
                }
                par[nex] = cur;
                cur = nex;
            } else {
                if(cur == r) break;
                sub_siz[par[cur]] += sub_siz[cur];
                cur = par[cur];
            }
        }
        
        memcpy(idx, start, sizeof(int)*(n+1));
        int *state = dum1+n*6+1;
        int *heavy = dum1+n*7+1;
        memset(state, 0, sizeof(int)*n);
        
        int node_siz = 0;
        cur = r;
        head[cur] = r;
        dep[cur] = 0;
        while(1){
            if(state[cur] == 0){
                in[cur] = node_siz++;
                heavy[cur] = -1;
                for(int i = start[cur]; i &lt; start[cur+1]-(cur!=r); i++){
                    int nex = g[i];
                    if(heavy[cur] == -1 || sub_siz[heavy[cur]] &lt; sub_siz[nex]){
                        heavy[cur] = nex;
                    }
                }
                if(heavy[cur] != -1){
                    int nex = heavy[cur];
                    dep[nex] = dep[cur];
                    head[nex] = head[cur];
                    state[cur] = 2;
                    cur = nex;
                } else state[cur] = 2;
            } else if(state[cur] == 2){
                if(idx[cur] &lt; start[cur+1]-(cur!=r)){
                    int nex = g[idx[cur]++];
                    if(nex == heavy[cur]) continue;
                    dep[nex] = dep[cur]+1;
                    head[nex] = nex;
                    cur = nex;
                } else state[cur] = 3;
            } else {
                out[cur] = node_siz;
                if(cur == r) break;
                cur = par[cur];
            }
        }
        
        vector&lt;S&gt; node_v(n);
        for(int i = 0; i &lt; n; i++) node_v[in[i]] = v[i];
        
        node[0] = node_type(node_v);
        reverse(node_v.begin(), node_v.end());
        node[1] = node_type(node_v);
        
        delete[] dum1;
    }
    
    S prod(int l, int r){
        assert(0 &lt;= l &amp;&amp; 0 &lt;= r &amp;&amp; l &lt; n &amp;&amp; r &lt; n);
        S l_ans = e();
        S r_ans = e();
        bool rev = false;
        while(true){
            if(dep[l] &lt; dep[r]) swap(l, r), rev ^= 1;
            if(dep[l] != dep[r] || head[l] != head[r]){
                if(!rev) l_ans = op(l_ans, node[1].prod(n-in[l]-1, n-in[head[l]]));
                else r_ans = op(node[0].prod(in[head[l]], in[l]+1), r_ans);
                l = par[head[l]];
            } else {
                if(in[l] &gt; in[r]) swap(l, r), rev ^= 1;
                if(!rev) l_ans = op(l_ans, node[0].prod(in[l], in[r]+1));
                else r_ans = op(node[1].prod(n-in[r]-1, n-in[l]), r_ans);
                return op(l_ans, r_ans);
            }
        }
    }
    
    S prod(int r){
        assert(0 &lt;= r &amp;&amp; r &lt; n);
        return node[0].prod(in[r], out[r]);
    }
    
    S get(int p){
        assert(0 &lt;= p &amp;&amp; p &lt; n);
        return node[0].get(in[p]);
    }
    
    void set(int p, const S&amp; x){
        assert(0 &lt;= p &amp;&amp; p &lt; n);
        node[0].set(in[p], x);
        node[1].set(n-in[p]-1, x);
    }
    
    void add(int p, const S&amp; x){
        assert(0 &lt;= p &amp;&amp; p &lt; n);
        node[0].add(in[p], x);
        node[1].add(n-in[p]-1, x);
    }
    
    int lca(int l, int r){
        assert(0 &lt;= l &amp;&amp; 0 &lt;= r &amp;&amp; l &lt; n &amp;&amp; r &lt; n);
        while(true){
            if(dep[l] &lt; dep[r]) swap(l, r);
            if(dep[l] != dep[r] || head[l] != head[r]){
                l = par[head[l]];
            } else {
                if(in[l] &gt; in[r]) swap(l, r);
                return l;
            }
        }
    }
    
    int dist(int l, int r){
        assert(0 &lt;= l &amp;&amp; 0 &lt;= r &amp;&amp; l &lt; n &amp;&amp; r &lt; n);
        int d = 0;
        while(true){
            if(dep[l] &lt; dep[r]) swap(l, r);
            if(dep[l] != dep[r] || head[l] != head[r]){
                d += in[l] - in[head[l]] + 1;
                l = par[head[l]];
            } else {
                if(in[l] &gt; in[r]) swap(l, r);
                d += in[r] - in[l];
                return d;
            }
        }
    }
    
    
    void apply(int l, int r, const F&amp; x){
        while(true){
            if(dep[l] &lt; dep[r]) swap(l, r);
            if(dep[l] != dep[r] || head[l] != head[r]){
                node[0].apply(in[head[l]], in[l]+1, x);
                node[1].apply(n-in[l]-1, n-in[head[l]], x);
                l = par[head[l]];
            } else {
                if(in[l] &gt; in[r]) swap(l, r);
                node[0].apply(in[l], in[r]+1, x);
                node[1].apply(n-in[r]-1, n-in[l], x);
                break;
            }
        }
    }
    
    void apply(int r, const F&amp; x){
        node[0].apply(in[r], out[r], x);
        node[1].apply(n-out[r], n-in[r], x);
    }
};
">copy</button><button id="button_copy_oneline" data-copy="">copy_oneline</button><script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script>
    marked.setOptions({ gfm: true, breaks: true, headerIds: true, mangle: false, highlight: (code, lang) => { if (lang && hljs.getLanguage(lang)) { return hljs.highlight(code, { language: lang }).value; } return hljs.highlightAuto(code).value; } });
    const mdContent = document.getElementById("md_content");
    if(mdContent) mdContent.innerHTML = marked.parse(mdContent.textContent);
    
    const copyButton = document.getElementById("button_copy")
    if(copyButton){
        copyButton.addEventListener("click", () => {
            const text = copyButton.dataset.copy;
            navigator.clipboard.writeText(text);
        })
    }
    const copyButtonOneline = document.getElementById("button_copy")
    if(copyButtonOneline){
        copyButtonOneline.addEventListener("click", () => {
            const text = copyButtonOneline.dataset.copy;
            navigator.clipboard.writeText(text);
        })
    }
</script>
</body>
</html>