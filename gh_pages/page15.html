<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>smkyb's library</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&display=swap">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.5.1/github-markdown.min.css"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
<style>
body { margin: 60px; font-family:'Noto Sans JP', Arial, sans-serif; font-size:large; }
.markdown-body { box-sizing: border-box; max-width: 900px; margin: 0 auto; }
.markdown-body pre { padding: 16px; overflow: auto; }
</style>
</head>
<body>
<article id="md_content" class="markdown-body">
mel_b</article>
<pre>
template&lt;typename T, typename S, auto op, auto e&gt;
struct meldable_binary_trie{
    static_assert(is_unsigned_v&lt;T&gt;);
    
    static constexpr T one = 1;
    static constexpr int bit_width = sizeof(T) * 8;
    
    struct node_t{
        T value;
        S sum;
        int width;
        int count;
        array&lt;node_t*, 4&gt; child;
        node_t() = default;
        node_t(T v, S s, int w, int c) : value(v), sum(s), width(w), count(c), child{&amp;nil, &amp;nil, &amp;nil, &amp;nil} {}
        node_t(T v, S s, int w, int c, node_t* c0, node_t* c1, node_t* c2, node_t* c3) : value(v), sum(s), width(w), count(c), child{c0, c1, c2, c3} {}
        static node_t nil;
    };
    
    struct ref_node_t{
        T val;
        bool exist;
        ref_node_t(T x, bool _e) : val{x}, exist{_e} {}
    };
    
    struct Pool {
        int cnt = 0;
        constexpr static int SIZ = 1&lt;&lt;17;
        node_t *ptr = nullptr, *en = nullptr;
        vector&lt;node_t*&gt; reuse;
        Pool() {
            ptr = new node_t[SIZ];
            en = ptr + SIZ;
        }
        node_t *get() {
            if(ptr == en) {
                if(!reuse.empty()) {
                    auto ptr = reuse.back();
                    reuse.pop_back();
                    return ptr;
                }
                ptr = new node_t[SIZ];
                en = ptr + SIZ;
            }
            return ptr++;
        }
        void push(node_t *p) {reuse.push_back(p);}
    };
    
    static Pool pool;
    node_t* root;
    bool rev = false;
    
    template&lt;typename _Tp&gt;
    inline static int clz(_Tp x) {
        if constexpr(sizeof(_Tp) == 8ull) return __builtin_clzll(x);
        else return __builtin_clz(x);
    }
    
    inline static T mask(int l, int r) {
        if(r &gt;= bit_width) return -(one&lt;&lt;l);
        return (one&lt;&lt;r) - (one&lt;&lt;l);
    }
    
    inline static T masked(T v, int l, int r) {
        return mask(l, r) &amp; v;
    }
    
    inline static int diff_bit(T x, T y) {
        return ((bit_width-1 - clz(x^y))|1) + 1;
    }
    
    //value, sum, width, count, child
    template&lt;typename... Args&gt;
    static inline node_t* make_node(Args ...args) {
        return &amp;((*pool.get()) = node_t(forward&lt;Args&gt;(args)...));
    }
    
    public:
    
    meldable_binary_trie(){
        root = make_node(0, e(), bit_width, 0);
    }
    meldable_binary_trie(T p, const S &amp;x){
        root = make_node(p, x, bit_width, 1);
    }
    meldable_binary_trie(node_t *x){
        root = x;
    }
    
    meldable_binary_trie&amp; operator=(meldable_binary_trie&amp;&amp; o) noexcept = default;
    
    meldable_binary_trie(meldable_binary_trie&amp;&amp; o) noexcept = default;
    
    void insert(T v, const S &amp;x) {
        node_t* pos = root;
        int bit = bit_width;
        node_t *route[65]; int route_cnt = 0;
        while(true){
            T mv = masked(v, bit-pos-&gt;width, bit);
            T mnv = masked(pos-&gt;value, bit-pos-&gt;width, bit);
            if(mv != mnv){
                route[route_cnt++] = pos;
                int diff = diff_bit(mv, mnv);
                int b = (mv&gt;&gt;(diff-2))&amp;3;
                int nb = (mnv&gt;&gt;(diff-2))&amp;3;
                node_t* inter = make_node(pos-&gt;value, pos-&gt;sum, pos-&gt;width-bit+diff, pos-&gt;count, pos-&gt;child[0], pos-&gt;child[1], pos-&gt;child[2], pos-&gt;child[3]);
                node_t* leaf = make_node(v, x, diff, 1);
                pos-&gt;width = bit-diff;
                pos-&gt;count++;
                pos-&gt;child = {&amp;node_t::nil, &amp;node_t::nil, &amp;node_t::nil, &amp;node_t::nil};
                pos-&gt;child[b] = leaf;
                pos-&gt;child[nb] = inter;
                break;
            } else {
                pos-&gt;count++;
                bit -= pos-&gt;width;
                if(bit == 0) {
                    pos-&gt;sum = x;
                    break;
                }
                route[route_cnt++] = pos;
                int b = (v&gt;&gt;(bit-2))&amp;3;
                if(pos-&gt;child[b] == &amp;node_t::nil){
                    pos-&gt;child[b] = make_node(v, x, bit, 1);
                    break;
                }
                pos = pos-&gt;child[b];
            }
        }
        for(int i = route_cnt-1; i &gt;= 0; i--){
            node_t *ptr = route[i];
            ptr-&gt;sum = op(op(op(ptr-&gt;child[0]-&gt;sum, ptr-&gt;child[1]-&gt;sum), ptr-&gt;child[2]-&gt;sum), ptr-&gt;child[3]-&gt;sum);
        }
    }
    
    int count(T v) const {
        node_t* pos = root;
        int bit = bit_width;
        while(pos != &amp;node_t::nil){
            T mv = masked(v, bit-pos-&gt;width, bit);
            T mnv = masked(pos-&gt;value, bit-pos-&gt;width, bit);
            if(mv != mnv) return 0;
            bit -= pos-&gt;width;
            if(bit == 0) return pos-&gt;count;
            pos = pos-&gt;child[(v&gt;&gt;(bit-2))&amp;3];
        }
        return 0;
    }
    
    int size() const {
        return root-&gt;count;
    }
    
    static node_t *meld(meldable_binary_trie &amp;l, meldable_binary_trie &amp;r){
        return meld(l.root, r.root);
    }
    static node_t *meld(node_t *l, node_t *r){
        node_t *res = meld(l, r, bit_width);
        return res;
    }
    static node_t *meld(node_t *l, node_t *r, int bit){
        if(l-&gt;count == 0){
            return r;
        }
        if(r-&gt;count == 0){
            return l;
        }
        T mlv = masked(l-&gt;value, min(bit-l-&gt;width, bit-r-&gt;width), bit);
        T mrv = masked(r-&gt;value, min(bit-l-&gt;width, bit-r-&gt;width), bit);
        if(mlv == mrv){
            if(l-&gt;width == r-&gt;width){
                l-&gt;count += r-&gt;count;
                if(bit == l-&gt;width){
                    l-&gt;sum = op(l-&gt;sum, r-&gt;sum);
                    return l;
                } else {
                    for(int i = 0; i &lt; 4; i++) l-&gt;child[i] = meld(l-&gt;child[i], r-&gt;child[i], bit - l-&gt;width);
                    pool.push(r);
                }
            } else {
                if(l-&gt;width &gt; r-&gt;width) swap(l, r);
                l-&gt;count += r-&gt;count;
                bit -= l-&gt;width;
                r-&gt;width -= l-&gt;width;
                int b = (r-&gt;value&gt;&gt;(bit-2))&amp;3;
                l-&gt;child[b] = meld(l-&gt;child[b], r, bit);
            }
        } else {
            if(l-&gt;width &gt; r-&gt;width) swap(l, r);
            int diff = diff_bit(mlv, mrv);
            if(l-&gt;width &lt;= bit - diff){
                l-&gt;count += r-&gt;count;
                r-&gt;width -= l-&gt;width;
                bit -= l-&gt;width;
                int b = (r-&gt;value&gt;&gt;(bit-2))&amp;3;
                l-&gt;child[b] = meld(l-&gt;child[b], r, bit);
            } else {
                node_t *ptr = make_node(l-&gt;value, l-&gt;sum, l-&gt;width-bit+diff, l-&gt;count, l-&gt;child[0], l-&gt;child[1], l-&gt;child[2], l-&gt;child[3]);
                memcpy(l-&gt;child.data(), node_t::nil.child.data(), sizeof(node_t*) * 4);
                r-&gt;width -= bit - diff;
                l-&gt;width = bit - diff;
                l-&gt;count += r-&gt;count;
                l-&gt;child[l-&gt;value&gt;&gt;(diff-2)&amp;3] = ptr;
                l-&gt;child[r-&gt;value&gt;&gt;(diff-2)&amp;3] = r;
            }
        }
        l-&gt;sum = op(op(op(l-&gt;child[0]-&gt;sum, l-&gt;child[1]-&gt;sum), l-&gt;child[2]-&gt;sum), l-&gt;child[3]-&gt;sum);
        return l;
    }
    
    pair&lt;meldable_binary_trie, meldable_binary_trie&gt; split(int p){
        if(rev) p = root-&gt;count-p;
        auto res = split(root, p);
        if(rev){
            meldable_binary_trie f(res.second), s(res.first);
            f.rev = true; s.rev = true;
            return make_pair(move(f), move(s));
        } else return {meldable_binary_trie(res.first), meldable_binary_trie(res.second)};
    }
    
    static pair&lt;node_t*, node_t*&gt; split(node_t *l, int p){
        if(p == 0) return {&amp;node_t::nil, l};
        if(p == l-&gt;count) return {l, &amp;node_t::nil};
        int acc = 0;
        
        for (int i = 0; i &lt; 4; i++) {
            int c = l-&gt;child[i]-&gt;count;
            if (p &lt; acc + c) {
                auto sub = split(l-&gt;child[i], p - acc);
                
                node_t *ptr = make_node(l-&gt;value, e(), l-&gt;width, 0);
                
                l-&gt;child[i] = sub.first;
                ptr-&gt;child[i] = sub.second;
                for(int j = i+1; j &lt; 4; j++) ptr-&gt;child[j] = l-&gt;child[j];
                for(int j = i+1; j &lt; 4; j++) l-&gt;child[j] = &amp;node_t::nil;
                
                l-&gt;count = 0;
                for(int j = 0; j &lt;= i; j++) l-&gt;count += l-&gt;child[j]-&gt;count;
                for(int j = i; j &lt; 4; j++) ptr-&gt;count += ptr-&gt;child[j]-&gt;count;
                
                l-&gt;sum = e();
                for(int j = 0; j &lt;= i; j++) l-&gt;sum = op(l-&gt;sum, l-&gt;child[j]-&gt;sum);
                for(int j = i; j &lt; 4; j++) ptr-&gt;sum = op(ptr-&gt;sum, ptr-&gt;child[j]-&gt;sum);
                
                return {l, ptr};
            }
            acc += c;
        }
        assert(false);
    }
    
    meldable_binary_trie split_one(){
        if(rev){
            meldable_binary_trie res(split_one_rev(root));
            res.rev = true;
            return move(res);
        } else {
            return meldable_binary_trie(split_one(root));
        }
    }
    node_t *split_one(node_t *l){
        if(l-&gt;count == 1) return &amp;node_t::nil;
        
        l-&gt;count--;
        for(int i = 0; i &lt; 4; i++){
            int c = l-&gt;child[i]-&gt;count;
            if(c == 0) continue;
            l-&gt;child[i] = split_one(l-&gt;child[i]);
            l-&gt;sum = e();
            for(int j = i; j &lt; 4; j++) l-&gt;sum = op(l-&gt;sum, l-&gt;child[j]-&gt;sum);
            return l;
        }
        assert(false);
    }
    node_t *split_one_rev(node_t *l){
        if(l-&gt;count == 1) return &amp;node_t::nil;
        
        l-&gt;count--;
        for(int i = 3; i &gt;= 0; i--){
            int c = l-&gt;child[i]-&gt;count;
            if(c == 0) continue;
            l-&gt;child[i] = split_one_rev(l-&gt;child[i]);
            l-&gt;sum = e();
            for(int j = 0; j &lt;= i; j++) l-&gt;sum = op(l-&gt;sum, l-&gt;child[j]-&gt;sum);
            return l;
        }
        assert(false);
    }
    
    S all_prod() const {return root-&gt;sum;}
    
    void init(T p, const S &amp;x){
        root = make_node(p, x, bit_width, 1);
    }
    
    static int get_size(node_t *ptr){
        if(ptr == &amp;node_t::nil) return 0;
        int res = 1;
        for(int i = 0; i &lt; 4; i++) res += get_size(ptr-&gt;child[i]);
        return res;
    }
};
template&lt;typename T, typename S, auto op, auto e&gt; typename meldable_binary_trie&lt;T, S, op, e&gt;::node_t meldable_binary_trie&lt;T, S, op, e&gt;::node_t::nil = meldable_binary_trie&lt;T, S, op, e&gt;::node_t(0, e(), bit_width, 0);
template&lt;typename T, typename S, auto op, auto e&gt; typename meldable_binary_trie&lt;T, S, op, e&gt;::Pool meldable_binary_trie&lt;T, S, op, e&gt;::pool = meldable_binary_trie&lt;T, S, op, e&gt;::Pool();</pre>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script>
    marked.setOptions({ gfm: true, breaks: true, headerIds: true, mangle: false, highlight: (code, lang) => { if (lang && hljs.getLanguage(lang)) { return hljs.highlight(code, { language: lang }).value; } return hljs.highlightAuto(code).value; } });
    const el = document.getElementById('md_content');
    el.innerHTML = marked.parse(el.textContent);
</script>
</body>
</html>
