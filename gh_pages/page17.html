<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>smkyb's library</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&display=swap">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.5.1/github-markdown.min.css"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
<style>
    body { margin: 60px; font-family:'Noto Sans JP', Arial, sans-serif; font-size:large; }
    .markdown-body { box-sizing: border-box; max-width: 900px; margin: 0 auto; }
    .markdown-body pre { padding: 16px; overflow: auto; }
</style>
</head>
<body>
<article id="md_content" class="markdown-body">
seg</article>
<pre>
template&lt;typename S, auto op, auto e&gt;
struct segtree{
    int siz;
    vector&lt;S&gt; node;
    
    segtree() = default;
    segtree(unsigned n) : siz(std::bit_ceil(n)), node(siz*2, e()){}
    segtree(const vector&lt;S&gt;&amp; v){init(v);}
    void init(const vector&lt;S&gt;&amp; v){
        siz = bit_ceil(v.size()); node.resize(siz*2, e());
        for(int i = 0; i &lt; (int)v.size(); i++) node[i+siz] = v[i];
        for(int i = siz-1; i &gt;= 1; i--) node[i] = op(node[i*2], node[i*2+1]);
    }
    
    const S &amp;operator[](int pos) const {return node[pos+siz];}
    
    const S &amp;get(int pos) const {return node[pos+siz];}
    
    void set(int pos, const S &amp;x){
        assert(0 &lt;= pos &amp;&amp; pos &lt; siz);
        pos += siz;
        node[pos] = x;
        while(pos&gt;&gt;=1) node[pos] = op(node[pos&lt;&lt;1], node[(pos&lt;&lt;1)+1]);
    }
    
    void add(int pos, const S &amp;x){
        assert(0 &lt;= pos &amp;&amp; pos &lt; siz);
        pos += siz;
        node[pos] = op(node[pos], x);
        while(pos&gt;&gt;=1) node[pos] = op(node[pos], x);
    }
    
    S prod(int left, int right){
        left = max(0, left); right = min(right, siz);
        S l_ans = e(), r_ans = e();
        for(left+=siz, right+=siz; left &lt; right; left&gt;&gt;=1, right&gt;&gt;=1){
            if(left&amp;1) l_ans = op(l_ans, node[left++]);
            if(right&amp;1) r_ans = op(node[--right], r_ans);
        }
        return op(l_ans, r_ans);
    }
    
    S all_prod(){
        return node[1];
    }
};</pre>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script>
    marked.setOptions({ gfm: true, breaks: true, headerIds: true, mangle: false, highlight: (code, lang) => { if (lang && hljs.getLanguage(lang)) { return hljs.highlight(code, { language: lang }).value; } return hljs.highlightAuto(code).value; } });
    const el = document.getElementById("md_content");
    el.innerHTML = marked.parse(el.textContent);
</script>
</body>
</html>