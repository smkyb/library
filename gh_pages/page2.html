<pre>#define PROBLEM &quot;https://judge.yosupo.jp/problem/double_ended_priority_queue&quot;

//#include &quot;../../../_initialize.cpp&quot;
//#include &quot;../binary_trie.cpp&quot;
#include &lt;bits/stdc++.h&gt;
using namespace std;

template &lt;typename T&gt;
struct binary_trie{
    static_assert(is_unsigned_v&lt;T&gt;);
    
    struct node_t{
        T value;
        int width;
        int count;
        array&lt;node_t*, 4&gt; child;
        node_t() = default;
        node_t(T v, int w, int c) : value(v), width(w), count(c), child{&amp;nil, &amp;nil, &amp;nil, &amp;nil} {}
        node_t(T v, int w, int c, node_t* c0, node_t* c1, node_t* c2, node_t* c3) : value(v), width(w), count(c), child{c0, c1, c2, c3} {}
        static node_t nil;
    };
    
    struct ref_node_t{
        T val;
        bool exist;
        ref_node_t(T x, bool e) : val{x}, exist{e} {}
    };
    
    struct Pool {
        constexpr static int SIZ = 1&lt;&lt;16;
        node_t* ptr = nullptr, *en = nullptr;
        node_t* get() {
            if(ptr == en) [[unlikely]] {
                ptr = new node_t[SIZ];
                en = ptr + SIZ;
            }
            return ptr++;
        }
    };
    
    static constexpr T one = 1;
    static constexpr int bit_width = sizeof(T) * 8;
    static Pool pool;
    T xor_val = 0;
    node_t* root;
    int siz = 0;
    
    template&lt;typename _Tp&gt;
    inline int clz(_Tp x) const {
        if constexpr(sizeof(_Tp) == 8ull) return __builtin_clzll(x);
        else return __builtin_clz(x);
    }
    
    inline T mask(int l, int r) const {
        if(r &gt;= bit_width) {
            if(l &gt;= bit_width) return 0;
            else return -(one&lt;&lt;l);
        }
        return (one&lt;&lt;r) - (one&lt;&lt;l);
    }
    
    inline T masked(T v, int l, int r) const {
        return mask(l, r) &amp; v;
    }
    
    inline int diff_bit(T x, T y) const {
        return ((bit_width-1 - clz(x^y))|1) + 1;
    }
    
    template&lt;typename... Args&gt;
    inline node_t* make_node(Args ...args) {
        return &amp;((*pool.get()) = node_t(args...));
    }
    
    public:
    
    binary_trie(){
        root = make_node(0, bit_width, 0);
    }
    
    binary_trie&lt;T&gt;&amp; operator=(binary_trie&lt;T&gt;&amp;&amp; o) noexcept = default;
    
    binary_trie(binary_trie&amp;&amp; o) noexcept = default;
    
    void insert(T v) {
        node_t* pos = root;
        int bit = bit_width;
        siz++;
        v ^= xor_val;
        while(true){
            T mv = masked(v, bit-pos-&gt;width, bit);
            T mnv = masked(pos-&gt;value, bit-pos-&gt;width, bit);
            if(mv != mnv){
                int diff = diff_bit(mv, mnv);
                int b = (mv&gt;&gt;(diff-2))&amp;3;
                int nb = (mnv&gt;&gt;(diff-2))&amp;3;
                node_t* inter = make_node(pos-&gt;value, pos-&gt;width-bit+diff, pos-&gt;count, pos-&gt;child[0], pos-&gt;child[1], pos-&gt;child[2], pos-&gt;child[3]);
                node_t* leaf = make_node(v, diff, 1);
                pos-&gt;width = bit-diff;
                pos-&gt;count++;
                pos-&gt;child = {&amp;node_t::nil, &amp;node_t::nil, &amp;node_t::nil, &amp;node_t::nil};
                pos-&gt;child[b] = leaf;
                pos-&gt;child[nb] = inter;
                return;
            } else {
                pos-&gt;count++;
                bit -= pos-&gt;width;
                if(bit == 0) return;
                int b = (v&gt;&gt;(bit-2))&amp;3;
                if(pos-&gt;child[b] == &amp;node_t::nil){
                    pos-&gt;child[b] = make_node(v, bit, 1);
                    return;
                }
                pos = pos-&gt;child[b];
            }
        }
    }
    
    int count(T v) const {
        node_t* pos = root;
        int bit = bit_width;
        v ^= xor_val;
        while(pos != &amp;node_t::nil){
            T mv = masked(v, bit-pos-&gt;width, bit);
            T mnv = masked(pos-&gt;value, bit-pos-&gt;width, bit);
            if(mv != mnv) return 0;
            bit -= pos-&gt;width;
            if(bit == 0) return pos-&gt;count;
            pos = pos-&gt;child[(v&gt;&gt;(bit-2))&amp;3];
        }
        return 0;
    }
    
    void erase(T v) {
        node_t* pos = root;
        int bit = bit_width;
        siz--;
        v ^= xor_val;
        while(true){
            pos-&gt;count--;
            bit -= pos-&gt;width;
            if(bit == 0) return;
            pos = pos-&gt;child[(v&gt;&gt;(bit-2))&amp;3];
        }
    }
    
    void erase_all(T v) {
        int n = count(v);
        if(n == 0) return;
        node_t* pos = root;
        int bit = bit_width;
        siz -= n;
        v ^= xor_val;
        while(true){
            pos-&gt;count -= n;
            bit -= pos-&gt;width;
            if(bit == 0) return;
            pos = pos-&gt;child[(v&gt;&gt;(bit-2))&amp;3];
        }
    }
    
    const T operator[](int k) const {
        if(k &lt; 0) k += siz;
        
        k++;
        node_t* pos = root;
        int bit = bit_width;
        while(true){
            bit -= pos-&gt;width;
            if(bit == 0) return pos-&gt;value^xor_val;
            int b = (xor_val&gt;&gt;(bit-2))&amp;3;
            auto &amp;child = pos-&gt;child;
            if(k &lt;= child[b]-&gt;count){
                pos = child[b];
            } else {
                k -= child[b]-&gt;count;
                if(k &lt;= child[b^1]-&gt;count){
                    pos = child[b^1];
                } else {
                    k -= child[b^1]-&gt;count;
                    if(k &lt;= child[b^2]-&gt;count){
                        pos = child[b^2];
                    } else {
                        k -= child[b^2]-&gt;count;
                        pos = child[b^3];
                    }
                }
            }
        }
    }
    
    T min() const {
        node_t* pos = root;
        int bit = bit_width;
        while(true){
            bit -= pos-&gt;width;
            if(bit == 0) return pos-&gt;value^xor_val;
            int b = (xor_val&gt;&gt;(bit-2))&amp;3;
            auto &amp;child = pos-&gt;child;
            if(child[b]-&gt;count) pos = child[b];
            else if(child[b^1]-&gt;count) pos = child[b^1];
            else if(child[b^2]-&gt;count) pos = child[b^2];
            else pos = child[b^3];
        }
    }
    
    T max() const {
        node_t* pos = root;
        int bit = bit_width;
        while(true){
            bit -= pos-&gt;width;
            if(bit == 0) return pos-&gt;value^xor_val;
            int b = (xor_val&gt;&gt;(bit-2))&amp;3;
            auto &amp;child = pos-&gt;child;
            if(child[b^3]-&gt;count) pos = child[b^3];
            else if(child[b^2]-&gt;count) pos = child[b^2];
            else if(child[b^1]-&gt;count) pos = child[b^1];
            else pos = child[b];
        }
    }
    
    int order(T v) const {
        if(v == 0) return 0;
        v--;
        int res = 0;
        node_t* pos = root;
        int bit = bit_width;
        while(pos != &amp;node_t::nil){
            T mv = masked(v, bit-pos-&gt;width, bit);
            T mnv = masked(pos-&gt;value^xor_val, bit-pos-&gt;width, bit);
            if(mv &lt; mnv){
                return res;
            } else {
                if(mv &gt; mnv){
                    res += pos-&gt;count;
                    return res;
                } else {
                    bit -= pos-&gt;width;
                    if(bit == 0) return res + pos-&gt;count;
                    int b = (v&gt;&gt;(bit-2))&amp;3;
                    auto &amp;child = pos-&gt;child;
                    T mxv = (xor_val&gt;&gt;(bit-2))&amp;3;
                    
                    if(b &gt;= 1){
                        res += child[mxv]-&gt;count;
                        if(b &gt;= 2){
                            res += child[mxv^1]-&gt;count;
                            if(b &gt;= 3){
                                res += child[mxv^2]-&gt;count;
                            }
                        }
                    }
                    pos = child[b^mxv];
                }
            }
        }
        return res;
    }
    
    const ref_node_t lower_bound(T v) const {
        int ord = order(v);
        if(siz == ord) return ref_node_t{0, false};
        else return ref_node_t{(*this)[ord], true};
    }
    
    const ref_node_t less_bound(T v) const {
        int ord = v!=numeric_limits&lt;T&gt;::max() ? order(v+1) : siz;
        if(ord == 0) return ref_node_t{0, false};
        else return ref_node_t{(*this)[ord-1], true};
    }
    
    int size() const {
        return siz;
    }
    
    void apply_xor(T x) {
        xor_val ^= x;
    }
    
    const T xor_min(T v) {
        apply_xor(v);
        T res = min()^v;
        apply_xor(v);
        return res;
    }
    
    const T xor_max(T v) {
        apply_xor(v);
        T res = max()^v;
        apply_xor(v);
        return res;
    }
};
template&lt;typename T&gt; typename binary_trie&lt;T&gt;::node_t binary_trie&lt;T&gt;::node_t::nil = node_t(0, bit_width, 0, &amp;node_t::nil, &amp;node_t::nil, &amp;node_t::nil, &amp;node_t::nil);
template&lt;typename T&gt; typename binary_trie&lt;T&gt;::Pool binary_trie&lt;T&gt;::pool = Pool();

constexpr int num = 1000000000;

int main(){
    cin.tie(0)-&gt;sync_with_stdio(0);
    int n, q;
    cin &gt;&gt; n &gt;&gt; q;
    
    binary_trie&lt;unsigned&gt; tree;
    
    for(int i = 0; i &lt; n; i++){
        int x;
        cin &gt;&gt; x;
        tree.insert(x+num);
    }
    
    while(q--){
        int t, x;
        cin &gt;&gt; t;
        switch(t){
            case 0:
                cin &gt;&gt; x;
                tree.insert(x+num);
                break;
            case 1:
                cout &lt;&lt; (x = tree.min())-num &lt;&lt; &#x27;\n&#x27;;
                tree.erase(x);
                break;
            case 2:
                cout &lt;&lt; (x = tree.max())-num &lt;&lt; &#x27;\n&#x27;;
                tree.erase(x);
                break;
        }
    }
}</pre>