<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>smkyb's library</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&display=swap">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.5.1/github-markdown.min.css"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
<style>
    body { margin: 60px; font-family:'Noto Sans JP', Arial, sans-serif; font-size:large; }
    .markdown-body { box-sizing: border-box; max-width: 900px; margin: 0 auto; }
    .markdown-body pre { padding: 16px; overflow: auto; }
</style>
</head>
<body>
<article id="md_content" class="markdown-body">
# dynamic segtree

動的セグ木（必要なところだけ作るセグ木）です。  
・一点更新  
・区間積  
だけ行えます。  
  
空間 $O(n)$ です
<br>

## コンストラクタ
```cpp
dynamic_segtree<T, S, op, e> seg;
```

T は添え字の型  
S・op・eはACLと同じ  
<br>

## set(T p, S x)
$O(log N)$  

## get(T p)
$O(log N)$  

## prod(T l, T r)
$O(log N)$  

## all_prod()
$O(log N)$  

## reserve

```cpp
void reserve(int n)
```

**・ 概要 :** 合計n回setしたときに、内部のvectorで再配置が起こらないようにする  
**・ 制約 :** 0 ≤ n < 常識  
**・ (空間)計算量 :** $O(n)$  
<br>

verified? : [Library Checker Point Set Range Composite (Large Array)](https://judge.yosupo.jp/submission/286197)
</article>
<pre>
template &lt;typename T, typename S, auto op, auto e&gt;
struct dynamic_segtree{
    private:
    
    struct node_t{
        S sum;
        T value;
        array&lt;int, 4&gt; child = {};
        int width = 0;
        node_t() : sum{e()} {}
        node_t(const node_t &amp;o) noexcept = default;
        node_t(node_t &amp;&amp;o) noexcept = default;
        node_t &amp;operator=(const node_t &amp;o) noexcept = default;
        node_t &amp;operator=(node_t &amp;&amp;o) noexcept = default;
    };
    
    static constexpr T one = 1;
    static constexpr int bit_width = sizeof(T) * 8;
    vector&lt;node_t&gt; node;
    int root = -1;
    
    //__builtin_clz
    template&lt;typename _Tp&gt;
    inline int clz(_Tp x) const {
        if constexpr(sizeof(_Tp) == 8ull) return __builtin_clzll(x);
        else return __builtin_clz(x);
    }
    
    inline T mask(int l, int r) const {
        if(r &gt;= bit_width) return -(one&lt;&lt;l);
        return (one&lt;&lt;r) - (one&lt;&lt;l);
    }
    
    inline T masked(T v, int l, int r) const {
        return mask(l, r) &amp; v;
    }
    
    inline int diff_bit(T x, T y) const {
        return ((bit_width-1 - clz(x^y))|1) + 1;
    }
    
    inline int make_node(T v, S x){
        node.emplace_back();
        node.back().value = v;
        node.back().sum = move(x);
        return ssize(node)-1;
    }
    
    public:
    
    dynamic_segtree(){
        make_node(0, e());
        root = make_node(0, e());
        node[root].width = bit_width;
    }
    
    dynamic_segtree&lt;T, S, op, e&gt;&amp; operator=(dynamic_segtree&lt;T, S, op, e&gt;&amp;&amp; o) noexcept = default;
    
    dynamic_segtree(dynamic_segtree&amp;&amp; o) noexcept = default;
    
    void set(T v, const S &amp;x) {
        int pos = root;
        int bit = bit_width;
        int route[65], route_cnt = 0;
        while(true){
            T mv = masked(v, bit-node[pos].width, bit);
            T mnv = masked(node[pos].value, bit-node[pos].width, bit);
            if(mv != mnv){
                route[route_cnt++] = pos;
                int diff = diff_bit(mv, mnv);
                int b = (mv&gt;&gt;(diff-2))&amp;3;
                int nb = (mnv&gt;&gt;(diff-2))&amp;3;
                int inter = make_node(node[pos].value, node[pos].sum);
                int leaf = make_node(v, x);
                node[inter] = node[pos];
                node[inter].width -= bit - diff;
                memset(node[pos].child.data(), 0, sizeof(int)*4);
                node[pos].child[b] = leaf;
                node[pos].child[nb] = inter;
                node[pos].width = bit - diff;
                bit = diff;
                node[leaf].width = bit;
                pos = leaf;
                break;
            } else {
                
                bit -= node[pos].width;
                if(bit == 0){
                    node[pos].sum = x;
                    break;
                }
                route[route_cnt++] = pos;
                int nex = node[pos].child[(v&gt;&gt;(bit-2))&amp;3];
                if(nex == 0){
                    nex = node[pos].child[(v&gt;&gt;(bit-2))&amp;3] = make_node(v, x);
                    node[nex].width = bit;
                    break;
                }
                pos = nex;
            }
        }
        for(int i = route_cnt-1; i &gt;= 0; i--){
            int idx = route[i];
            auto &amp;child = node[idx].child;
            node[idx].sum = op(op(op(node[child[0]].sum, node[child[1]].sum), node[child[2]].sum), node[child[3]].sum);
        }
    }
    
    S get(T p) const {
        int pos = root;
        int bit = bit_width;
        while(pos != 0){
            bit -= node[pos].width;
            if(bit == 0) return node[pos].value==p ? node[pos].sum : e();
            pos = node[pos].child[(p&gt;&gt;(bit-2))&amp;3];
        }
        return e();
    }
    
    S prod(T l, T r) const {
        return _prod(l, r, root, bit_width);
    }
    S _prod(T l, T r, int pos, int bit) const {
        if(pos == 0) return e();
        bit -= node[pos].width;
        T mv = masked(node[pos].value, bit, bit_width);
        if(r &lt;= mv) return e();
        if(l != numeric_limits&lt;T&gt;::min() &amp;&amp; mv-1+(one&lt;&lt;bit) &lt; l) return e();
        if(l &lt;= mv &amp;&amp; mv-1+(one&lt;&lt;bit) &lt; r){
            return node[pos].sum;
        }
        auto &amp;child = node[pos].child;
        return op(op(op(_prod(l, r, child[0], bit), _prod(l, r, child[1], bit)), _prod(l, r, child[2], bit)), _prod(l, r, child[3], bit));
    }
    
    S all_prod() const {
        return node[root].sum;
    }
    
    void reserve(int n) {
        node.reserve(2*n+2);
    }
};
</pre>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script>
    marked.setOptions({ gfm: true, breaks: true, headerIds: true, mangle: false, highlight: (code, lang) => { if (lang && hljs.getLanguage(lang)) { return hljs.highlight(code, { language: lang }).value; } return hljs.highlightAuto(code).value; } });
    const el = document.getElementById("md_content");
    el.innerHTML = marked.parse(el.textContent);
</script>
</body>
</html>