<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>smkyb's library</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP&display=swap">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.5.1/github-markdown.min.css"></script>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
<style>
    body { margin: 60px; font-family:'Noto Sans JP', Arial, sans-serif; font-size:large; }
    .markdown-body { box-sizing: border-box; max-width: 900px; margin: 0 auto; }
    .markdown-body pre { padding: 16px; overflow: auto; }
    .button_sq { display: flex; font-size: 22px; flex-direction: column; gap: 20px; margin-bottom: 10px; padding: 10px; background-color: rgb(89, 158, 157); color: white; border: none; padding-left: 20px; padding-right: 20px; cursor: pointer; text-align: center; }
</style>
</head>
<body>
<article id="md_content" class="markdown-body">
fasio</article>
<pre>
struct FIstream{
    static constexpr unsigned SIZ = 1 &lt;&lt; 17;
    char buf[SIZ], *p1 = buf, *p2 = buf;
    
    inline char _getchar(){
        if(p1 == p2){
            p2 = (p1 = buf) + fread(buf, 1, SIZ, stdin);
            if(p1 == p2) [[unlikely]] assert(0&amp;&amp;&quot;EOF&quot;);
        }
        return *p1++;
    }
    
    inline char ignore_space(){
        char c;
        while((c = _getchar()) &lt;= 0x20);
        return c;
    }
    
    template&lt;typename T&gt;
    inline void _read(T&amp; res){
        T x = 0, f = 1;
        char c = ignore_space();
        if(c == &#x27;-&#x27;){
            f = -1;
            c = _getchar();
        }
        while(&#x27;0&#x27; &lt;= c &amp;&amp; c &lt;= &#x27;9&#x27;){
            x = x*10 + (c-&#x27;0&#x27;);
            c = _getchar();
        }
        res = x*f;
    }
    
    template&lt;typename T&gt;
    inline FIstream&amp; operator&gt;&gt;(T&amp; x){_read(x); return *this;}
    inline FIstream&amp; operator&gt;&gt;(char&amp; x){x = ignore_space(); return *this;}
    inline FIstream&amp; operator&gt;&gt;(string&amp; x){
        string().swap(x);
        char c = ignore_space();
        while(c &gt; 0x20){
            x.push_back(c);
            c = _getchar();
        }
        return *this;
    }
} _cin;

struct FOstream_Pre{
    char num[10000][4];
    constexpr FOstream_Pre():num(){
        for(int i = 0; i &lt; 10000; i++){
            int x = i;
            for(int j = 3; j &gt;= 0; j--){
                num[i][j] = x%10 + &#x27;0&#x27;;
                x /= 10;
            }
        }
    }
} constexpr _FOstream_pre;

struct FOstream{
    static constexpr unsigned SIZ = 1 &lt;&lt; 17;
    char buf[SIZ], *p1 = buf, *p2 = buf+SIZ;
    
    inline void _write(){
        fwrite(buf, 1, p1-buf, stdout);
        p1 = buf;
    }
    
    inline void _putchar(char c){
        if(p1 == p2) [[unlikely]] {
            _write();
        }
        *p1++ = c;
    }
    
    template&lt;typename T&gt;
    void _write_i(T x){
        constexpr int DIGIT_SIZ = 40;
        static_assert(DIGIT_SIZ &lt;= SIZ);
        char num[DIGIT_SIZ], *idxp = num+DIGIT_SIZ;
        if(x &lt; 0){
            _putchar(&#x27;-&#x27;);
            x = -x;
        }
        if(p2 - p1 &lt; DIGIT_SIZ) _write();
        while(x &gt;= 10000){
            idxp -= 4;
            memcpy(idxp, _FOstream_pre.num[size_t(x%10000)], 4);
            x /= 10000;
        }
        if(x &gt;= 1000){
            memcpy(p1, _FOstream_pre.num[size_t(x)], 4);
            p1 += 4;
        } else if(x &gt;= 100){
            memcpy(p1, _FOstream_pre.num[size_t(x)]+1, 3);
            p1 += 3;
        } else if(x &gt;= 10){
            memcpy(p1, _FOstream_pre.num[size_t(x)]+2, 2);
            p1 += 2;
        } else *p1++ = char(x)+&#x27;0&#x27;;
        memcpy(p1, idxp, num+DIGIT_SIZ - idxp);
        p1 += num+DIGIT_SIZ - idxp;
    }
    
    template&lt;typename T&gt;
    FOstream &amp;operator&lt;&lt;(const T &amp;x) {_write_i(x); return *this;}
    FOstream &amp;operator&lt;&lt;(char x) {_putchar(x); return *this;}
    FOstream &amp;operator&lt;&lt;(const char *x) {
        while(*x) _putchar(*x++);
        return *this;
    }
    FOstream &amp;operator&lt;&lt;(char *x) {return *this &lt;&lt; const_cast&lt;const char*&gt;(x);}
    FOstream &amp;operator&lt;&lt;(double x) {
        if(isnan(x)) [[unlikely]] return *this &lt;&lt; &quot;nan&quot;;
        char _b[70];
        snprintf(_b, sizeof(_b), &quot;%.*f&quot;, 15, x);
        return *this &lt;&lt; const_cast&lt;const char*&gt;(_b);
    }
    FOstream &amp;operator&lt;&lt;(long double x) {
        if(isnan(x)) [[unlikely]] return *this &lt;&lt; &quot;nan&quot;;
        char _b[330];
        snprintf(_b, sizeof(_b), &quot;%.*Lf&quot;, 15, x);
        return *this &lt;&lt; const_cast&lt;const char*&gt;(_b);
    }
    FOstream&amp; operator&lt;&lt;(const string&amp; x){
        for(char i : x) _putchar(i);
        return *this;
    }
    
    ~FOstream(){
        if(p1 != buf){
            fwrite(buf, 1, p1 - buf, stdout);
        }
    }
} _cout;

#define cin _cin
#define istream FIstream
#define cout _cout
#define ostream FOstream
</pre>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script>
    marked.setOptions({ gfm: true, breaks: true, headerIds: true, mangle: false, highlight: (code, lang) => { if (lang && hljs.getLanguage(lang)) { return hljs.highlight(code, { language: lang }).value; } return hljs.highlightAuto(code).value; } });
    const el = document.getElementById("md_content");
    el.innerHTML = marked.parse(el.textContent);
</script>
</body>
</html>